\page tpde-main TPDE - Core Framework

Content:
- What is the core framework? What problems does it solve? What does it not solve?
- Who is the core framework for?
- TOC of the subpages

Subpages:
- Overview of the core framework. Components and compilation flow. Code Layout
- IRAdaptor Reference (required functions)
- Compiler{Base,X64,A64} Reference (required functions)
- EncodeGen Reference
- Guide: How-To implement a back-end (using TestIR as example IR); first without snippets then with snippets (maybe make this two pages)

This is the main documentation for the TPDE framework. It is designed to help implement a baseline compiler back-end (i.e. machine code generation)
when compiling from [SSA IRs](https://en.wikipedia.org/wiki/Static_single-assignment_form) and written in C++.

The framework is designed to take care of register allocation, generating unwind information, object generation or mapping to memory as well as common operations needed in a back-end,
e.g. branch generation, generating calls, handling function arguments or materializing constants.
As such, from a code generation perspective, a user needs to be primarily concerned with implementing the instruction selection for each IR instruction.
Notably, TPDE does not require you to convert an SSA IR you might already be generating to some other IR for code generation. It simply asks a user 
to implement an interface for accessing information about the IR required for the functionality the framework is implementing.

To make implementing instruction selection less tedious, TPDE includes a tool to generate so-called snippet encoders from functions written in high-level programming languages (i.e. C)
which will generate the instructions corresponding to the operations in the high-level function given some input values.
This way, a user mainly has to stitch together calls to the encoders to implement most of the IR operations. As these snippet encoders can be generated
for different architectures (currently x86-64 and AArch64), the calls to them can be written in architecture-independent code making porting a back-end to another architecture significantly easier.

However, TPDE is designed to help implement a baseline back-end. Small local optimizations, e.g. fusing adjacent instructions, are possible but if you are
looking to implement an optimizing back-end, TPDE is probably not for you.
Additionally, vector support in TPDE is currently not that good, especially if your IR supports unusual vector types. Your mileage may vary.

TPDE is also not designed to help you implement any part except the transformation from IR to machine code and will not spare you from having to look
at assembly generated by your back-end or writing the instruction selection for some operations yourself. Therefore, if you do not have some idea
what kind of machine code should be generated for your IR (and aren't willing to think about it), a more full-fledged back-end library like [LLVM](https://llvm.org/) or [Cranelift](https://cranelift.dev) might be a better fit.

This documentation is split up into multiple sections:
- \subpage tpde-overview gives an overview over TPDE, its components, the compilation flow as well as the code layout.
- \subpage tpde-adaptor is a reference for the IRAdaptor giving guidance on functions you as a user are required to implement
- \subpage tpde-compiler-ref is a reference for the Compiler classes, explaining what functions you need to implement for instruction selection
- \subpage tpde-encodegen is a reference for the tool generating snippet encoders
- \subpage tpde-guide is a guide that explains how to implement a back-end using TPDE for an example IR

<div class="section_buttons">
 
| Previous          |                              Next |
|:------------------|----------------------------------:|
|                   | [Overview](@ref tpde-overview) |
 
</div>

