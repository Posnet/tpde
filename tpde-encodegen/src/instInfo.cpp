// SPDX-FileCopyrightText: 2024 Tobias Kamm <tobias.kamm@tum.de>
// SPDX-FileCopyrightText: 2024 Tobias Schwarz <tobias.schwarz@tum.de>
//
// SPDX-License-Identifier: LicenseRef-Proprietary

#include "instInfo.hpp"
#include <cassert>
#include <cstdint>
#include <string>

const uint8_t REG = GPREG | XMMREG;
const uint8_t IMM = IMM8 | IMM16 | IMM32 | IMM64;

bool isRegOpType(OpType opType) { return opType & REG; }

bool isImmOpType(OpType opType) { return opType & IMM; }

void OpSupports::reset() {
    supportMap = 0;
    iterator   = 0;
    opIndex    = 0;
}

void OpSupports::addOpType(OpType opType) { supportMap |= opType; }

bool OpSupports::supportsReg() { return supportMap & REG; }

bool OpSupports::supportsImm() { return supportMap & IMM; }

bool OpSupports::supportsMem() { return (supportMap & MEM) != 0; }

bool OpSupports::isPhysReg(const llvm::MCInstrDesc &instrDesc) {
    return opIndex > (instrDesc.NumOperands - instrDesc.NumDefs);
}

bool OpSupports::isNOP() { return !supportMap; }

uint8_t OpSupports::getNumCases() { return __builtin_popcount(supportMap); }

uint8_t OpSupports::getOpIndex() { return opIndex; }

OpType OpSupports::getNextOpType() {
    if (!supportMap) {
        return NO_OP;
    }

    while (true) {
        iterator = ++iterator % 9;
        if (iterator == 1 && supportMap & IMM64) {
            return IMM64;
        } else if (iterator == 2 && supportMap & IMM32) {
            return IMM32;
        } else if (iterator == 3 && supportMap & IMM16) {
            return IMM16;
        } else if (iterator == 4 && supportMap & IMM8) {
            return IMM8;
        } else if (iterator == 5 && supportMap & MEM) {
            return MEM;
        } else if (iterator == 6 && supportMap & ADDR) {
            return ADDR;
        } else if (iterator == 7 && supportMap & GPREG) {
            return GPREG;
        } else if (iterator == 8 && supportMap & XMMREG) {
            return XMMREG;
        }
    }
}

OpType OpSupports::getRegOpType() {
    if (supportMap & GPREG) {
        return GPREG;
    } else if (supportMap & XMMREG) {
        return XMMREG;
    } else {
        return NO_OP;
    }
}

OpType OpSupports::getLargestImmOpType() const {
    if (supportMap & IMM64) {
        return IMM64;
    }
    if (supportMap & IMM32) {
        return IMM32;
    }
    if (supportMap & IMM16) {
        return IMM16;
    }
    if (supportMap & IMM8) {
        return IMM8;
    }
    return NO_OP;
}

void OpSupports::print(std::ostream &out) {
    if (supportMap == NO_OP) {
        out << "Ignored";
    } else {
        if (supportMap & GPREG) {
            out << "GP register; ";
        }
        if (supportMap & XMMREG) {
            out << "XMM register; ";
        }
        if (supportMap & IMM64) {
            out << "IMM64; ";
        }
        if (supportMap & IMM32) {
            out << "IMM32; ";
        }
        if (supportMap & IMM16) {
            out << "IMM16; ";
        }
        if (supportMap & IMM8) {
            out << "IMM8; ";
        }
        if (supportMap & MEM) {
            out << "Memory Operand; ";
        }
        if (supportMap & ADDR) {
            out << "Address";
        }
    }
    out << " (maps to LLVM Operand #" << static_cast<unsigned>(opIndex) << ")";
}

void InstInfo::print(std::ostream &out) {
    out << "      /* Instruction info:\n"
           "       * - operands: "
        << static_cast<int>(numOps) << "\n";
    for (int i = 0; i < numOps; i++) {
        out << "       *   - operand #" << i << ": ";
        ops[i].print(out);
        out << "\n";
    }
    out << "       * - commutable: " << (commutable ? "yes" : "no")
        << "\n"
           "       * - fadec-name: "
        << fadecName << " (" << (isFullName ? "full name" : "partial name")
        << ")\n"
           "       */\n";
}

const char *getUnsupportedReason(std::string              instName,
                                 const llvm::MCInstrDesc &instrDesc) {
    if (instName.starts_with("G_")) {
        return "Generic instrs (GlobalISel) are irrelevant";
    } else if (instrDesc.isMetaInstruction()) {
        return "is a meta instruction";
    } else if (instrDesc.isPseudo()) {
        return "is a pseudo instruction";
    } else if (instName.find("_NF") != std::string::npos
               || instName.find("_ND") != std::string::npos
               || instName.find("_EVEX") != std::string::npos) {
        return "APX instructions are not supported by hardware yet";
    } else if (instName.find("_REV") != std::string::npos) {
        return "REV-instructions should never be generated by LLVM "
               "automatically";
    } else if (instName.starts_with("ENCL")) {
        return "SGX instructions are irrelevant";
    } else if (instName.starts_with("MMX_")) {
        return "MMX instructions are irrelevant";
    } else {
        return nullptr;
    }
}
