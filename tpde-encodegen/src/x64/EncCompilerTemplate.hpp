// SPDX-FileCopyrightText: 2024 Tobias Kamm <tobias.kamm@tum.de>
// SPDX-FileCopyrightText: 2024 Tobias Schwarz <tobias.schwarz@tum.de>
//
// SPDX-License-Identifier: LicenseRef-Proprietary
#pragma once

// TODO(ts): I'd really like to keep these as normal headers in the source tree
// and generate this header
// TODO(ts): then also work with placeholders like
// -- DECLS_HERE --
// or
// -- IMPL_HERE --

namespace tpde_encgen::x64 {
static constexpr inline char ENCODER_TEMPLATE_BEGIN[] =
    R"(// SPDX-FileCopyrightText: 2024 Tobias Schwarz <tobias.schwarz@tum.de>
// SPDX-FileCopyrightText: 2024 Tobias Kamm <tobias.kamm@tum.de>
//
// SPDX-License-Identifier: LicenseRef-Proprietary AND CC0-1.0

// NOTE: This file is autogenerated by tpde-encodegen. Please DO NOT edit this file
// as all changes will be overwritten once the file is generated again.
// NOTE: Some parts of this file are subject to the default license of TPDE
// and only the autogenerated code falls under the CC0-1.0 license

// SPDX-SnippetBegin
// SPDX-License-Identifier: LicenseRef-Proprietary
#pragma once

#include <variant>

#include "base.hpp"
#include "tpde/x64/CompilerX64.hpp"

// Helper macros for assembling in the compiler
#if defined(ASMD)
    #error Got definition for ASM macros from somewhere else. Maybe you included compilers for multiple architectures?
#endif

#define ASMD(...) ASMC(this->derived(), __VA_ARGS__)

namespace tpde_encodegen {

using namespace tpde;

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          typename BaseTy>
struct EncodeCompiler {
    using CompilerX64  = tpde::x64::CompilerX64<Adaptor, Derived, BaseTy>;
    using ScratchReg   = typename CompilerX64::ScratchReg;
    using AsmReg       = typename CompilerX64::AsmReg;
    using ValuePartRef = typename CompilerX64::ValuePartRef;
    using Assembler = typename CompilerX64::Assembler;
    using Label = typename Assembler::Label;

    struct AsmOperand {
        struct Address {
            AsmReg  base;
            AsmReg  index;
            uint8_t scale;
            int32_t disp;

            explicit Address(AsmReg base, int32_t disp = 0)
                : base(base), scale(0), disp(disp) {}

            [[nodiscard]] bool has_index() const noexcept { return scale != 0; }
        };

        struct Immediate {
            union {
                u64                const_u64;
                std::array<u8, 64> const_bytes;
            };

            u32 bank, size;
        };

        // TODO(ts): evaluate the use of std::variant
        // TODO(ts): I don't like the ValuePartRefs but we also don't want to
        // force all the operands into registers at the start of the encoding...
        std::variant<std::monostate,
                     ScratchReg,
                     ValuePartRef,
                     ValuePartRef *,
                     AsmReg,
                     Address,
                     Immediate>
            state;

        AsmOperand() = default;

        AsmOperand(AsmOperand &) = delete;

        AsmOperand(AsmOperand &&other) noexcept {
            state       = std::move(other.state);
            other.state = std::monostate{};
        }

        AsmOperand &operator=(const AsmOperand &) noexcept = delete;

        AsmOperand &operator=(AsmOperand &&other) noexcept {
            if (this == &other) {
                return *this;
            }
            state       = std::move(other.state);
            other.state = std::monostate{};
            return *this;
        }

        // ReSharper disable CppNonExplicitConvertingConstructor
        // NOLINTBEGIN(*-explicit-constructor)

        // reg can't be overwritten
        AsmOperand(AsmReg reg) noexcept : state{reg} {}

        // no salvaging
        AsmOperand(const ScratchReg &reg) noexcept {
            assert(!reg.cur_reg.invalid());
            state = reg.cur_reg;
        }

        // salvaging
        AsmOperand(ScratchReg &&reg) noexcept {
            assert(!reg.cur_reg.invalid());
            state = std::move(reg);
        }

        // no salvaging
        AsmOperand(ValuePartRef &ref) noexcept {
            if (ref.is_const) {
                state = Immediate{.const_bytes = ref.state.c.const_data,
                                  .bank        = ref.state.c.bank,
                                  .size        = ref.state.c.size};
                return;
            }
            // TODO(ts): check if it is a variable_ref/frame_ptr and then
            // turning it into an Address?
            state = &ref;
        }

        // salvaging
        AsmOperand(ValuePartRef &&ref) noexcept {
            if (ref.is_const) {
                state = Immediate{.const_bytes = ref.state.c.const_data,
                                  .bank        = ref.state.c.bank,
                                  .size        = ref.state.c.size};
                return;
            }
            state = std::move(ref);
        }

        AsmOperand(Address addr) noexcept { state = addr; }

        AsmOperand(Immediate imm) noexcept { state = imm; }

        // NOLINTEND(*-explicit-constructor)
        // ReSharper restore CppNonExplicitConvertingConstructor

        [[nodiscard]] bool is_addr() const noexcept {
            return std::holds_alternative<Address>(state);
        }

        [[nodiscard]] bool is_imm() const noexcept {
            return std::holds_alternative<Immediate>(state);
        }

        [[nodiscard]] Address &addr() noexcept {
            return std::get<Address>(state);
        }

        [[nodiscard]] Immediate &imm() noexcept {
            return std::get<Immediate>(state);
        }

        [[nodiscard]] ValuePartRef &val_ref() noexcept {
            return std::get<ValuePartRef>(state);
        }

        [[nodiscard]] bool encodeable_as_imm64() const noexcept;
        [[nodiscard]] bool encodeable_as_imm32_sext() const noexcept;
        [[nodiscard]] bool encodeable_as_imm16_sext() const noexcept;
        [[nodiscard]] bool encodeable_as_imm8_sext() const noexcept;
        [[nodiscard]] bool val_ref_prefers_mem_enc() const noexcept;
        [[nodiscard]] u32  val_ref_frame_off() const noexcept;
        AsmReg             as_reg(EncodeCompiler *compiler) noexcept;
        bool try_salvage(ScratchReg &, u8 bank) noexcept;
        void try_salvage_or_materialize(EncodeCompiler *compiler,
                                        ScratchReg     &dst_scratch,
                                        u8              bank,
                                        u32             size) noexcept;
        // compatibility
        bool try_salvage(AsmReg&, ScratchReg &, u8 bank) noexcept;
        void try_salvage_or_materialize(EncodeCompiler *compiler,
                                        AsmReg &dst_reg,
                                        ScratchReg     &dst_scratch,
                                        u8              bank,
                                        u32             size) noexcept;
        void reset() noexcept;
    };

    CompilerX64 *derived() noexcept {
        return static_cast<CompilerX64 *>(static_cast<Derived *>(this));
    }

    const CompilerX64 *derived() const noexcept {
        return static_cast<const CompilerX64 *>(
            static_cast<const Derived *>(this));
    }

    static bool reg_needs_avx512(AsmReg reg) noexcept {
        if (reg.id() > AsmReg::XMM15) {
            return true;
        }
        return false;
    }

    [[nodiscard]] bool has_avx() const noexcept {
        return derived()->has_cpu_feats(CompilerX64::CPU_AVX);
    }

    [[nodiscard]] static bool disp_add_encodeable(int32_t disp, int32_t add) noexcept {
        const auto tmp = static_cast<int64_t>(disp) + add;
        return (static_cast<int64_t>(static_cast<int32_t>(tmp)) == tmp);
    }

// SPDX-SnippetEnd
// SPDX-SnippetBegin
// SPDX-License-Identifier: CC0-1.0
// clang-format off
)";

static constexpr inline char ENCODER_TEMPLATE_END[] = R"(
};
// SPDX-SnippetEnd
)";

static constexpr inline char ENCODER_IMPL_TEMPLATE_BEGIN[] = R"(

// SPDX-SnippetBegin
// SPDX-License-Identifier: LicenseRef-Proprietary
template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::
    encodeable_as_imm64() const noexcept {
    if (!is_imm() || std::get<Immediate>(state).size > 8) {
        return false;
    }

    const u64 imm = std::get<Immediate>(state).const_u64;
    return imm;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::
    encodeable_as_imm32_sext() const noexcept {
    if (!is_imm()) {
        return false;
    }

    assert(std::get<Immediate>(state).size <= 8);
    const u64 imm = std::get<Immediate>(state).const_u64;
    return static_cast<i64>(static_cast<i32>(imm)) == static_cast<i64>(imm);
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::
    encodeable_as_imm16_sext() const noexcept {
    if (!is_imm()) {
        return false;
    }

    const auto& info = std::get<Immediate>(state);
    assert(info.bank == 0);
    assert(info.size <= 8);

    const u64 imm = std::get<Immediate>(state).const_u64;
    return static_cast<i64>(static_cast<i16>(imm)) == static_cast<i64>(imm);
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::
    encodeable_as_imm8_sext() const noexcept {
    if (!is_imm()) {
        return false;
    }

    const auto& info = std::get<Immediate>(state);
    assert(info.bank == 0);
    assert(info.size <= 8);

    const u64 imm = std::get<Immediate>(state).const_u64;
    return static_cast<i64>(static_cast<i8>(imm)) == static_cast<i8>(imm);
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::
    val_ref_prefers_mem_enc() const noexcept {
    const ValuePartRef *ptr;
    if (std::holds_alternative<ValuePartRef>(state)) {
        ptr = &std::get<ValuePartRef>(state);
    } else if (std::holds_alternative<ValuePartRef *>(state)) {
        ptr = std::get<ValuePartRef *>(state);
    } else {
        return false;
    }

    if (ptr->is_const) {
        return false;
    }

    const auto ap = ptr->assignment();
    return (!ap.register_valid() && !ap.variable_ref());
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
u32 EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::val_ref_frame_off()
    const noexcept {
    if (std::holds_alternative<ValuePartRef>(state)) {
        const auto &val_ref = std::get<ValuePartRef>(state);
        assert(!val_ref.is_const);
        const auto ap = val_ref.assignment();
        assert(!ap.variable_ref());
        return ap.frame_off();
    } else {
        assert(std::holds_alternative<ValuePartRef *>(state));
        const auto *val_ref = std::get<ValuePartRef *>(state);
        assert(!val_ref->is_const);
        const auto ap = val_ref->assignment();
        assert(!ap.variable_ref());
        return ap.frame_off();
    }
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
typename EncodeCompiler<Adaptor, Derived, BaseTy>::AsmReg
    EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::as_reg(
        EncodeCompiler<Adaptor, Derived, BaseTy> *compiler) noexcept {
    if (std::holds_alternative<ScratchReg>(state)) {
        return std::get<ScratchReg>(state).cur_reg;
    }
    if (std::holds_alternative<ValuePartRef>(state)) {
        return std::get<ValuePartRef>(state).alloc_reg();
    }
    if (std::holds_alternative<ValuePartRef *>(state)) {
        return std::get<ValuePartRef *>(state)->alloc_reg();
    }
    if (std::holds_alternative<AsmReg>(state)) {
        return std::get<AsmReg>(state);
    }
    if (is_imm()) {
        const auto &data = std::get<Immediate>(state);
        ScratchReg  dst{compiler->derived()};
        const auto  dst_reg = dst.alloc_from_bank(data.bank);
        compiler->derived()->materialize_constant(
            data.const_bytes, data.bank, data.size, dst_reg);
        state = std::move(dst);
        return dst_reg;
    }
    // TODO(ts): allow mem operands with scratchreg param?
    assert(0);
    exit(1);
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::try_salvage(
    ScratchReg &dst_scratch, const u8 bank) noexcept {
    if (std::holds_alternative<ScratchReg>(state)) {
        assert(std::get<ScratchReg>(state).compiler->register_file.reg_bank(
                   std::get<ScratchReg>(state).cur_reg)
               == bank);
        dst_scratch = std::move(std::get<ScratchReg>(state));
        return true;
    }
    if (std::holds_alternative<ValuePartRef>(state)) {
        auto &ref = std::get<ValuePartRef>(state);
        assert(ref.bank() == bank);
        if (ref.can_salvage()) {
            auto reg = ref.salvage();
            dst_scratch.alloc_specific(reg);
            return true;
        }
        // dst = std::get<ValuePartRef>(state).alloc_reg();
        // return;
    }

    dst_scratch.alloc_from_bank(bank);
    return false;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::try_salvage(
    AsmReg &dst_reg, ScratchReg &dst_scratch, const u8 bank) noexcept {
    const auto res = try_salvage(dst_scratch, bank);
    dst_reg = dst_scratch.cur_reg;
    return res;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
void EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::
    try_salvage_or_materialize(EncodeCompiler *compiler,
                               AsmReg         &dst_reg,
                               ScratchReg     &dst_scratch,
                               u8              bank,
                               u32             size) noexcept {
    try_salvage_or_materialize(compiler, dst_scratch, bank, size);
    dst_reg = dst_scratch.cur_reg;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
void EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::
    try_salvage_or_materialize(EncodeCompiler *compiler,
                               ScratchReg     &dst_scratch,
                               u8              bank,
                               u32             size) noexcept {
    AsmReg val = this->as_reg(compiler);
    if (!this->try_salvage(dst_scratch, bank)) {
        if (bank == 0) {
            if (size <= 4) {
                ASMC(compiler->derived(), MOV32rr, dst_scratch.cur_reg, val);
            } else {
                ASMC(compiler->derived(), MOV64rr, dst_scratch.cur_reg, val);
            }
        } else {
            // TODO
            assert(0);
                exit(1);
            }
        }
    }

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
void EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::reset() noexcept {
    state = std::monostate{};
}

// SPDX-SnippetEnd
// SPDX-SnippetBegin
// SPDX-License-Identifier: CC0-1.0
)";


static constexpr inline char ENCODER_IMPL_TEMPLATE_END[] = R"(
} // namespace tpde_encodegen

#undef ASMD
// SPDX-SnippetEnd
)";
} // namespace tpde_encgen::x64
