// SPDX-FileCopyrightText: 2024 Tobias Schwarz <tobias.schwarz@tum.de>
// SPDX-FileCopyrightText: 2024 Tobias Kamm <tobias.kamm@tum.de>
//
// SPDX-License-Identifier: LicenseRef-Proprietary AND CC0-1.0

// NOTE: This file is autogenerated by tpde-encodegen. Please DO NOT edit this file
// as all changes will be overwritten once the file is generated again.
// NOTE: Some parts of this file are subject to the default license of TPDE
// and only the autogenerated code falls under the CC0-1.0 license

// SPDX-SnippetBegin
// SPDX-License-Identifier: LicenseRef-Proprietary
#pragma once

#include <variant>

#include "tpde/base.hpp"
#include "tpde/arm64/CompilerA64.hpp"

// Helper macros for assembling in the compiler
#if defined(ASMD)
    #error Got definition for ASM macros from somewhere else. Maybe you included compilers for multiple architectures?
#endif

#define ASMD(...) ASMC(this->derived(), __VA_ARGS__)

namespace tpde_encodegen {

using namespace tpde;

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          typename BaseTy,
          typename Config>
struct EncodeCompiler {
    using CompilerA64  = tpde::a64::CompilerA64<Adaptor, Derived, BaseTy, Config>;
    using ScratchReg   = typename CompilerA64::ScratchReg;
    using AsmReg       = typename CompilerA64::AsmReg;
    using ValuePartRef = typename CompilerA64::ValuePartRef;
    using Assembler    = typename CompilerA64::Assembler;
    using Label        = typename Assembler::Label;
    using ValLocalIdx  = typename CompilerA64::ValLocalIdx;
    using SymRef       = typename Assembler::SymRef;

    struct AsmOperand {
        struct Expr {
            std::variant<AsmReg, ScratchReg> base;
            std::variant<AsmReg, ScratchReg> index;
            i64                              scale;
            i64                              disp;

            explicit Expr()
                : base{AsmReg::make_invalid()}, scale{0}, disp{0} {}

            explicit Expr(AsmReg base, i64 disp = 0)
                : base(base), scale(0), disp(disp) {}

            explicit Expr(ScratchReg &&base, i64 disp = 0)
                : base(std::move(base)), scale(0), disp(disp) {}

            AsmReg base_reg() const noexcept {
                if (std::holds_alternative<AsmReg>(base)) {
                    return std::get<AsmReg>(base);
                }
                return std::get<ScratchReg>(base).cur_reg;
            }

            [[nodiscard]] bool has_base() const noexcept {
                if (std::holds_alternative<AsmReg>(base)) {
                    return std::get<AsmReg>(base).valid();
                }
                return true;
            }

            AsmReg index_reg() const noexcept {
                assert(scale != 0 && "index_reg() called on invalid index");
                assert((scale != 1 || has_base()) &&
                       "Expr with unscaled index must have base");
                if (std::holds_alternative<AsmReg>(index)) {
                    return std::get<AsmReg>(index);
                }
                return std::get<ScratchReg>(index).cur_reg;
            }

            [[nodiscard]] bool has_index() const noexcept { return scale != 0; }
        };

        struct Immediate {
            union {
                u64                const_u64;
                std::array<u8, 64> const_bytes;
            };

            u32 bank, size;
        };

        // TODO(ts): evaluate the use of std::variant
        // TODO(ts): I don't like the ValuePartRefs but we also don't want to
        // force all the operands into registers at the start of the encoding...
        std::variant<std::monostate,
                     ValuePartRef,
                     ValuePartRef *,
                     ScratchReg,
                     Expr,
                     Immediate>
            state;

        AsmOperand() = default;

        AsmOperand(AsmOperand &) = delete;

        AsmOperand(AsmOperand &&other) noexcept {
            state       = std::move(other.state);
            other.state = std::monostate{};
        }

        AsmOperand &operator=(const AsmOperand &) noexcept = delete;

        AsmOperand &operator=(AsmOperand &&other) noexcept {
            if (this == &other) {
                return *this;
            }
            state       = std::move(other.state);
            other.state = std::monostate{};
            return *this;
        }

        // ReSharper disable CppNonExplicitConvertingConstructor
        // NOLINTBEGIN(*-explicit-constructor)

        // reg can't be overwritten
        AsmOperand(AsmReg reg) noexcept : state{Expr(reg)} {}

        // no salvaging
        AsmOperand(const ScratchReg &reg) noexcept {
            assert(!reg.cur_reg.invalid());
            state = Expr(reg.cur_reg);
        }

        // salvaging
        AsmOperand(ScratchReg &&reg) noexcept {
            assert(!reg.cur_reg.invalid());
            state = std::move(reg);
        }

        // no salvaging
        AsmOperand(ValuePartRef &ref) noexcept {
            if (ref.is_const) {
                state = Immediate{.const_bytes = ref.state.c.const_data,
                                  .bank        = ref.state.c.bank,
                                  .size        = ref.state.c.size};
                return;
            }
            // TODO(ts): check if it is a variable_ref/frame_ptr and then
            // turning it into an Address?
            state = &ref;
        }

        // salvaging
        AsmOperand(ValuePartRef &&ref) noexcept {
            if (ref.is_const) {
                state = Immediate{.const_bytes = ref.state.c.const_data,
                                  .bank        = ref.state.c.bank,
                                  .size        = ref.state.c.size};
                return;
            }
            state = std::move(ref);
        }

        AsmOperand(Expr &&expr) noexcept {
            state = std::move(expr);
        }

        AsmOperand(Immediate imm) noexcept { state = imm; }

        // NOLINTEND(*-explicit-constructor)
        // ReSharper restore CppNonExplicitConvertingConstructor

        [[nodiscard]] bool is_expr() const noexcept {
            return std::holds_alternative<Expr>(state);
        }

        [[nodiscard]] bool is_imm() const noexcept {
            return std::holds_alternative<Immediate>(state);
        }

        [[nodiscard]] const Immediate &imm() const noexcept {
            return std::get<Immediate>(state);
        }

        [[nodiscard]] ValuePartRef &val_ref() noexcept {
            return std::get<ValuePartRef>(state);
        }

        std::optional<u64> encodeable_as_imm() const noexcept {
            if (is_imm() && imm().size <= 8) {
                return imm().const_u64;
            }
            return std::nullopt;
        }
        std::optional<u64> encodeable_as_immarith() const noexcept {
            if (is_imm() && imm().size <= 8) {
                u64 val = imm().const_u64;
                val     = static_cast<i64>(val) < 0 ? -val : val;
                if ((val & 0xfff) == val || (val & 0xff'f000) == val) {
                    return imm().const_u64;
                }
            }
            return std::nullopt;
        }
        std::optional<std::pair<AsmReg, u64>> encodeable_with_mem_uoff12(EncodeCompiler *compiler, u64 off, unsigned shift) noexcept;

        AsmReg as_reg(EncodeCompiler *compiler) noexcept;
        bool   try_salvage(ScratchReg &, u8 bank) noexcept;
        AsmReg as_reg_try_salvage(EncodeCompiler *, ScratchReg &, u8 bank) noexcept;
        void   try_salvage_or_materialize(EncodeCompiler *compiler,
                                                 ScratchReg     &dst_scratch,
                                                 u8              bank,
                                                 u32             size) noexcept;
        // compatibility
        bool          try_salvage(AsmReg &, ScratchReg &, u8 bank) noexcept;
        void          try_salvage_or_materialize(EncodeCompiler *compiler,
                                                 AsmReg         &dst_reg,
                                                 ScratchReg     &dst_scratch,
                                                 u8              bank,
                                                 u32             size) noexcept;
        void          reset() noexcept;
    };

    CompilerA64 *derived() noexcept {
        return static_cast<CompilerA64 *>(static_cast<Derived *>(this));
    }

    const CompilerA64 *derived() const noexcept {
        return static_cast<const CompilerA64 *>(
            static_cast<const Derived *>(this));
    }

    struct FixedRegBackup {
        ScratchReg  scratch;
        ValLocalIdx local_idx;
        u32         part;
        u32         lock_count;
    };

    void scratch_alloc_specific(AsmReg                              reg,
                                ScratchReg                         &scratch,
                                std::initializer_list<AsmOperand *> operands,
                                FixedRegBackup &backup_reg) noexcept;

    void scratch_check_fixed_backup(ScratchReg     &scratch,
                                    FixedRegBackup &backup_reg,
                                    bool            is_ret_reg) noexcept;

// SPDX-SnippetEnd
// SPDX-SnippetBegin
// SPDX-License-Identifier: CC0-1.0
// clang-format off

    bool encode_loadi8(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi16(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi24(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi40(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi48(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi56(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi128(AsmOperand param_0, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_loadf32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadf64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadv128(AsmOperand param_0, ScratchReg &result_0);
    bool encode_storei8(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei16(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei32(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei64(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei24(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei40(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei48(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei56(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2);
    bool encode_storef32(AsmOperand param_0, AsmOperand param_1);
    bool encode_storef64(AsmOperand param_0, AsmOperand param_1);
    bool encode_storev128(AsmOperand param_0, AsmOperand param_1);
    bool encode_addi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_subi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_muli32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_udivi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_sdivi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_uremi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_sremi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_landi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_lori32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_lxori32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_shli32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_shri32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_ashri32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_absi32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_addi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_subi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_muli64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_udivi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_sdivi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_uremi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_sremi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_landi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_lori64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_lxori64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_shli64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_shri64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_ashri64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_absi64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_addi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_subi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_muli128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_landi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_lori128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_lxori128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_shli128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_shri128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_ashri128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_shli128_lt64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_shli128_ge64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_shri128_lt64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_shri128_ge64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_ashri128_lt64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_ashri128_ge64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cttzi32_zero_poison(AsmOperand param_0, ScratchReg &result_0);
    bool encode_cttzi64_zero_poison(AsmOperand param_0, ScratchReg &result_0);
    bool encode_cttzi8(AsmOperand param_0, ScratchReg &result_0);
    bool encode_cttzi16(AsmOperand param_0, ScratchReg &result_0);
    bool encode_cttzi32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_cttzi64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_ctlzi8_zero_poison(AsmOperand param_0, ScratchReg &result_0);
    bool encode_ctlzi16_zero_poison(AsmOperand param_0, ScratchReg &result_0);
    bool encode_ctlzi32_zero_poison(AsmOperand param_0, ScratchReg &result_0);
    bool encode_ctlzi64_zero_poison(AsmOperand param_0, ScratchReg &result_0);
    bool encode_ctlzi8(AsmOperand param_0, ScratchReg &result_0);
    bool encode_ctlzi16(AsmOperand param_0, ScratchReg &result_0);
    bool encode_ctlzi32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_ctlzi64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_of_add_i8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_sub_i8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_mul_i8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_add_u8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_sub_u8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_mul_u8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_add_i16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_sub_i16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_mul_i16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_add_u16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_sub_u16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_mul_u16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_add_i32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_sub_i32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_mul_i32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_add_u32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_sub_u32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_mul_u32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_add_i64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_sub_i64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_mul_i64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_add_u64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_sub_u64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_mul_u64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_addf32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_subf32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_mulf32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_divf32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_addf64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_subf64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_mulf64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_divf64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fnegf32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_fnegf64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_fabsf32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_fabsf64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_fmaf32(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0);
    bool encode_fmaf64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0);
    bool encode_f64tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f32tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f32toi32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f32tou32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f32toi64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f32tou64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f64toi32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f64tou32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f64toi64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f64tou64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_i8tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_i16tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_i32tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_i64tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_u8tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_u16tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_u32tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_u64tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_i8tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_i16tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_i32tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_i64tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_u8tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_u16tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_u32tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_u64tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_sext_8_to_32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_sext_8_to_64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_sext_16_to_32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_sext_16_to_64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_sext_32_to_64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_sext_arbitrary_to_32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_sext_arbitrary_to_64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fill_with_sign64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_zext_8_to_32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_zext_16_to_32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_zext_32_to_64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_cmpxchg_u64_monotonic_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_acquire_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_acquire_acquire(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_release_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_release_acquire(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_acqrel_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_acqrel_acquire(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_seqcst_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_seqcst_acquire(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_seqcst_seqcst(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_atomic_load_u8_mono(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u16_mono(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u32_mono(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u64_mono(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u8_acq(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u16_acq(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u32_acq(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u64_acq(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u8_seqcst(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u16_seqcst(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u32_seqcst(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u64_seqcst(AsmOperand param_0, ScratchReg &result_0);
    bool encode_select_i32(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0);
    bool encode_select_i64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0);
    bool encode_select_i128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, AsmOperand param_4, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_select_f32(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0);
    bool encode_select_f64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0);
    bool encode_fcmp_oeq_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ogt_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_oge_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_olt_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ole_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_one_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ord_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ueq_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ugt_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_uge_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ult_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ule_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_une_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_uno_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_oeq_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ogt_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_oge_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_olt_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ole_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_one_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ord_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ueq_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ugt_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_uge_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ult_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ule_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_une_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_uno_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_snan_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_qnan_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_ninf_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_nnorm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_nsnorm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_nzero_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_pzero_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_psnorm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_pnorm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_pinf_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_nan_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_inf_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_norm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_finite_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_snan_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_qnan_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_ninf_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_nnorm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_nsnorm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_nzero_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_pzero_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_psnorm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_pnorm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_pinf_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_nan_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_inf_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_norm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_finite_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_prefetch_rl0(AsmOperand param_0);
    bool encode_prefetch_rl1(AsmOperand param_0);
    bool encode_prefetch_rl2(AsmOperand param_0);
    bool encode_prefetch_rl3(AsmOperand param_0);
    bool encode_prefetch_wl0(AsmOperand param_0);
    bool encode_prefetch_wl1(AsmOperand param_0);
    bool encode_prefetch_wl2(AsmOperand param_0);
    bool encode_prefetch_wl3(AsmOperand param_0);




};
// SPDX-SnippetEnd



// SPDX-SnippetBegin
// SPDX-License-Identifier: LicenseRef-Proprietary
// clang-format on
template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
std::optional<std::pair<typename EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmReg, u64>> EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::
    encodeable_with_mem_uoff12(EncodeCompiler<Adaptor, Derived, BaseTy, Config> *compiler, u64 off, unsigned shift) noexcept {
    Expr *expr = std::get_if<Expr>(&state);
    if (!expr || !expr->has_base()) {
        return std::nullopt;
    }

    u64 res_off = expr->disp + off;
    if (res_off >= (u64{0x1000} << shift) || (res_off & ((1 << shift) - 1))) {
        return std::nullopt;
    }
    if (res_off == 0 && expr->has_index()) {
        // In this case, try index encoding.
        return std::nullopt;
    }

    if (!expr->has_index()) {
        return std::make_pair(expr->base_reg(), res_off);
    }
    if ((expr->scale & (expr->scale - 1)) != 0) {
        return std::nullopt;
    }

    ScratchReg scratch{compiler->derived()};
    AsmReg base_reg = expr->base_reg();
    AsmReg index_reg = expr->index_reg();
    if (std::holds_alternative<ScratchReg>(expr->base)) {
        scratch = std::move(std::get<ScratchReg>(expr->base));
    } else if (std::holds_alternative<ScratchReg>(expr->index)) {
        scratch = std::move(std::get<ScratchReg>(expr->index));
    } else {
        (void)scratch.alloc_gp();
    }
    const auto scale_shift = __builtin_ctzl(expr->scale);
    AsmReg dst = scratch.cur_reg;
    ASMC(compiler->derived(), ADDx_lsl, dst, base_reg, index_reg, scale_shift);
    if (expr->disp != 0) {
        expr->base = std::move(scratch);
        expr->index = AsmReg::make_invalid();
        expr->scale = 0;
    } else {
        state = std::move(scratch);
    }

    return std::make_pair(dst, res_off);
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
typename EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmReg
    EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::as_reg(
        EncodeCompiler<Adaptor, Derived, BaseTy, Config> *compiler) noexcept {
    if (std::holds_alternative<ScratchReg>(state)) {
        return std::get<ScratchReg>(state).cur_reg;
    }
    if (std::holds_alternative<ValuePartRef>(state)) {
        auto      &val_ref = std::get<ValuePartRef>(state);
        const auto reg     = val_ref.alloc_reg();
        val_ref.lock();
        return reg;
    }
    if (std::holds_alternative<ValuePartRef *>(state)) {
        auto      &val_ref = *std::get<ValuePartRef *>(state);
        const auto reg     = val_ref.alloc_reg();
        val_ref.lock();
        return reg;
    }
    if (is_imm()) {
        const auto &data = std::get<Immediate>(state);
        ScratchReg  dst{compiler->derived()};
        const auto  dst_reg = dst.alloc_from_bank(data.bank);
        compiler->derived()->materialize_constant(
            data.const_bytes, data.bank, data.size, dst_reg);
        state = std::move(dst);
        return dst_reg;
    }
    Expr *expr = std::get_if<Expr>(&state);
    if (!expr) {
        // TODO(ts): allow mem operands with scratchreg param?
        assert(0);
        exit(1);
    }

    if (expr->has_base() && !expr->has_index() && expr->disp == 0) {
        return expr->base_reg();
    }

    ScratchReg scratch{compiler->derived()};
    if (!expr->has_base() && !expr->has_index()) {
        AsmReg dst = scratch.alloc_gp();
        compiler->derived()->materialize_constant(expr->disp, 0, 8, dst);
        expr->disp = 0;
    } else if (!expr->has_base() && expr->has_index()) {
        AsmReg index_reg = expr->index_reg();
        if (std::holds_alternative<ScratchReg>(expr->index)) {
            scratch = std::move(std::get<ScratchReg>(expr->index));
        } else {
            (void)scratch.alloc_gp();
        }
        AsmReg dst = scratch.cur_reg;
        if ((expr->scale & (expr->scale - 1)) == 0) {
            const auto shift = __builtin_ctzl(expr->scale);
            ASMC(compiler->derived(), LSLxi, dst, index_reg, shift);
        } else {
            ScratchReg scratch2{compiler->derived()};
            AsmReg tmp2 = scratch2.alloc_gp();
            compiler->derived()->materialize_constant(expr->scale, 0, 8, tmp2);
            ASMC(compiler->derived(), MULx, dst, index_reg, tmp2);
        }
    } else if (expr->has_base() && expr->has_index()) {
        AsmReg base_reg = expr->base_reg();
        AsmReg index_reg = expr->index_reg();
        if (std::holds_alternative<ScratchReg>(expr->base)) {
            scratch = std::move(std::get<ScratchReg>(expr->base));
        } else if (std::holds_alternative<ScratchReg>(expr->index)) {
            scratch = std::move(std::get<ScratchReg>(expr->index));
        } else {
            (void)scratch.alloc_gp();
        }
        AsmReg dst = scratch.cur_reg;
        if ((expr->scale & (expr->scale - 1)) == 0) {
            const auto shift = __builtin_ctzl(expr->scale);
            ASMC(compiler->derived(), ADDx_lsl, dst, base_reg, index_reg, shift);
        } else {
            ScratchReg scratch2{compiler->derived()};
            AsmReg tmp2 = scratch2.alloc_gp();
            compiler->derived()->materialize_constant(expr->scale, 0, 8, tmp2);
            ASMC(compiler->derived(), MULx, tmp2, index_reg, tmp2);
            ASMC(compiler->derived(), ADDx, dst, base_reg, tmp2);
        }
    } else if (expr->has_base() && !expr->has_index()) {
        AsmReg base_reg = expr->base_reg();
        if (std::holds_alternative<ScratchReg>(expr->base)) {
            scratch = std::move(std::get<ScratchReg>(expr->base));
        } else {
            (void)scratch.alloc_gp();
        }
        AsmReg dst = scratch.cur_reg;
        if (ASMIFC(compiler->derived(), ADDxi, dst, base_reg, expr->disp)) {
            expr->disp = 0;
        } else {
            ASMC(compiler->derived(), MOVx, dst, base_reg);
        }
    } else {
        assert(0);
    }

    AsmReg dst = scratch.cur_reg;
    if (expr->disp != 0) {
        if (!ASMIFC(compiler->derived(), ADDxi, dst, dst, expr->disp)) {
            ScratchReg scratch2{compiler->derived()};
            AsmReg tmp2 = scratch2.alloc_gp();
            compiler->derived()->materialize_constant(expr->disp, 0, 8, tmp2);
            ASMC(compiler->derived(), ADDx, dst, dst, tmp2);
        }
    }

    state = std::move(scratch);
    return dst;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::try_salvage(
    ScratchReg &dst_scratch, const u8 bank) noexcept {
    if (!dst_scratch.cur_reg.invalid()) {
        return false;
    }

    if (std::holds_alternative<ScratchReg>(state)) {
        assert(std::get<ScratchReg>(state).compiler->register_file.reg_bank(
                   std::get<ScratchReg>(state).cur_reg)
               == bank);
        dst_scratch = std::move(std::get<ScratchReg>(state));
        state       = std::monostate{};
        return true;
    } else if (std::holds_alternative<ValuePartRef>(state)) {
        auto &ref = std::get<ValuePartRef>(state);
        assert(ref.bank() == bank);
        if (ref.can_salvage()) {
            auto reg = ref.salvage();
            dst_scratch.alloc_specific(reg);
            return true;
        }
        // dst = std::get<ValuePartRef>(state).alloc_reg();
        // return;
    } else if (std::holds_alternative<Immediate>(state)) {
        this->as_reg(static_cast<Derived *>(dst_scratch.compiler));
        assert(std::holds_alternative<ScratchReg>(state));
        assert(std::get<ScratchReg>(state).compiler->register_file.reg_bank(
                   std::get<ScratchReg>(state).cur_reg)
               == bank);

        dst_scratch = std::move(std::get<ScratchReg>(state));
        state       = std::monostate{};
        return true;
    }

    dst_scratch.alloc_from_bank(bank);
    return false;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
typename EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmReg
    EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::
    as_reg_try_salvage(EncodeCompiler *compiler,
                       ScratchReg &dst_scratch,
                       u8 bank) noexcept {
    if (try_salvage(dst_scratch, bank)) {
        return dst_scratch.cur_reg;
    }
    return as_reg(compiler);
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::try_salvage(
    AsmReg &dst_reg, ScratchReg &dst_scratch, const u8 bank) noexcept {
    const auto res = try_salvage(dst_scratch, bank);
    dst_reg        = dst_scratch.cur_reg;
    return res;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
void EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::
    try_salvage_or_materialize(EncodeCompiler *compiler,
                               AsmReg         &dst_reg,
                               ScratchReg     &dst_scratch,
                               u8              bank,
                               u32             size) noexcept {
    try_salvage_or_materialize(compiler, dst_scratch, bank, size);
    dst_reg = dst_scratch.cur_reg;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
void EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::
    try_salvage_or_materialize(EncodeCompiler *compiler,
                               ScratchReg     &dst_scratch,
                               u8              bank,
                               u32             size) noexcept {
    if (!this->try_salvage(dst_scratch, bank)) {
        if (bank == 0) {
            if (std::holds_alternative<Immediate>(state)) {
                const auto &data = std::get<Immediate>(state);
                compiler->derived()->materialize_constant(data.const_bytes,
                                                          data.bank,
                                                          data.size,
                                                          dst_scratch.cur_reg);
                return;
            }

            AsmReg val = this->as_reg(compiler);
            if (size <= 4) {
                ASMC(compiler->derived(), MOVw, dst_scratch.cur_reg, val);
            } else {
                ASMC(compiler->derived(), MOVx, dst_scratch.cur_reg, val);
            }
        } else {
            AsmReg val = this->as_reg(compiler);
            ASMC(compiler->derived(), MOV8b, dst_scratch.cur_reg, val);
        }
    }
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
void EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::
    reset() noexcept {
    state = std::monostate{};
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
void EncodeCompiler<Adaptor, Derived, BaseTy, Config>::scratch_alloc_specific(
    AsmReg                              reg,
    ScratchReg                         &scratch,
    std::initializer_list<AsmOperand *> operands,
    FixedRegBackup                     &backup_reg) noexcept {
    if (!derived()->register_file.is_fixed(reg)) [[likely]] {
        scratch.alloc_specific(reg);
        return;
    }

    const auto bank = derived()->register_file.reg_bank(reg);
    if (bank != 0) {
        // TODO(ts): need to know the size
        assert(0);
        exit(1);
    }

    const auto alloc_backup = [this, &backup_reg, &scratch, reg, bank]() {
        const auto bak_reg    = backup_reg.scratch.alloc_from_bank(bank);
        auto      &reg_file   = derived()->register_file;
        auto      &assignment = reg_file.assignments[reg.id()];
        backup_reg.local_idx  = assignment.local_idx;
        backup_reg.part       = assignment.part;
        backup_reg.lock_count = assignment.lock_count;

        assignment.local_idx  = CompilerA64::INVALID_VAL_LOCAL_IDX;
        assignment.part       = 0;
        assignment.lock_count = 0;

        assert(scratch.cur_reg.invalid());
        scratch.cur_reg = reg;

        ASMD(MOV64rr, bak_reg, reg);
    };

    // check if one of the operands holds the fixed register
    for (auto *op_ptr : operands) {
        auto &op = op_ptr->state;
        if (std::holds_alternative<ScratchReg>(op)) {
            auto &op_scratch = std::get<ScratchReg>(op);
            if (op_scratch.cur_reg == reg) {
                scratch = std::move(op_scratch);
                op_scratch.alloc_from_bank(bank);
                ASMD(MOVx, op_scratch.cur_reg, reg);
                return;
            }
            continue;
        }

        if (std::holds_alternative<ValuePartRef>(op)) {
            auto &op_ref = std::get<ValuePartRef>(op);
            if (!op_ref.is_const) {
                assert(!op_ref.state.v.locked);
                const auto ap = op_ref.assignment();
                if (ap.register_valid()) {
                    assert(AsmReg{ap.full_reg_id()} != reg);
                }
            }
            continue;
        }

        if (std::holds_alternative<ValuePartRef *>(op)) {
            auto &op_ref = *std::get<ValuePartRef *>(op);
            if (!op_ref.is_const) {
                assert(!op_ref.state.v.locked);
                const auto ap = op_ref.assignment();
                if (ap.register_valid()) {
                    assert(AsmReg{ap.full_reg_id()} != reg);
                }
            }
            continue;
        }

        if (std::holds_alternative<typename AsmOperand::Expr>(op)) {
            auto &expr = std::get<typename AsmOperand::Expr>(op);
            if (expr.base_reg() == reg) {
                if (std::holds_alternative<ScratchReg>(expr.base)) {
                    auto &op_scratch = std::get<ScratchReg>(expr.base);
                    scratch          = std::move(op_scratch);
                    op_scratch.alloc_from_bank(bank);
                    ASMD(MOVx, op_scratch.cur_reg, reg);
                } else {
                    alloc_backup();
                    expr.base = backup_reg.scratch.cur_reg;
                }
                return;
            }
            if (expr.scale != 0 && expr.index_reg() == reg) {
                if (std::holds_alternative<ScratchReg>(expr.index)) {
                    auto &op_scratch = std::get<ScratchReg>(expr.index);
                    scratch          = std::move(op_scratch);
                    op_scratch.alloc_from_bank(bank);
                    ASMD(MOVx, op_scratch.cur_reg, reg);
                } else {
                    alloc_backup();
                    expr.index = backup_reg.scratch.cur_reg;
                }
                return;
            }
            continue;
        }
    }

    // otherwise temporarily store it somewhere else
    alloc_backup();
    return;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
void EncodeCompiler<Adaptor, Derived, BaseTy, Config>::
    scratch_check_fixed_backup(ScratchReg     &scratch,
                               FixedRegBackup &backup_reg,
                               const bool      is_ret_reg) noexcept {
    if (backup_reg.scratch.cur_reg.invalid()) [[likely]] {
        return;
    }

    assert(!scratch.cur_reg.invalid());
    auto &reg_file        = derived()->register_file;
    auto &assignment      = reg_file.assignments[scratch.cur_reg.id()];
    assignment.local_idx  = backup_reg.local_idx;
    assignment.part       = backup_reg.part;
    assignment.lock_count = backup_reg.lock_count;

    assert(reg_file.reg_bank(scratch.cur_reg) == 0);
    if (is_ret_reg) {
        // TODO(ts): allocate another scratch? Though at this point the scratch
        // regs have not been released yet so we might need to spill...

        // need to switch around backup and reg so it can be returned as a
        // ScratchReg
        assert(false);
        // ASMD(XCHG64rr, scratch.cur_reg, backup_reg.scratch.cur_reg);
        // scratch.cur_reg            = backup_reg.scratch.cur_reg;
        // backup_reg.scratch.cur_reg = AsmReg::make_invalid();
    } else {
        ASMD(MOVx, scratch.cur_reg, backup_reg.scratch.cur_reg);

        scratch.cur_reg = AsmReg::make_invalid();
        backup_reg.scratch.reset();
    }
}

// clang-format off
// SPDX-SnippetEnd
// SPDX-SnippetBegin
// SPDX-License-Identifier: CC0-1.0

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi8(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $w0 = LDRBBui killed renamable $x0, 0 :: (load (s8) from %ir.0, !tbaa !4)
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function loadi8.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = LDRBBui killed renamable $x0, 0 :: (load (s8) from %ir.0, !tbaa !4)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 0);
    if (cond0) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDRBu, scratch_x0.cur_reg, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDRBu, scratch_x0.cur_reg, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi16(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $w0 = LDRHHui killed renamable $x0, 0 :: (load (s16) from %ir.0, !tbaa !7)
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function loadi16.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = LDRHHui killed renamable $x0, 0 :: (load (s16) from %ir.0, !tbaa !7)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 1);
    if (cond0) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDRHu, scratch_x0.cur_reg, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDRHu, scratch_x0.cur_reg, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $w0 = LDRWui killed renamable $x0, 0 :: (load (s32) from %ir.0, !tbaa !9)
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function loadi32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = LDRWui killed renamable $x0, 0 :: (load (s32) from %ir.0, !tbaa !9)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 2);
    if (cond0) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDRwu, scratch_x0.cur_reg, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDRwu, scratch_x0.cur_reg, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $x0 = LDRXui killed renamable $x0, 0 :: (load (s64) from %ir.0, !tbaa !11)
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function loadi64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $x0 = LDRXui killed renamable $x0, 0 :: (load (s64) from %ir.0, !tbaa !11)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 3);
    if (cond0) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDRxu, scratch_x0.cur_reg, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDRxu, scratch_x0.cur_reg, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi24(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi24: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $w8 = LDRBBui renamable $x0, 2 :: (load (s8) from %ir.0 + 2)
    //   renamable $w9 = LDRHHui killed renamable $x0, 0 :: (load (s16) from %ir.0, align 1)
    //   renamable $w0 = ORRWrs killed renamable $w9, killed renamable $w8, 16
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function loadi24.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = LDRBBui renamable $x0, 2 :: (load (s8) from %ir.0 + 2)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x2, 0);
    if (cond0) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LDRBu, scratch_x8.cur_reg, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LDRBu, scratch_x8.cur_reg, op1, 0x2);
        break;
    }
    }
    } while (false);
    // result x8 is marked as alive


    // renamable $w9 = LDRHHui killed renamable $x0, 0 :: (load (s16) from %ir.0, align 1)
    do {
    {
    auto cond1 = param_0.encodeable_with_mem_uoff12(this, 0x0, 1);
    if (cond1) {
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(LDRHu, scratch_x9.cur_reg, (*cond1).first, (*cond1).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x9, 0);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(LDRHu, scratch_x9.cur_reg, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x9 is marked as alive


    // renamable $w0 = ORRWrs killed renamable $w9, killed renamable $w8, 16
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 16);
    }
    }
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi40(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi40: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $w8 = LDRBBui renamable $x0, 4, implicit-def $x8 :: (load (s8) from %ir.0 + 4)
    //   renamable $w9 = LDRWui killed renamable $x0, 0, implicit-def $x9 :: (load (s32) from %ir.0, align 1)
    //   renamable $x0 = ORRXrs killed renamable $x9, killed renamable $x8, 32
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function loadi40.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = LDRBBui renamable $x0, 4, implicit-def $x8 :: (load (s8) from %ir.0 + 4)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x4, 0);
    if (cond0) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LDRBu, scratch_x8.cur_reg, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LDRBu, scratch_x8.cur_reg, op1, 0x4);
        break;
    }
    }
    } while (false);
    // result x8 is marked as alive
    // result x8 is marked as alive


    // renamable $w9 = LDRWui killed renamable $x0, 0, implicit-def $x9 :: (load (s32) from %ir.0, align 1)
    do {
    {
    auto cond1 = param_0.encodeable_with_mem_uoff12(this, 0x0, 2);
    if (cond1) {
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(LDRwu, scratch_x9.cur_reg, (*cond1).first, (*cond1).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x9, 0);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(LDRwu, scratch_x9.cur_reg, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x9 is marked as alive
    // result x9 is marked as alive


    // renamable $x0 = ORRXrs killed renamable $x9, killed renamable $x8, 32
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, op1, op2, 32);
    }
    }
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi48(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi48: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $w8 = LDRHHui renamable $x0, 2, implicit-def $x8 :: (load (s16) from %ir.0 + 4, align 1)
    //   renamable $w9 = LDRWui killed renamable $x0, 0, implicit-def $x9 :: (load (s32) from %ir.0, align 1)
    //   renamable $x0 = ORRXrs killed renamable $x9, killed renamable $x8, 32
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function loadi48.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = LDRHHui renamable $x0, 2, implicit-def $x8 :: (load (s16) from %ir.0 + 4, align 1)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x2, 1);
    if (cond0) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LDRHu, scratch_x8.cur_reg, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LDRHu, scratch_x8.cur_reg, op1, 0x2);
        break;
    }
    }
    } while (false);
    // result x8 is marked as alive
    // result x8 is marked as alive


    // renamable $w9 = LDRWui killed renamable $x0, 0, implicit-def $x9 :: (load (s32) from %ir.0, align 1)
    do {
    {
    auto cond1 = param_0.encodeable_with_mem_uoff12(this, 0x0, 2);
    if (cond1) {
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(LDRwu, scratch_x9.cur_reg, (*cond1).first, (*cond1).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x9, 0);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(LDRwu, scratch_x9.cur_reg, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x9 is marked as alive
    // result x9 is marked as alive


    // renamable $x0 = ORRXrs killed renamable $x9, killed renamable $x8, 32
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, op1, op2, 32);
    }
    }
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi56(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi56: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $w8 = LDRBBui renamable $x0, 6 :: (load (s8) from %ir.0 + 6)
    //   renamable $w9 = LDRHHui renamable $x0, 2 :: (load (s16) from %ir.0 + 4, align 1)
    //   renamable $w8 = ORRWrs killed renamable $w9, killed renamable $w8, 16, implicit-def $x8
    //   renamable $w9 = LDRWui killed renamable $x0, 0, implicit-def $x9 :: (load (s32) from %ir.0, align 1)
    //   renamable $x0 = ORRXrs killed renamable $x9, killed renamable $x8, 32
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function loadi56.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = LDRBBui renamable $x0, 6 :: (load (s8) from %ir.0 + 6)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x6, 0);
    if (cond0) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LDRBu, scratch_x8.cur_reg, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LDRBu, scratch_x8.cur_reg, op1, 0x6);
        break;
    }
    }
    } while (false);
    // result x8 is marked as alive


    // renamable $w9 = LDRHHui renamable $x0, 2 :: (load (s16) from %ir.0 + 4, align 1)
    do {
    {
    auto cond1 = param_0.encodeable_with_mem_uoff12(this, 0x2, 1);
    if (cond1) {
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(LDRHu, scratch_x9.cur_reg, (*cond1).first, (*cond1).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(LDRHu, scratch_x9.cur_reg, op1, 0x2);
        break;
    }
    }
    } while (false);
    // result x9 is marked as alive


    // renamable $w8 = ORRWrs killed renamable $w9, killed renamable $w8, 16, implicit-def $x8
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x8.cur_reg, op1, op2, 16);
    }
    }
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive
    // result x8 is marked as alive


    // renamable $w9 = LDRWui killed renamable $x0, 0, implicit-def $x9 :: (load (s32) from %ir.0, align 1)
    do {
    {
    auto cond2 = param_0.encodeable_with_mem_uoff12(this, 0x0, 2);
    if (cond2) {
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(LDRwu, scratch_x9.cur_reg, (*cond2).first, (*cond2).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x9, 0);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(LDRwu, scratch_x9.cur_reg, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x9 is marked as alive
    // result x9 is marked as alive


    // renamable $x0 = ORRXrs killed renamable $x9, killed renamable $x8, 32
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, op1, op2, 32);
    }
    }
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi128(AsmOperand param_0, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function loadi128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $x8, renamable $x1 = LDPXi killed renamable $x0, 0 :: (load (s64) from %ir.0, align 16, !tbaa !17), (load (s64) from %ir.0 + 8, basealign 16, !tbaa !17)
    //   $x0 = ORRXrs $xzr, killed $x8, 0
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function loadi128.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $x8, renamable $x1 = LDPXi killed renamable $x0, 0 :: (load (s64) from %ir.0, align 16, !tbaa !17), (load (s64) from %ir.0 + 8, basealign 16, !tbaa !17)
    {
    if (1) {
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(LDPx, scratch_x8.cur_reg, scratch_x1.cur_reg, op2, 0x0);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive
    // result x1 is marked as alive


    // $x0 = ORRXrs $xzr, killed $x8, 0
    {
    if (1) {
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, DA_ZR, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadf32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $s0 = LDRSui killed renamable $x0, 0 :: (load (s32) from %ir.0, !tbaa !19)
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function loadf32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $s0 = LDRSui killed renamable $x0, 0 :: (load (s32) from %ir.0, !tbaa !19)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 2);
    if (cond0) {
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(LDRsu, scratch_v0.cur_reg, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(LDRsu, scratch_v0.cur_reg, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadf64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $d0 = LDRDui killed renamable $x0, 0 :: (load (s64) from %ir.0, !tbaa !21)
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function loadf64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $d0 = LDRDui killed renamable $x0, 0 :: (load (s64) from %ir.0, !tbaa !21)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 3);
    if (cond0) {
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(LDRdu, scratch_v0.cur_reg, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(LDRdu, scratch_v0.cur_reg, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadv128(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadv128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $q0 = LDRQui killed renamable $x0, 0 :: (load (s128) from %ir.0, !tbaa !4)
    //   RET undef $lr, implicit killed $q0
    // 
    // # End machine code for function loadv128.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $q0 = LDRQui killed renamable $x0, 0 :: (load (s128) from %ir.0, !tbaa !4)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 4);
    if (cond0) {
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(LDRqu, scratch_v0.cur_reg, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(LDRqu, scratch_v0.cur_reg, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $q0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei8(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w1, $x0
    //   STRBBui killed renamable $w1, killed renamable $x0, 0 :: (store (s8) into %ir.0, !tbaa !4)
    //   RET undef $lr
    // 
    // # End machine code for function storei8.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // STRBBui killed renamable $w1, killed renamable $x0, 0 :: (store (s8) into %ir.0, !tbaa !4)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 0);
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(STRBu, op0, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(STRBu, op0, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei16(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w1, $x0
    //   STRHHui killed renamable $w1, killed renamable $x0, 0 :: (store (s16) into %ir.0, !tbaa !7)
    //   RET undef $lr
    // 
    // # End machine code for function storei16.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // STRHHui killed renamable $w1, killed renamable $x0, 0 :: (store (s16) into %ir.0, !tbaa !7)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 1);
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(STRHu, op0, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(STRHu, op0, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei32(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w1, $x0
    //   STRWui killed renamable $w1, killed renamable $x0, 0 :: (store (s32) into %ir.0, !tbaa !9)
    //   RET undef $lr
    // 
    // # End machine code for function storei32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // STRWui killed renamable $w1, killed renamable $x0, 0 :: (store (s32) into %ir.0, !tbaa !9)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 2);
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(STRwu, op0, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(STRwu, op0, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei64(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   STRXui killed renamable $x1, killed renamable $x0, 0 :: (store (s64) into %ir.0, !tbaa !11)
    //   RET undef $lr
    // 
    // # End machine code for function storei64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // STRXui killed renamable $x1, killed renamable $x0, 0 :: (store (s64) into %ir.0, !tbaa !11)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 3);
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(STRxu, op0, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(STRxu, op0, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei24(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei24: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   renamable $x8 = UBFMXri renamable $x1, 16, 31
    //   STRHHui killed renamable $w1, renamable $x0, 0, implicit killed $x1 :: (store (s16) into %ir.0, align 1)
    //   STRBBui killed renamable $w8, killed renamable $x0, 2, implicit killed $x8 :: (store (s8) into %ir.0 + 2)
    //   RET undef $lr
    // 
    // # End machine code for function storei24.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $x8 = UBFMXri renamable $x1, 16, 31
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UBFMx, scratch_x8.cur_reg, op1, 0x10, 0x1f);
    }
    }
    // result x8 is marked as alive


    // STRHHui killed renamable $w1, renamable $x0, 0, implicit killed $x1 :: (store (s16) into %ir.0, align 1)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 1);
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(STRHu, op0, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(STRHu, op0, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x1 is killed and marked as dead


    // STRBBui killed renamable $w8, killed renamable $x0, 2, implicit killed $x8 :: (store (s8) into %ir.0 + 2)
    do {
    {
    auto cond1 = param_0.encodeable_with_mem_uoff12(this, 0x2, 0);
    if (cond1) {
        AsmReg op0 = scratch_x8.cur_reg;
        // operand exceeds NumImplicitUses, ignore
        ASMD(STRBu, op0, (*cond1).first, (*cond1).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = scratch_x8.cur_reg;
        AsmReg op1 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(STRBu, op0, op1, 0x2);
        break;
    }
    }
    } while (false);
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x8 is killed and marked as dead


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei40(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei40: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   renamable $x8 = UBFMXri renamable $x1, 32, 63
    //   STRWui killed renamable $w1, renamable $x0, 0, implicit killed $x1 :: (store (s32) into %ir.0, align 1)
    //   STRBBui killed renamable $w8, killed renamable $x0, 4, implicit killed $x8 :: (store (s8) into %ir.0 + 4)
    //   RET undef $lr
    // 
    // # End machine code for function storei40.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $x8 = UBFMXri renamable $x1, 32, 63
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UBFMx, scratch_x8.cur_reg, op1, 0x20, 0x3f);
    }
    }
    // result x8 is marked as alive


    // STRWui killed renamable $w1, renamable $x0, 0, implicit killed $x1 :: (store (s32) into %ir.0, align 1)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 2);
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(STRwu, op0, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(STRwu, op0, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x1 is killed and marked as dead


    // STRBBui killed renamable $w8, killed renamable $x0, 4, implicit killed $x8 :: (store (s8) into %ir.0 + 4)
    do {
    {
    auto cond1 = param_0.encodeable_with_mem_uoff12(this, 0x4, 0);
    if (cond1) {
        AsmReg op0 = scratch_x8.cur_reg;
        // operand exceeds NumImplicitUses, ignore
        ASMD(STRBu, op0, (*cond1).first, (*cond1).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = scratch_x8.cur_reg;
        AsmReg op1 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(STRBu, op0, op1, 0x4);
        break;
    }
    }
    } while (false);
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x8 is killed and marked as dead


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei48(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei48: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   renamable $x8 = UBFMXri renamable $x1, 32, 63
    //   STRWui killed renamable $w1, renamable $x0, 0, implicit killed $x1 :: (store (s32) into %ir.0, align 1)
    //   STRHHui killed renamable $w8, killed renamable $x0, 2, implicit killed $x8 :: (store (s16) into %ir.0 + 4, align 1)
    //   RET undef $lr
    // 
    // # End machine code for function storei48.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $x8 = UBFMXri renamable $x1, 32, 63
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UBFMx, scratch_x8.cur_reg, op1, 0x20, 0x3f);
    }
    }
    // result x8 is marked as alive


    // STRWui killed renamable $w1, renamable $x0, 0, implicit killed $x1 :: (store (s32) into %ir.0, align 1)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 2);
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(STRwu, op0, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(STRwu, op0, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x1 is killed and marked as dead


    // STRHHui killed renamable $w8, killed renamable $x0, 2, implicit killed $x8 :: (store (s16) into %ir.0 + 4, align 1)
    do {
    {
    auto cond1 = param_0.encodeable_with_mem_uoff12(this, 0x2, 1);
    if (cond1) {
        AsmReg op0 = scratch_x8.cur_reg;
        // operand exceeds NumImplicitUses, ignore
        ASMD(STRHu, op0, (*cond1).first, (*cond1).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = scratch_x8.cur_reg;
        AsmReg op1 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(STRHu, op0, op1, 0x2);
        break;
    }
    }
    } while (false);
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x8 is killed and marked as dead


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei56(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei56: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   renamable $x8 = UBFMXri renamable $x1, 48, 63
    //   renamable $x9 = UBFMXri renamable $x1, 32, 63
    //   STRWui killed renamable $w1, renamable $x0, 0 :: (store (s32) into %ir.0, align 1)
    //   STRBBui killed renamable $w8, renamable $x0, 6, implicit killed $x8 :: (store (s8) into %ir.0 + 6)
    //   STRHHui killed renamable $w9, killed renamable $x0, 2, implicit killed $x9 :: (store (s16) into %ir.0 + 4, align 1)
    //   RET undef $lr
    // 
    // # End machine code for function storei56.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $x8 = UBFMXri renamable $x1, 48, 63
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UBFMx, scratch_x8.cur_reg, op1, 0x30, 0x3f);
    }
    }
    // result x8 is marked as alive


    // renamable $x9 = UBFMXri renamable $x1, 32, 63
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(UBFMx, scratch_x9.cur_reg, op1, 0x20, 0x3f);
    }
    }
    // result x9 is marked as alive


    // STRWui killed renamable $w1, renamable $x0, 0 :: (store (s32) into %ir.0, align 1)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 2);
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(STRwu, op0, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(STRwu, op0, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();


    // STRBBui killed renamable $w8, renamable $x0, 6, implicit killed $x8 :: (store (s8) into %ir.0 + 6)
    do {
    {
    auto cond1 = param_0.encodeable_with_mem_uoff12(this, 0x6, 0);
    if (cond1) {
        AsmReg op0 = scratch_x8.cur_reg;
        // operand exceeds NumImplicitUses, ignore
        ASMD(STRBu, op0, (*cond1).first, (*cond1).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = scratch_x8.cur_reg;
        AsmReg op1 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(STRBu, op0, op1, 0x6);
        break;
    }
    }
    } while (false);
    // argument x8 is killed and marked as dead
    // argument x8 is killed and marked as dead


    // STRHHui killed renamable $w9, killed renamable $x0, 2, implicit killed $x9 :: (store (s16) into %ir.0 + 4, align 1)
    do {
    {
    auto cond2 = param_0.encodeable_with_mem_uoff12(this, 0x2, 1);
    if (cond2) {
        AsmReg op0 = scratch_x9.cur_reg;
        // operand exceeds NumImplicitUses, ignore
        ASMD(STRHu, op0, (*cond2).first, (*cond2).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = scratch_x9.cur_reg;
        AsmReg op1 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(STRHu, op0, op1, 0x2);
        break;
    }
    }
    } while (false);
    // argument x9 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x9 is killed and marked as dead


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2) {
    // # Machine code for function storei128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x2, $x3
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x2, $x3
    //   STPXi killed renamable $x2, killed renamable $x3, killed renamable $x0, 0 :: (store (s64) into %ir.0 + 8, basealign 16, !tbaa !17), (store (s64) into %ir.0, align 16, !tbaa !17)
    //   RET undef $lr
    // 
    // # End machine code for function storei128.
    // 

    // Mapping x0 to param_0
    // Mapping x2 to param_1
    // Mapping x3 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x3{derived()};


    // STPXi killed renamable $x2, killed renamable $x3, killed renamable $x0, 0 :: (store (s64) into %ir.0 + 8, basealign 16, !tbaa !17), (store (s64) into %ir.0, align 16, !tbaa !17)
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_2.as_reg(this);
        AsmReg op2 = param_0.as_reg(this);
        ASMD(STPx, op0, op1, op2, 0x0);
    }
    }
    // argument x2 is killed and marked as dead
    param_1.reset();
    // argument x3 is killed and marked as dead
    param_2.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storef32(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storef32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $s0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $x0
    //   STRSui killed renamable $s0, killed renamable $x0, 0 :: (store (s32) into %ir.0, !tbaa !19)
    //   RET undef $lr
    // 
    // # End machine code for function storef32.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // STRSui killed renamable $s0, killed renamable $x0, 0 :: (store (s32) into %ir.0, !tbaa !19)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 2);
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(STRsu, op0, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(STRsu, op0, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument v0 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storef64(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storef64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $d0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $x0
    //   STRDui killed renamable $d0, killed renamable $x0, 0 :: (store (s64) into %ir.0, !tbaa !21)
    //   RET undef $lr
    // 
    // # End machine code for function storef64.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // STRDui killed renamable $d0, killed renamable $x0, 0 :: (store (s64) into %ir.0, !tbaa !21)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 3);
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(STRdu, op0, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(STRdu, op0, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument v0 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storev128(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storev128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $q0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $q0, $x0
    //   STRQui killed renamable $q0, killed renamable $x0, 0 :: (store (s128) into %ir.0, !tbaa !4)
    //   RET undef $lr
    // 
    // # End machine code for function storev128.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // STRQui killed renamable $q0, killed renamable $x0, 0 :: (store (s128) into %ir.0, !tbaa !4)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 4);
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(STRqu, op0, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(STRqu, op0, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument v0 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_addi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function addi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   $w0 = ADDWrs killed renamable $w1, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function addi32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $w0 = ADDWrs killed renamable $w1, killed renamable $w0, 0
    do {
    {
    auto cond0 = param_0.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDwi, scratch_x0.cur_reg, op1, (*cond0));        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_immarith();
    if (cond1) {
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDwi, scratch_x0.cur_reg, op2, (*cond1));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDw_lsl, scratch_x0.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_subi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function subi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   $w0 = SUBWrs killed renamable $w0, killed renamable $w1, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function subi32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $w0 = SUBWrs killed renamable $w0, killed renamable $w1, 0
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SUBwi, scratch_x0.cur_reg, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SUBw_lsl, scratch_x0.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_muli32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function muli32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w0 = MADDWrrr killed renamable $w1, killed renamable $w0, $wzr
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function muli32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // renamable $w0 = MADDWrrr killed renamable $w1, killed renamable $w0, $wzr
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(MADDw, scratch_x0.cur_reg, op1, op2, DA_ZR);
    }
    }
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_udivi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function udivi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w0 = UDIVWr killed renamable $w0, killed renamable $w1
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function udivi32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // renamable $w0 = UDIVWr killed renamable $w0, killed renamable $w1
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(UDIVw, scratch_x0.cur_reg, op1, op2);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sdivi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sdivi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w0 = SDIVWr killed renamable $w0, killed renamable $w1
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function sdivi32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // renamable $w0 = SDIVWr killed renamable $w0, killed renamable $w1
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SDIVw, scratch_x0.cur_reg, op1, op2);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_uremi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function uremi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w8 = UDIVWr renamable $w0, renamable $w1
    //   renamable $w0 = MSUBWrrr killed renamable $w8, killed renamable $w1, killed renamable $w0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function uremi32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = UDIVWr renamable $w0, renamable $w1
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UDIVw, scratch_x8.cur_reg, op1, op2);
    }
    }
    // result x8 is marked as alive


    // renamable $w0 = MSUBWrrr killed renamable $w8, killed renamable $w1, killed renamable $w0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op3 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(MSUBw, scratch_x0.cur_reg, op1, op2, op3);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sremi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sremi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w8 = SDIVWr renamable $w0, renamable $w1
    //   renamable $w0 = MSUBWrrr killed renamable $w8, killed renamable $w1, killed renamable $w0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function sremi32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = SDIVWr renamable $w0, renamable $w1
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SDIVw, scratch_x8.cur_reg, op1, op2);
    }
    }
    // result x8 is marked as alive


    // renamable $w0 = MSUBWrrr killed renamable $w8, killed renamable $w1, killed renamable $w0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op3 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(MSUBw, scratch_x0.cur_reg, op1, op2, op3);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_landi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function landi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   $w0 = ANDWrs killed renamable $w1, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function landi32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $w0 = ANDWrs killed renamable $w1, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_lori32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function lori32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   $w0 = ORRWrs killed renamable $w1, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function lori32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $w0 = ORRWrs killed renamable $w1, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_lxori32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function lxori32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   $w0 = EORWrs killed renamable $w1, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function lxori32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $w0 = EORWrs killed renamable $w1, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(EORw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shli32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function shli32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w0 = LSLVWr killed renamable $w0, killed renamable $w1
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function shli32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // renamable $w0 = LSLVWr killed renamable $w0, killed renamable $w1
    do {
    {
    auto cond0 = param_1.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LSLwi, scratch_x0.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LSLVw, scratch_x0.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shri32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function shri32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w0 = LSRVWr killed renamable $w0, killed renamable $w1
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function shri32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // renamable $w0 = LSRVWr killed renamable $w0, killed renamable $w1
    do {
    {
    auto cond0 = param_1.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LSRwi, scratch_x0.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LSRVw, scratch_x0.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ashri32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function ashri32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w0 = ASRVWr killed renamable $w0, killed renamable $w1
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function ashri32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // renamable $w0 = ASRVWr killed renamable $w0, killed renamable $w1
    do {
    {
    auto cond0 = param_1.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ASRwi, scratch_x0.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ASRVw, scratch_x0.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_absi32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function absi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   $wzr = SUBSWri renamable $w0, 0, 0, implicit-def $nzcv
    //   renamable $w0 = CSNEGWr killed renamable $w0, killed renamable $w0, 5, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function absi32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // $wzr = SUBSWri renamable $w0, 0, 0, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(SUBSwi, DA_ZR, op1, 0);
    }
    }


    // renamable $w0 = CSNEGWr killed renamable $w0, killed renamable $w0, 5, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSNEGw, scratch_x0.cur_reg, op1, op1, DA_PL);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x0 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_addi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function addi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   $x0 = ADDXrs killed renamable $x1, killed renamable $x0, 0
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function addi64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $x0 = ADDXrs killed renamable $x1, killed renamable $x0, 0
    do {
    {
    auto cond0 = param_0.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDxi, scratch_x0.cur_reg, op1, (*cond0));        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_immarith();
    if (cond1) {
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDxi, scratch_x0.cur_reg, op2, (*cond1));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDx_lsl, scratch_x0.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_subi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function subi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   $x0 = SUBXrs killed renamable $x0, killed renamable $x1, 0
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function subi64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $x0 = SUBXrs killed renamable $x0, killed renamable $x1, 0
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SUBxi, scratch_x0.cur_reg, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SUBx_lsl, scratch_x0.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_muli64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function muli64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   renamable $x0 = MADDXrrr killed renamable $x1, killed renamable $x0, $xzr
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function muli64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // renamable $x0 = MADDXrrr killed renamable $x1, killed renamable $x0, $xzr
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(MADDx, scratch_x0.cur_reg, op1, op2, DA_ZR);
    }
    }
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_udivi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function udivi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   renamable $x0 = UDIVXr killed renamable $x0, killed renamable $x1
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function udivi64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // renamable $x0 = UDIVXr killed renamable $x0, killed renamable $x1
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(UDIVx, scratch_x0.cur_reg, op1, op2);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sdivi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sdivi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   renamable $x0 = SDIVXr killed renamable $x0, killed renamable $x1
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function sdivi64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // renamable $x0 = SDIVXr killed renamable $x0, killed renamable $x1
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SDIVx, scratch_x0.cur_reg, op1, op2);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_uremi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function uremi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   renamable $x8 = UDIVXr renamable $x0, renamable $x1
    //   renamable $x0 = MSUBXrrr killed renamable $x8, killed renamable $x1, killed renamable $x0
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function uremi64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $x8 = UDIVXr renamable $x0, renamable $x1
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UDIVx, scratch_x8.cur_reg, op1, op2);
    }
    }
    // result x8 is marked as alive


    // renamable $x0 = MSUBXrrr killed renamable $x8, killed renamable $x1, killed renamable $x0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op3 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(MSUBx, scratch_x0.cur_reg, op1, op2, op3);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sremi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sremi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   renamable $x8 = SDIVXr renamable $x0, renamable $x1
    //   renamable $x0 = MSUBXrrr killed renamable $x8, killed renamable $x1, killed renamable $x0
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function sremi64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $x8 = SDIVXr renamable $x0, renamable $x1
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SDIVx, scratch_x8.cur_reg, op1, op2);
    }
    }
    // result x8 is marked as alive


    // renamable $x0 = MSUBXrrr killed renamable $x8, killed renamable $x1, killed renamable $x0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op3 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(MSUBx, scratch_x0.cur_reg, op1, op2, op3);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_landi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function landi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   $x0 = ANDXrs killed renamable $x1, killed renamable $x0, 0
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function landi64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $x0 = ANDXrs killed renamable $x1, killed renamable $x0, 0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDx_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_lori64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function lori64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   $x0 = ORRXrs killed renamable $x1, killed renamable $x0, 0
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function lori64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $x0 = ORRXrs killed renamable $x1, killed renamable $x0, 0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_lxori64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function lxori64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   $x0 = EORXrs killed renamable $x1, killed renamable $x0, 0
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function lxori64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $x0 = EORXrs killed renamable $x1, killed renamable $x0, 0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(EORx_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shli64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function shli64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   renamable $x0 = LSLVXr killed renamable $x0, killed renamable $x1
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function shli64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // renamable $x0 = LSLVXr killed renamable $x0, killed renamable $x1
    do {
    {
    auto cond0 = param_1.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LSLxi, scratch_x0.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LSLVx, scratch_x0.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shri64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function shri64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   renamable $x0 = LSRVXr killed renamable $x0, killed renamable $x1
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function shri64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // renamable $x0 = LSRVXr killed renamable $x0, killed renamable $x1
    do {
    {
    auto cond0 = param_1.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LSRxi, scratch_x0.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LSRVx, scratch_x0.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ashri64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function ashri64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   renamable $x0 = ASRVXr killed renamable $x0, killed renamable $x1
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function ashri64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // renamable $x0 = ASRVXr killed renamable $x0, killed renamable $x1
    do {
    {
    auto cond0 = param_1.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ASRxi, scratch_x0.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ASRVx, scratch_x0.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_absi64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function absi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   $xzr = SUBSXri renamable $x0, 0, 0, implicit-def $nzcv
    //   renamable $x0 = CSNEGXr killed renamable $x0, killed renamable $x0, 5, implicit killed $nzcv
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function absi64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // $xzr = SUBSXri renamable $x0, 0, 0, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(SUBSxi, DA_ZR, op1, 0);
    }
    }


    // renamable $x0 = CSNEGXr killed renamable $x0, killed renamable $x0, 5, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSNEGx, scratch_x0.cur_reg, op1, op1, DA_PL);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x0 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_addi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function addi128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2, $x3
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1, $x2, $x3
    //   $x0 = ADDSXrs killed renamable $x2, killed renamable $x0, 0, implicit-def $nzcv
    //   renamable $x1 = ADCXr killed renamable $x3, killed renamable $x1, implicit killed $nzcv
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function addi128.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    // Mapping x3 to param_3
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x3{derived()};


    // $x0 = ADDSXrs killed renamable $x2, killed renamable $x0, 0, implicit-def $nzcv
    do {
    {
    auto cond0 = param_0.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = param_2.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDSxi, scratch_x0.cur_reg, op1, (*cond0));        break;
    }
    }
    {
    auto cond1 = param_2.encodeable_as_immarith();
    if (cond1) {
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDSxi, scratch_x0.cur_reg, op2, (*cond1));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_2.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDSx_lsl, scratch_x0.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // renamable $x1 = ADCXr killed renamable $x3, killed renamable $x1, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = param_3.as_reg_try_salvage(this, scratch_x1, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x1, 0);
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(ADCx, scratch_x1.cur_reg, op1, op2);
    }
    }
    // argument x3 is killed and marked as dead
    param_3.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_subi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function subi128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2, $x3
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1, $x2, $x3
    //   $x0 = SUBSXrs killed renamable $x0, killed renamable $x2, 0, implicit-def $nzcv
    //   renamable $x1 = SBCXr killed renamable $x1, killed renamable $x3, implicit killed $nzcv
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function subi128.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    // Mapping x3 to param_3
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x3{derived()};


    // $x0 = SUBSXrs killed renamable $x0, killed renamable $x2, 0, implicit-def $nzcv
    do {
    {
    auto cond0 = param_2.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SUBSxi, scratch_x0.cur_reg, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_2.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SUBSx_lsl, scratch_x0.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x2 is killed and marked as dead
    param_2.reset();
    // result x0 is marked as alive


    // renamable $x1 = SBCXr killed renamable $x1, killed renamable $x3, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x1, 0);
        AsmReg op2 = param_3.as_reg_try_salvage(this, scratch_x1, 0);
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(SBCx, scratch_x1.cur_reg, op1, op2);
    }
    }
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x3 is killed and marked as dead
    param_3.reset();
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_muli128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function muli128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2, $x3
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1, $x2, $x3
    //   renamable $x8 = UMULHrr renamable $x2, renamable $x0
    //   renamable $x8 = MADDXrrr renamable $x2, killed renamable $x1, killed renamable $x8
    //   renamable $x1 = MADDXrrr killed renamable $x3, renamable $x0, killed renamable $x8
    //   renamable $x0 = MADDXrrr killed renamable $x2, killed renamable $x0, $xzr
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function muli128.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    // Mapping x3 to param_3
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};
    ScratchReg scratch_x3{derived()};


    // renamable $x8 = UMULHrr renamable $x2, renamable $x0
    {
    if (1) {
        AsmReg op1 = param_2.as_reg(this);
        AsmReg op2 = param_0.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UMULH, scratch_x8.cur_reg, op1, op2);
    }
    }
    // result x8 is marked as alive


    // renamable $x8 = MADDXrrr renamable $x2, killed renamable $x1, killed renamable $x8
    {
    if (1) {
        AsmReg op1 = param_2.as_reg(this);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x8, 0);
        AsmReg op3 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MADDx, scratch_x8.cur_reg, op1, op2, op3);
    }
    }
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // renamable $x1 = MADDXrrr killed renamable $x3, renamable $x0, killed renamable $x8
    {
    if (1) {
        AsmReg op1 = param_3.as_reg_try_salvage(this, scratch_x1, 0);
        AsmReg op2 = param_0.as_reg(this);
        AsmReg op3 = scratch_x8.cur_reg;
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(MADDx, scratch_x1.cur_reg, op1, op2, op3);
    }
    }
    // argument x3 is killed and marked as dead
    param_3.reset();
    // argument x8 is killed and marked as dead
    // result x1 is marked as alive


    // renamable $x0 = MADDXrrr killed renamable $x2, killed renamable $x0, $xzr
    {
    if (1) {
        AsmReg op1 = param_2.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(MADDx, scratch_x0.cur_reg, op1, op2, DA_ZR);
    }
    }
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_landi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function landi128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2, $x3
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1, $x2, $x3
    //   $x1 = ANDXrs killed renamable $x3, killed renamable $x1, 0
    //   $x0 = ANDXrs killed renamable $x2, killed renamable $x0, 0
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function landi128.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    // Mapping x3 to param_3
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x3{derived()};


    // $x1 = ANDXrs killed renamable $x3, killed renamable $x1, 0
    {
    if (1) {
        AsmReg op1 = param_3.as_reg_try_salvage(this, scratch_x1, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x1, 0);
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(ANDx_lsl, scratch_x1.cur_reg, op1, op2, 0);
    }
    }
    // argument x3 is killed and marked as dead
    param_3.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x1 is marked as alive


    // $x0 = ANDXrs killed renamable $x2, killed renamable $x0, 0
    {
    if (1) {
        AsmReg op1 = param_2.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDx_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_lori128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function lori128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2, $x3
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1, $x2, $x3
    //   $x1 = ORRXrs killed renamable $x3, killed renamable $x1, 0
    //   $x0 = ORRXrs killed renamable $x2, killed renamable $x0, 0
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function lori128.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    // Mapping x3 to param_3
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x3{derived()};


    // $x1 = ORRXrs killed renamable $x3, killed renamable $x1, 0
    {
    if (1) {
        AsmReg op1 = param_3.as_reg_try_salvage(this, scratch_x1, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x1, 0);
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x1.cur_reg, op1, op2, 0);
    }
    }
    // argument x3 is killed and marked as dead
    param_3.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x1 is marked as alive


    // $x0 = ORRXrs killed renamable $x2, killed renamable $x0, 0
    {
    if (1) {
        AsmReg op1 = param_2.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_lxori128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function lxori128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2, $x3
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1, $x2, $x3
    //   $x1 = EORXrs killed renamable $x3, killed renamable $x1, 0
    //   $x0 = EORXrs killed renamable $x2, killed renamable $x0, 0
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function lxori128.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    // Mapping x3 to param_3
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x3{derived()};


    // $x1 = EORXrs killed renamable $x3, killed renamable $x1, 0
    {
    if (1) {
        AsmReg op1 = param_3.as_reg_try_salvage(this, scratch_x1, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x1, 0);
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(EORx_lsl, scratch_x1.cur_reg, op1, op2, 0);
    }
    }
    // argument x3 is killed and marked as dead
    param_3.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x1 is marked as alive


    // $x0 = EORXrs killed renamable $x2, killed renamable $x0, 0
    {
    if (1) {
        AsmReg op1 = param_2.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(EORx_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shli128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function shli128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1, $x2
    //   renamable $x8 = UBFMXri renamable $x0, 1, 63
    //   $w9 = ORNWrs $wzr, renamable $w2, 0, implicit-def $x9
    //   renamable $x10 = LSLVXr killed renamable $x1, renamable $x2
    //   $xzr = ANDSXri renamable $x2, 7808, implicit-def $nzcv
    //   renamable $x8 = LSRVXr killed renamable $x8, killed renamable $x9
    //   renamable $x9 = LSLVXr killed renamable $x0, killed renamable $x2
    //   $x8 = ORRXrs killed renamable $x10, killed renamable $x8, 0
    //   renamable $x0 = CSELXr $xzr, renamable $x9, 1, implicit $nzcv
    //   renamable $x1 = CSELXr killed renamable $x9, killed renamable $x8, 1, implicit killed $nzcv
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function shli128.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};
    ScratchReg scratch_x10{derived()};


    // renamable $x8 = UBFMXri renamable $x0, 1, 63
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UBFMx, scratch_x8.cur_reg, op1, 0x1, 0x3f);
    }
    }
    // result x8 is marked as alive


    // $w9 = ORNWrs $wzr, renamable $w2, 0, implicit-def $x9
    {
    if (1) {
        AsmReg op2 = param_2.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ORNw_lsl, scratch_x9.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x9 is marked as alive
    // result x9 is marked as alive


    // renamable $x10 = LSLVXr killed renamable $x1, renamable $x2
    do {
    {
    auto cond0 = param_2.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x10, 0);
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(LSLxi, scratch_x10.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x10, 0);
        AsmReg op2 = param_2.as_reg(this);
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(LSLVx, scratch_x10.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x10 is marked as alive


    // $xzr = ANDSXri renamable $x2, 7808, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = param_2.as_reg(this);
        ASMD(ANDSxi, DA_ZR, op1, 0x40);
    }
    }


    // renamable $x8 = LSRVXr killed renamable $x8, killed renamable $x9
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = scratch_x9.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LSRVx, scratch_x8.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x8 is killed and marked as dead
    // argument x9 is killed and marked as dead
    // result x8 is marked as alive


    // renamable $x9 = LSLVXr killed renamable $x0, killed renamable $x2
    do {
    {
    auto cond1 = param_2.encodeable_as_imm();
    if (cond1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x9, 0);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(LSLxi, scratch_x9.cur_reg, op1, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x9, 0);
        AsmReg op2 = param_2.as_reg_try_salvage(this, scratch_x9, 0);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(LSLVx, scratch_x9.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x2 is killed and marked as dead
    param_2.reset();
    // result x9 is marked as alive


    // $x8 = ORRXrs killed renamable $x10, killed renamable $x8, 0
    {
    if (1) {
        AsmReg op1 = scratch_x10.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x8.cur_reg, op1, op2, 0);
    }
    }
    // argument x10 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // renamable $x0 = CSELXr $xzr, renamable $x9, 1, implicit $nzcv
    {
    if (1) {
        AsmReg op2 = scratch_x9.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSELx, scratch_x0.cur_reg, DA_ZR, op2, DA_NE);
    }
    }
    // result x0 is marked as alive


    // renamable $x1 = CSELXr killed renamable $x9, killed renamable $x8, 1, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSELx, scratch_x1.cur_reg, op1, op2, DA_NE);
    }
    }
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shri128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function shri128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1, $x2
    //   renamable $x8 = UBFMXri renamable $x1, 63, 62
    //   $w9 = ORNWrs $wzr, renamable $w2, 0, implicit-def $x9
    //   renamable $x10 = LSRVXr killed renamable $x0, renamable $x2
    //   $xzr = ANDSXri renamable $x2, 7808, implicit-def $nzcv
    //   renamable $x8 = LSLVXr killed renamable $x8, killed renamable $x9
    //   renamable $x9 = LSRVXr killed renamable $x1, killed renamable $x2
    //   $x8 = ORRXrs killed renamable $x8, killed renamable $x10, 0
    //   renamable $x1 = CSELXr $xzr, renamable $x9, 1, implicit $nzcv
    //   renamable $x0 = CSELXr killed renamable $x9, killed renamable $x8, 1, implicit killed $nzcv
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function shri128.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};
    ScratchReg scratch_x10{derived()};


    // renamable $x8 = UBFMXri renamable $x1, 63, 62
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UBFMx, scratch_x8.cur_reg, op1, 0x3f, 0x3e);
    }
    }
    // result x8 is marked as alive


    // $w9 = ORNWrs $wzr, renamable $w2, 0, implicit-def $x9
    {
    if (1) {
        AsmReg op2 = param_2.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ORNw_lsl, scratch_x9.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x9 is marked as alive
    // result x9 is marked as alive


    // renamable $x10 = LSRVXr killed renamable $x0, renamable $x2
    do {
    {
    auto cond0 = param_2.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x10, 0);
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(LSRxi, scratch_x10.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x10, 0);
        AsmReg op2 = param_2.as_reg(this);
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(LSRVx, scratch_x10.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x10 is marked as alive


    // $xzr = ANDSXri renamable $x2, 7808, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = param_2.as_reg(this);
        ASMD(ANDSxi, DA_ZR, op1, 0x40);
    }
    }


    // renamable $x8 = LSLVXr killed renamable $x8, killed renamable $x9
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = scratch_x9.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LSLVx, scratch_x8.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x8 is killed and marked as dead
    // argument x9 is killed and marked as dead
    // result x8 is marked as alive


    // renamable $x9 = LSRVXr killed renamable $x1, killed renamable $x2
    do {
    {
    auto cond1 = param_2.encodeable_as_imm();
    if (cond1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x9, 0);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(LSRxi, scratch_x9.cur_reg, op1, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x9, 0);
        AsmReg op2 = param_2.as_reg_try_salvage(this, scratch_x9, 0);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(LSRVx, scratch_x9.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x2 is killed and marked as dead
    param_2.reset();
    // result x9 is marked as alive


    // $x8 = ORRXrs killed renamable $x8, killed renamable $x10, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = scratch_x10.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x8.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x10 is killed and marked as dead
    // result x8 is marked as alive


    // renamable $x1 = CSELXr $xzr, renamable $x9, 1, implicit $nzcv
    {
    if (1) {
        AsmReg op2 = scratch_x9.cur_reg;
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSELx, scratch_x1.cur_reg, DA_ZR, op2, DA_NE);
    }
    }
    // result x1 is marked as alive


    // renamable $x0 = CSELXr killed renamable $x9, killed renamable $x8, 1, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSELx, scratch_x0.cur_reg, op1, op2, DA_NE);
    }
    }
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ashri128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function ashri128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1, $x2
    //   renamable $x8 = UBFMXri renamable $x1, 63, 62
    //   $w9 = ORNWrs $wzr, renamable $w2, 0, implicit-def $x9
    //   renamable $x10 = LSRVXr killed renamable $x0, renamable $x2
    //   renamable $x11 = SBFMXri renamable $x1, 63, 63
    //   $xzr = ANDSXri renamable $x2, 7808, implicit-def $nzcv
    //   renamable $x8 = LSLVXr killed renamable $x8, killed renamable $x9
    //   renamable $x9 = ASRVXr killed renamable $x1, killed renamable $x2
    //   $x8 = ORRXrs killed renamable $x8, killed renamable $x10, 0
    //   renamable $x1 = CSELXr killed renamable $x11, renamable $x9, 1, implicit $nzcv
    //   renamable $x0 = CSELXr killed renamable $x9, killed renamable $x8, 1, implicit killed $nzcv
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function ashri128.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x11{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};
    ScratchReg scratch_x10{derived()};


    // renamable $x8 = UBFMXri renamable $x1, 63, 62
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UBFMx, scratch_x8.cur_reg, op1, 0x3f, 0x3e);
    }
    }
    // result x8 is marked as alive


    // $w9 = ORNWrs $wzr, renamable $w2, 0, implicit-def $x9
    {
    if (1) {
        AsmReg op2 = param_2.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ORNw_lsl, scratch_x9.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x9 is marked as alive
    // result x9 is marked as alive


    // renamable $x10 = LSRVXr killed renamable $x0, renamable $x2
    do {
    {
    auto cond0 = param_2.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x10, 0);
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(LSRxi, scratch_x10.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x10, 0);
        AsmReg op2 = param_2.as_reg(this);
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(LSRVx, scratch_x10.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x10 is marked as alive


    // renamable $x11 = SBFMXri renamable $x1, 63, 63
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x11 has not been allocated yet
        scratch_x11.alloc_from_bank(0);
        ASMD(SBFMx, scratch_x11.cur_reg, op1, 0x3f, 0x3f);
    }
    }
    // result x11 is marked as alive


    // $xzr = ANDSXri renamable $x2, 7808, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = param_2.as_reg(this);
        ASMD(ANDSxi, DA_ZR, op1, 0x40);
    }
    }


    // renamable $x8 = LSLVXr killed renamable $x8, killed renamable $x9
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = scratch_x9.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LSLVx, scratch_x8.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x8 is killed and marked as dead
    // argument x9 is killed and marked as dead
    // result x8 is marked as alive


    // renamable $x9 = ASRVXr killed renamable $x1, killed renamable $x2
    do {
    {
    auto cond1 = param_2.encodeable_as_imm();
    if (cond1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x9, 0);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ASRxi, scratch_x9.cur_reg, op1, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x9, 0);
        AsmReg op2 = param_2.as_reg_try_salvage(this, scratch_x9, 0);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ASRVx, scratch_x9.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x2 is killed and marked as dead
    param_2.reset();
    // result x9 is marked as alive


    // $x8 = ORRXrs killed renamable $x8, killed renamable $x10, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = scratch_x10.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x8.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x10 is killed and marked as dead
    // result x8 is marked as alive


    // renamable $x1 = CSELXr killed renamable $x11, renamable $x9, 1, implicit $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x11.cur_reg;
        AsmReg op2 = scratch_x9.cur_reg;
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSELx, scratch_x1.cur_reg, op1, op2, DA_NE);
    }
    }
    // argument x11 is killed and marked as dead
    // result x1 is marked as alive


    // renamable $x0 = CSELXr killed renamable $x9, killed renamable $x8, 1, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSELx, scratch_x0.cur_reg, op1, op2, DA_NE);
    }
    }
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shli128_lt64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function shli128_lt64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1, $x2
    //   renamable $x8 = UBFMXri renamable $x0, 1, 63
    //   $w9 = ORNWrs $wzr, renamable $w2, 0, implicit-def $x9
    //   renamable $x10 = LSLVXr killed renamable $x1, renamable $x2
    //   renamable $x0 = LSLVXr killed renamable $x0, killed renamable $x2
    //   renamable $x8 = LSRVXr killed renamable $x8, killed renamable $x9
    //   $x1 = ORRXrs killed renamable $x10, killed renamable $x8, 0
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function shli128_lt64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};
    ScratchReg scratch_x10{derived()};


    // renamable $x8 = UBFMXri renamable $x0, 1, 63
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UBFMx, scratch_x8.cur_reg, op1, 0x1, 0x3f);
    }
    }
    // result x8 is marked as alive


    // $w9 = ORNWrs $wzr, renamable $w2, 0, implicit-def $x9
    {
    if (1) {
        AsmReg op2 = param_2.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ORNw_lsl, scratch_x9.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x9 is marked as alive
    // result x9 is marked as alive


    // renamable $x10 = LSLVXr killed renamable $x1, renamable $x2
    do {
    {
    auto cond0 = param_2.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x10, 0);
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(LSLxi, scratch_x10.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x10, 0);
        AsmReg op2 = param_2.as_reg(this);
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(LSLVx, scratch_x10.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x10 is marked as alive


    // renamable $x0 = LSLVXr killed renamable $x0, killed renamable $x2
    do {
    {
    auto cond1 = param_2.encodeable_as_imm();
    if (cond1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LSLxi, scratch_x0.cur_reg, op1, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_2.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LSLVx, scratch_x0.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x2 is killed and marked as dead
    param_2.reset();
    // result x0 is marked as alive


    // renamable $x8 = LSRVXr killed renamable $x8, killed renamable $x9
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = scratch_x9.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LSRVx, scratch_x8.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x8 is killed and marked as dead
    // argument x9 is killed and marked as dead
    // result x8 is marked as alive


    // $x1 = ORRXrs killed renamable $x10, killed renamable $x8, 0
    {
    if (1) {
        AsmReg op1 = scratch_x10.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x1.cur_reg, op1, op2, 0);
    }
    }
    // argument x10 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shli128_ge64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function shli128_ge64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x2
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x2
    //   renamable $x0 = LSLVXr killed renamable $x0, killed renamable $x2
    //   $x1 = ORRXrs $xzr, $xzr, 0
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function shli128_ge64.
    // 

    // Mapping x0 to param_0
    // Mapping x2 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};


    // renamable $x0 = LSLVXr killed renamable $x0, killed renamable $x2
    do {
    {
    auto cond0 = param_1.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LSLxi, scratch_x0.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LSLVx, scratch_x0.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x2 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // $x1 = ORRXrs $xzr, $xzr, 0
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x1.cur_reg, DA_ZR, DA_ZR, 0);
    }
    }
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shri128_lt64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function shri128_lt64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1, $x2
    //   renamable $x8 = UBFMXri renamable $x1, 63, 62
    //   $w9 = ORNWrs $wzr, renamable $w2, 0, implicit-def $x9
    //   renamable $x10 = LSRVXr killed renamable $x0, renamable $x2
    //   renamable $x1 = LSRVXr killed renamable $x1, killed renamable $x2
    //   renamable $x8 = LSLVXr killed renamable $x8, killed renamable $x9
    //   $x0 = ORRXrs killed renamable $x8, killed renamable $x10, 0
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function shri128_lt64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};
    ScratchReg scratch_x10{derived()};


    // renamable $x8 = UBFMXri renamable $x1, 63, 62
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UBFMx, scratch_x8.cur_reg, op1, 0x3f, 0x3e);
    }
    }
    // result x8 is marked as alive


    // $w9 = ORNWrs $wzr, renamable $w2, 0, implicit-def $x9
    {
    if (1) {
        AsmReg op2 = param_2.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ORNw_lsl, scratch_x9.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x9 is marked as alive
    // result x9 is marked as alive


    // renamable $x10 = LSRVXr killed renamable $x0, renamable $x2
    do {
    {
    auto cond0 = param_2.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x10, 0);
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(LSRxi, scratch_x10.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x10, 0);
        AsmReg op2 = param_2.as_reg(this);
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(LSRVx, scratch_x10.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x10 is marked as alive


    // renamable $x1 = LSRVXr killed renamable $x1, killed renamable $x2
    do {
    {
    auto cond1 = param_2.encodeable_as_imm();
    if (cond1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x1, 0);
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(LSRxi, scratch_x1.cur_reg, op1, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x1, 0);
        AsmReg op2 = param_2.as_reg_try_salvage(this, scratch_x1, 0);
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(LSRVx, scratch_x1.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x2 is killed and marked as dead
    param_2.reset();
    // result x1 is marked as alive


    // renamable $x8 = LSLVXr killed renamable $x8, killed renamable $x9
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = scratch_x9.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LSLVx, scratch_x8.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x8 is killed and marked as dead
    // argument x9 is killed and marked as dead
    // result x8 is marked as alive


    // $x0 = ORRXrs killed renamable $x8, killed renamable $x10, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = scratch_x10.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x10 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shri128_ge64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function shri128_ge64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x1, $x2
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x1, $x2
    //   renamable $x0 = LSRVXr killed renamable $x1, killed renamable $x2
    //   $x1 = ORRXrs $xzr, $xzr, 0
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function shri128_ge64.
    // 

    // Mapping x1 to param_0
    // Mapping x2 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};


    // renamable $x0 = LSRVXr killed renamable $x1, killed renamable $x2
    do {
    {
    auto cond0 = param_1.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LSRxi, scratch_x0.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LSRVx, scratch_x0.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_0.reset();
    // argument x2 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // $x1 = ORRXrs $xzr, $xzr, 0
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x1.cur_reg, DA_ZR, DA_ZR, 0);
    }
    }
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ashri128_lt64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function ashri128_lt64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1, $x2
    //   renamable $x8 = UBFMXri renamable $x1, 63, 62
    //   $w9 = ORNWrs $wzr, renamable $w2, 0, implicit-def $x9
    //   renamable $x10 = LSRVXr killed renamable $x0, renamable $x2
    //   renamable $x1 = ASRVXr killed renamable $x1, killed renamable $x2
    //   renamable $x8 = LSLVXr killed renamable $x8, killed renamable $x9
    //   $x0 = ORRXrs killed renamable $x8, killed renamable $x10, 0
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function ashri128_lt64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};
    ScratchReg scratch_x10{derived()};


    // renamable $x8 = UBFMXri renamable $x1, 63, 62
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UBFMx, scratch_x8.cur_reg, op1, 0x3f, 0x3e);
    }
    }
    // result x8 is marked as alive


    // $w9 = ORNWrs $wzr, renamable $w2, 0, implicit-def $x9
    {
    if (1) {
        AsmReg op2 = param_2.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ORNw_lsl, scratch_x9.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x9 is marked as alive
    // result x9 is marked as alive


    // renamable $x10 = LSRVXr killed renamable $x0, renamable $x2
    do {
    {
    auto cond0 = param_2.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x10, 0);
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(LSRxi, scratch_x10.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x10, 0);
        AsmReg op2 = param_2.as_reg(this);
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(LSRVx, scratch_x10.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x10 is marked as alive


    // renamable $x1 = ASRVXr killed renamable $x1, killed renamable $x2
    do {
    {
    auto cond1 = param_2.encodeable_as_imm();
    if (cond1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x1, 0);
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(ASRxi, scratch_x1.cur_reg, op1, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x1, 0);
        AsmReg op2 = param_2.as_reg_try_salvage(this, scratch_x1, 0);
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(ASRVx, scratch_x1.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();
    // argument x2 is killed and marked as dead
    param_2.reset();
    // result x1 is marked as alive


    // renamable $x8 = LSLVXr killed renamable $x8, killed renamable $x9
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = scratch_x9.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LSLVx, scratch_x8.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x8 is killed and marked as dead
    // argument x9 is killed and marked as dead
    // result x8 is marked as alive


    // $x0 = ORRXrs killed renamable $x8, killed renamable $x10, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = scratch_x10.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x10 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ashri128_ge64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function ashri128_ge64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x1, $x2
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x1, $x2
    //   renamable $x8 = SBFMXri renamable $x1, 63, 63
    //   renamable $x0 = ASRVXr killed renamable $x1, killed renamable $x2
    //   $x1 = ORRXrs $xzr, killed $x8, 0
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function ashri128_ge64.
    // 

    // Mapping x1 to param_0
    // Mapping x2 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $x8 = SBFMXri renamable $x1, 63, 63
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SBFMx, scratch_x8.cur_reg, op1, 0x3f, 0x3f);
    }
    }
    // result x8 is marked as alive


    // renamable $x0 = ASRVXr killed renamable $x1, killed renamable $x2
    do {
    {
    auto cond0 = param_1.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ASRxi, scratch_x0.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ASRVx, scratch_x0.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_0.reset();
    // argument x2 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // $x1 = ORRXrs $xzr, killed $x8, 0
    {
    if (1) {
        AsmReg op2 = scratch_x8.cur_reg;
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x1.cur_reg, DA_ZR, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cttzi32_zero_poison(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function cttzi32_zero_poison: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w8 = RBITWr killed renamable $w0
    //   renamable $w0 = CLZWr killed renamable $w8
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function cttzi32_zero_poison.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = RBITWr killed renamable $w0
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(RBITw, scratch_x8.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $w0 = CLZWr killed renamable $w8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CLZw, scratch_x0.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cttzi64_zero_poison(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function cttzi64_zero_poison: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $x8 = RBITXr killed renamable $x0
    //   renamable $x0 = CLZXr killed renamable $x8
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function cttzi64_zero_poison.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $x8 = RBITXr killed renamable $x0
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(RBITx, scratch_x8.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $x0 = CLZXr killed renamable $x8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CLZx, scratch_x0.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cttzi8(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function cttzi8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w8 = ORRWri killed renamable $w0, 1536
    //   renamable $w8 = RBITWr killed renamable $w8
    //   renamable $w0 = CLZWr killed renamable $w8
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function cttzi8.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = ORRWri killed renamable $w0, 1536
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ORRwi, scratch_x8.cur_reg, op1, 0x100);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $w8 = RBITWr killed renamable $w8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(RBITw, scratch_x8.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // renamable $w0 = CLZWr killed renamable $w8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CLZw, scratch_x0.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cttzi16(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function cttzi16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w8 = ORRWri killed renamable $w0, 1024
    //   renamable $w8 = RBITWr killed renamable $w8
    //   renamable $w0 = CLZWr killed renamable $w8
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function cttzi16.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = ORRWri killed renamable $w0, 1024
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ORRwi, scratch_x8.cur_reg, op1, 0x10000);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $w8 = RBITWr killed renamable $w8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(RBITw, scratch_x8.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // renamable $w0 = CLZWr killed renamable $w8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CLZw, scratch_x0.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cttzi32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function cttzi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w8 = RBITWr killed renamable $w0
    //   renamable $w0 = CLZWr killed renamable $w8
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function cttzi32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = RBITWr killed renamable $w0
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(RBITw, scratch_x8.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $w0 = CLZWr killed renamable $w8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CLZw, scratch_x0.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cttzi64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function cttzi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $x8 = RBITXr killed renamable $x0
    //   renamable $x0 = CLZXr killed renamable $x8
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function cttzi64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $x8 = RBITXr killed renamable $x0
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(RBITx, scratch_x8.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $x0 = CLZXr killed renamable $x8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CLZx, scratch_x0.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ctlzi8_zero_poison(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function ctlzi8_zero_poison: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w8 = ANDWri killed renamable $w0, 7
    //   renamable $w8 = CLZWr killed renamable $w8
    //   renamable $w0 = nsw SUBWri killed renamable $w8, 24, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function ctlzi8_zero_poison.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = ANDWri killed renamable $w0, 7
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x8.cur_reg, op1, 0xff);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $w8 = CLZWr killed renamable $w8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CLZw, scratch_x8.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // renamable $w0 = nsw SUBWri killed renamable $w8, 24, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SUBwi, scratch_x0.cur_reg, op1, 24);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ctlzi16_zero_poison(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function ctlzi16_zero_poison: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w8 = ANDWri killed renamable $w0, 15
    //   renamable $w8 = CLZWr killed renamable $w8
    //   renamable $w0 = nsw SUBWri killed renamable $w8, 16, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function ctlzi16_zero_poison.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = ANDWri killed renamable $w0, 15
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x8.cur_reg, op1, 0xffff);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $w8 = CLZWr killed renamable $w8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CLZw, scratch_x8.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // renamable $w0 = nsw SUBWri killed renamable $w8, 16, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SUBwi, scratch_x0.cur_reg, op1, 16);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ctlzi32_zero_poison(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function ctlzi32_zero_poison: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w0 = CLZWr killed renamable $w0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function ctlzi32_zero_poison.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = CLZWr killed renamable $w0
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CLZw, scratch_x0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ctlzi64_zero_poison(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function ctlzi64_zero_poison: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $x0 = CLZXr killed renamable $x0
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function ctlzi64_zero_poison.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $x0 = CLZXr killed renamable $x0
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CLZx, scratch_x0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ctlzi8(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function ctlzi8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w9 = ANDSWri renamable $w0, 7, implicit-def dead $nzcv
    //   renamable $w8 = MOVZWi 8, 0
    //   renamable $w9 = CLZWr killed renamable $w9
    //   $wzr = ANDSWri killed renamable $w0, 7, implicit-def $nzcv
    //   renamable $w9 = nsw SUBWri killed renamable $w9, 24, 0
    //   renamable $w0 = CSELWr killed renamable $w8, killed renamable $w9, 0, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function ctlzi8.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w9 = ANDSWri renamable $w0, 7, implicit-def dead $nzcv
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ANDSwi, scratch_x9.cur_reg, op1, 0xff);
    }
    }
    // result x9 is marked as alive


    // renamable $w8 = MOVZWi 8, 0
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZw_shift, scratch_x8.cur_reg, 0x8, 0);
    }
    }
    // result x8 is marked as alive


    // renamable $w9 = CLZWr killed renamable $w9
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(CLZw, scratch_x9.cur_reg, op1);
    }
    }
    // argument x9 is killed and marked as dead
    // result x9 is marked as alive


    // $wzr = ANDSWri killed renamable $w0, 7, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(ANDSwi, DA_ZR, op1, 0xff);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();


    // renamable $w9 = nsw SUBWri killed renamable $w9, 24, 0
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(SUBwi, scratch_x9.cur_reg, op1, 24);
    }
    }
    // argument x9 is killed and marked as dead
    // result x9 is marked as alive


    // renamable $w0 = CSELWr killed renamable $w8, killed renamable $w9, 0, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = scratch_x9.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSELw, scratch_x0.cur_reg, op1, op2, DA_EQ);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x9 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ctlzi16(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function ctlzi16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w9 = ANDSWri renamable $w0, 15, implicit-def dead $nzcv
    //   renamable $w8 = MOVZWi 16, 0
    //   renamable $w9 = CLZWr killed renamable $w9
    //   $wzr = ANDSWri killed renamable $w0, 15, implicit-def $nzcv
    //   renamable $w9 = nsw SUBWri killed renamable $w9, 16, 0
    //   renamable $w0 = CSELWr killed renamable $w8, killed renamable $w9, 0, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function ctlzi16.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w9 = ANDSWri renamable $w0, 15, implicit-def dead $nzcv
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ANDSwi, scratch_x9.cur_reg, op1, 0xffff);
    }
    }
    // result x9 is marked as alive


    // renamable $w8 = MOVZWi 16, 0
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZw_shift, scratch_x8.cur_reg, 0x10, 0);
    }
    }
    // result x8 is marked as alive


    // renamable $w9 = CLZWr killed renamable $w9
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(CLZw, scratch_x9.cur_reg, op1);
    }
    }
    // argument x9 is killed and marked as dead
    // result x9 is marked as alive


    // $wzr = ANDSWri killed renamable $w0, 15, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(ANDSwi, DA_ZR, op1, 0xffff);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();


    // renamable $w9 = nsw SUBWri killed renamable $w9, 16, 0
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(SUBwi, scratch_x9.cur_reg, op1, 16);
    }
    }
    // argument x9 is killed and marked as dead
    // result x9 is marked as alive


    // renamable $w0 = CSELWr killed renamable $w8, killed renamable $w9, 0, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = scratch_x9.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSELw, scratch_x0.cur_reg, op1, op2, DA_EQ);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x9 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ctlzi32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function ctlzi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w0 = CLZWr killed renamable $w0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function ctlzi32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = CLZWr killed renamable $w0
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CLZw, scratch_x0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ctlzi64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function ctlzi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $x0 = CLZXr killed renamable $x0
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function ctlzi64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $x0 = CLZXr killed renamable $x0
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CLZx, scratch_x0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_i8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_add_i8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w8 = SBFMWri killed renamable $w0, 0, 7
    //   renamable $w8 = ADDWrx killed renamable $w8, killed renamable $w1, 32, implicit-def $x8
    //   $wzr = SUBSWrx renamable $w8, renamable $w8, 32, implicit-def $nzcv
    //   $x0 = ANDXri killed renamable $x8, 4103
    //   renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_add_i8.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = SBFMWri killed renamable $w0, 0, 7
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SBFMw, scratch_x8.cur_reg, op1, 0x0, 0x7);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $w8 = ADDWrx killed renamable $w8, killed renamable $w1, 32, implicit-def $x8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ADDw_sxtb, scratch_x8.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive
    // result x8 is marked as alive


    // $wzr = SUBSWrx renamable $w8, renamable $w8, 32, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSw_sxtb, DA_ZR, op1, op1, 0);
    }
    }


    // $x0 = ANDXri killed renamable $x8, 4103
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x0.cur_reg, op1, 0xff);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_EQ);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_i8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_sub_i8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w8 = SBFMWri killed renamable $w0, 0, 7
    //   renamable $w8 = SUBWrx killed renamable $w8, killed renamable $w1, 32, implicit-def $x8
    //   $wzr = SUBSWrx renamable $w8, renamable $w8, 32, implicit-def $nzcv
    //   $x0 = ANDXri killed renamable $x8, 4103
    //   renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_sub_i8.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = SBFMWri killed renamable $w0, 0, 7
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SBFMw, scratch_x8.cur_reg, op1, 0x0, 0x7);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $w8 = SUBWrx killed renamable $w8, killed renamable $w1, 32, implicit-def $x8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SUBw_sxtb, scratch_x8.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive
    // result x8 is marked as alive


    // $wzr = SUBSWrx renamable $w8, renamable $w8, 32, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSw_sxtb, DA_ZR, op1, op1, 0);
    }
    }


    // $x0 = ANDXri killed renamable $x8, 4103
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x0.cur_reg, op1, 0xff);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_EQ);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_i8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_mul_i8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w8 = SBFMWri killed renamable $w1, 0, 7
    //   renamable $w9 = SBFMWri killed renamable $w0, 0, 7
    //   renamable $w8 = MADDWrrr killed renamable $w9, killed renamable $w8, $wzr, implicit-def $x8
    //   $wzr = SUBSWrx renamable $w8, renamable $w8, 32, implicit-def $nzcv
    //   $x0 = ANDXri killed renamable $x8, 4103
    //   renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_mul_i8.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = SBFMWri killed renamable $w1, 0, 7
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SBFMw, scratch_x8.cur_reg, op1, 0x0, 0x7);
    }
    }
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive


    // renamable $w9 = SBFMWri killed renamable $w0, 0, 7
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x9, 0);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(SBFMw, scratch_x9.cur_reg, op1, 0x0, 0x7);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x9 is marked as alive


    // renamable $w8 = MADDWrrr killed renamable $w9, killed renamable $w8, $wzr, implicit-def $x8
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MADDw, scratch_x8.cur_reg, op1, op2, DA_ZR);
    }
    }
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive
    // result x8 is marked as alive


    // $wzr = SUBSWrx renamable $w8, renamable $w8, 32, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSw_sxtb, DA_ZR, op1, op1, 0);
    }
    }


    // $x0 = ANDXri killed renamable $x8, 4103
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x0.cur_reg, op1, 0xff);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_EQ);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_u8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_add_u8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w8 = ANDWri killed renamable $w0, 7
    //   renamable $w8 = ADDWrx killed renamable $w8, killed renamable $w1, 0, implicit-def $x8
    //   renamable $w1 = UBFMWri renamable $w8, 8, 31, implicit-def $x1
    //   $x0 = ANDXri killed renamable $x8, 4103
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_add_u8.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = ANDWri killed renamable $w0, 7
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x8.cur_reg, op1, 0xff);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $w8 = ADDWrx killed renamable $w8, killed renamable $w1, 0, implicit-def $x8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ADDw_uxtb, scratch_x8.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive
    // result x8 is marked as alive


    // renamable $w1 = UBFMWri renamable $w8, 8, 31, implicit-def $x1
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(UBFMw, scratch_x1.cur_reg, op1, 0x8, 0x1f);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // $x0 = ANDXri killed renamable $x8, 4103
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x0.cur_reg, op1, 0xff);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_u8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_sub_u8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w8 = ANDWri killed renamable $w0, 7
    //   renamable $w8 = SUBWrx killed renamable $w8, killed renamable $w1, 0, implicit-def $x8
    //   $wzr = ANDSWri renamable $w8, 1559, implicit-def $nzcv
    //   $x0 = ANDXri killed renamable $x8, 4103
    //   renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_sub_u8.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = ANDWri killed renamable $w0, 7
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x8.cur_reg, op1, 0xff);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $w8 = SUBWrx killed renamable $w8, killed renamable $w1, 0, implicit-def $x8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SUBw_uxtb, scratch_x8.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive
    // result x8 is marked as alive


    // $wzr = ANDSWri renamable $w8, 1559, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(ANDSwi, DA_ZR, op1, 0xffffff00);
    }
    }


    // $x0 = ANDXri killed renamable $x8, 4103
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x0.cur_reg, op1, 0xff);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_EQ);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_u8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_mul_u8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w8 = ANDWri killed renamable $w1, 7
    //   renamable $w9 = ANDWri killed renamable $w0, 7
    //   renamable $w8 = MADDWrrr killed renamable $w9, killed renamable $w8, $wzr, implicit-def $x8
    //   $wzr = ANDSWri renamable $w8, 1543, implicit-def $nzcv
    //   $x0 = ANDXri killed renamable $x8, 4103
    //   renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_mul_u8.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = ANDWri killed renamable $w1, 7
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x8.cur_reg, op1, 0xff);
    }
    }
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive


    // renamable $w9 = ANDWri killed renamable $w0, 7
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x9, 0);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x9.cur_reg, op1, 0xff);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x9 is marked as alive


    // renamable $w8 = MADDWrrr killed renamable $w9, killed renamable $w8, $wzr, implicit-def $x8
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MADDw, scratch_x8.cur_reg, op1, op2, DA_ZR);
    }
    }
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive
    // result x8 is marked as alive


    // $wzr = ANDSWri renamable $w8, 1543, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(ANDSwi, DA_ZR, op1, 0xff00);
    }
    }


    // $x0 = ANDXri killed renamable $x8, 4103
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x0.cur_reg, op1, 0xff);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_EQ);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_i16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_add_i16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w8 = SBFMWri killed renamable $w0, 0, 15
    //   renamable $w8 = ADDWrx killed renamable $w8, killed renamable $w1, 40, implicit-def $x8
    //   $wzr = SUBSWrx renamable $w8, renamable $w8, 40, implicit-def $nzcv
    //   $x0 = ANDXri killed renamable $x8, 4111
    //   renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_add_i16.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = SBFMWri killed renamable $w0, 0, 15
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SBFMw, scratch_x8.cur_reg, op1, 0x0, 0xf);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $w8 = ADDWrx killed renamable $w8, killed renamable $w1, 40, implicit-def $x8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ADDw_sxth, scratch_x8.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive
    // result x8 is marked as alive


    // $wzr = SUBSWrx renamable $w8, renamable $w8, 40, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSw_sxth, DA_ZR, op1, op1, 0);
    }
    }


    // $x0 = ANDXri killed renamable $x8, 4111
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x0.cur_reg, op1, 0xffff);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_EQ);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_i16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_sub_i16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w8 = SBFMWri killed renamable $w0, 0, 15
    //   renamable $w8 = SUBWrx killed renamable $w8, killed renamable $w1, 40, implicit-def $x8
    //   $wzr = SUBSWrx renamable $w8, renamable $w8, 40, implicit-def $nzcv
    //   $x0 = ANDXri killed renamable $x8, 4111
    //   renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_sub_i16.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = SBFMWri killed renamable $w0, 0, 15
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SBFMw, scratch_x8.cur_reg, op1, 0x0, 0xf);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $w8 = SUBWrx killed renamable $w8, killed renamable $w1, 40, implicit-def $x8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SUBw_sxth, scratch_x8.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive
    // result x8 is marked as alive


    // $wzr = SUBSWrx renamable $w8, renamable $w8, 40, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSw_sxth, DA_ZR, op1, op1, 0);
    }
    }


    // $x0 = ANDXri killed renamable $x8, 4111
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x0.cur_reg, op1, 0xffff);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_EQ);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_i16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_mul_i16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w8 = SBFMWri killed renamable $w1, 0, 15
    //   renamable $w9 = SBFMWri killed renamable $w0, 0, 15
    //   renamable $w8 = MADDWrrr killed renamable $w9, killed renamable $w8, $wzr, implicit-def $x8
    //   $wzr = SUBSWrx renamable $w8, renamable $w8, 40, implicit-def $nzcv
    //   $x0 = ANDXri killed renamable $x8, 4111
    //   renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_mul_i16.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = SBFMWri killed renamable $w1, 0, 15
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SBFMw, scratch_x8.cur_reg, op1, 0x0, 0xf);
    }
    }
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive


    // renamable $w9 = SBFMWri killed renamable $w0, 0, 15
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x9, 0);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(SBFMw, scratch_x9.cur_reg, op1, 0x0, 0xf);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x9 is marked as alive


    // renamable $w8 = MADDWrrr killed renamable $w9, killed renamable $w8, $wzr, implicit-def $x8
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MADDw, scratch_x8.cur_reg, op1, op2, DA_ZR);
    }
    }
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive
    // result x8 is marked as alive


    // $wzr = SUBSWrx renamable $w8, renamable $w8, 40, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSw_sxth, DA_ZR, op1, op1, 0);
    }
    }


    // $x0 = ANDXri killed renamable $x8, 4111
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x0.cur_reg, op1, 0xffff);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_EQ);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_u16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_add_u16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w8 = ANDWri killed renamable $w0, 15
    //   renamable $w8 = ADDWrx killed renamable $w8, killed renamable $w1, 8, implicit-def $x8
    //   renamable $w1 = UBFMWri renamable $w8, 16, 31, implicit-def $x1
    //   $x0 = ANDXri killed renamable $x8, 4111
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_add_u16.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = ANDWri killed renamable $w0, 15
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x8.cur_reg, op1, 0xffff);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $w8 = ADDWrx killed renamable $w8, killed renamable $w1, 8, implicit-def $x8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ADDw_uxth, scratch_x8.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive
    // result x8 is marked as alive


    // renamable $w1 = UBFMWri renamable $w8, 16, 31, implicit-def $x1
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(UBFMw, scratch_x1.cur_reg, op1, 0x10, 0x1f);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // $x0 = ANDXri killed renamable $x8, 4111
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x0.cur_reg, op1, 0xffff);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_u16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_sub_u16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w8 = ANDWri killed renamable $w0, 15
    //   renamable $w8 = SUBWrx killed renamable $w8, killed renamable $w1, 8, implicit-def $x8
    //   $wzr = ANDSWri renamable $w8, 1039, implicit-def $nzcv
    //   $x0 = ANDXri killed renamable $x8, 4111
    //   renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_sub_u16.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = ANDWri killed renamable $w0, 15
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x8.cur_reg, op1, 0xffff);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $w8 = SUBWrx killed renamable $w8, killed renamable $w1, 8, implicit-def $x8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SUBw_uxth, scratch_x8.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive
    // result x8 is marked as alive


    // $wzr = ANDSWri renamable $w8, 1039, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(ANDSwi, DA_ZR, op1, 0xffff0000);
    }
    }


    // $x0 = ANDXri killed renamable $x8, 4111
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x0.cur_reg, op1, 0xffff);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_EQ);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_u16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_mul_u16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w8 = ANDWri killed renamable $w1, 15
    //   renamable $w9 = ANDWri killed renamable $w0, 15
    //   renamable $w8 = MADDWrrr killed renamable $w9, killed renamable $w8, $wzr, implicit-def $x8
    //   $wzr = ANDSWri renamable $w8, 1039, implicit-def $nzcv
    //   $x0 = ANDXri killed renamable $x8, 4111
    //   renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_mul_u16.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = ANDWri killed renamable $w1, 15
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x8.cur_reg, op1, 0xffff);
    }
    }
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive


    // renamable $w9 = ANDWri killed renamable $w0, 15
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x9, 0);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x9.cur_reg, op1, 0xffff);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x9 is marked as alive


    // renamable $w8 = MADDWrrr killed renamable $w9, killed renamable $w8, $wzr, implicit-def $x8
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MADDw, scratch_x8.cur_reg, op1, op2, DA_ZR);
    }
    }
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive
    // result x8 is marked as alive


    // $wzr = ANDSWri renamable $w8, 1039, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(ANDSwi, DA_ZR, op1, 0xffff0000);
    }
    }


    // $x0 = ANDXri killed renamable $x8, 4111
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x0.cur_reg, op1, 0xffff);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_EQ);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_i32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_add_i32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   $w0 = ADDSWrs killed renamable $w0, killed renamable $w1, 0, implicit-def $nzcv, implicit-def $x0
    //   renamable $w1 = CSINCWr $wzr, $wzr, 7, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_add_i32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $w0 = ADDSWrs killed renamable $w0, killed renamable $w1, 0, implicit-def $nzcv, implicit-def $x0
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDSwi, scratch_x0.cur_reg, op1, (*cond0));        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_immarith();
    if (cond1) {
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDSwi, scratch_x0.cur_reg, op2, (*cond1));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDSw_lsl, scratch_x0.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 7, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_VC);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_i32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_sub_i32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   $w0 = SUBSWrs killed renamable $w0, killed renamable $w1, 0, implicit-def $nzcv, implicit-def $x0
    //   renamable $w1 = CSINCWr $wzr, $wzr, 7, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_sub_i32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $w0 = SUBSWrs killed renamable $w0, killed renamable $w1, 0, implicit-def $nzcv, implicit-def $x0
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SUBSwi, scratch_x0.cur_reg, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SUBSw_lsl, scratch_x0.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 7, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_VC);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_i32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_mul_i32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $x8 = SMADDLrrr killed renamable $w0, killed renamable $w1, $xzr
    //   $xzr = SUBSXrx renamable $x8, renamable $w8, 48, implicit-def $nzcv
    //   $x0 = ANDXri killed renamable $x8, 4127
    //   renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_mul_i32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $x8 = SMADDLrrr killed renamable $w0, killed renamable $w1, $xzr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SMADDL, scratch_x8.cur_reg, op1, op2, DA_ZR);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive


    // $xzr = SUBSXrx renamable $x8, renamable $w8, 48, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSx_sxtw, DA_ZR, op1, op1, 0);
    }
    }


    // $x0 = ANDXri killed renamable $x8, 4127
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x0.cur_reg, op1, 0xffffffff);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_EQ);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_u32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_add_u32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   $w0 = ADDSWrs killed renamable $w0, killed renamable $w1, 0, implicit-def $nzcv, implicit-def $x0
    //   renamable $w1 = CSINCWr $wzr, $wzr, 3, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_add_u32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $w0 = ADDSWrs killed renamable $w0, killed renamable $w1, 0, implicit-def $nzcv, implicit-def $x0
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDSwi, scratch_x0.cur_reg, op1, (*cond0));        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_immarith();
    if (cond1) {
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDSwi, scratch_x0.cur_reg, op2, (*cond1));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDSw_lsl, scratch_x0.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 3, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_LO);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_u32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_sub_u32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   $w0 = SUBSWrs killed renamable $w0, killed renamable $w1, 0, implicit-def $nzcv, implicit-def $x0
    //   renamable $w1 = CSINCWr $wzr, $wzr, 2, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_sub_u32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $w0 = SUBSWrs killed renamable $w0, killed renamable $w1, 0, implicit-def $nzcv, implicit-def $x0
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SUBSwi, scratch_x0.cur_reg, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SUBSw_lsl, scratch_x0.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 2, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_HS);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_u32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_mul_u32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $x8 = UMADDLrrr killed renamable $w0, killed renamable $w1, $xzr
    //   $xzr = ANDSXri renamable $x8, 6175, implicit-def $nzcv
    //   $x0 = ANDXri killed renamable $x8, 4127
    //   renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_mul_u32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $x8 = UMADDLrrr killed renamable $w0, killed renamable $w1, $xzr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UMADDL, scratch_x8.cur_reg, op1, op2, DA_ZR);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive


    // $xzr = ANDSXri renamable $x8, 6175, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(ANDSxi, DA_ZR, op1, 0xffffffff00000000);
    }
    }


    // $x0 = ANDXri killed renamable $x8, 4127
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x0.cur_reg, op1, 0xffffffff);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_EQ);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_i64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_add_i64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   $x0 = ADDSXrs killed renamable $x0, killed renamable $x1, 0, implicit-def $nzcv
    //   renamable $w1 = CSINCWr $wzr, $wzr, 7, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_add_i64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $x0 = ADDSXrs killed renamable $x0, killed renamable $x1, 0, implicit-def $nzcv
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDSxi, scratch_x0.cur_reg, op1, (*cond0));        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_immarith();
    if (cond1) {
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDSxi, scratch_x0.cur_reg, op2, (*cond1));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDSx_lsl, scratch_x0.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 7, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_VC);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_i64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_sub_i64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   $x0 = SUBSXrs killed renamable $x0, killed renamable $x1, 0, implicit-def $nzcv
    //   renamable $w1 = CSINCWr $wzr, $wzr, 7, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_sub_i64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $x0 = SUBSXrs killed renamable $x0, killed renamable $x1, 0, implicit-def $nzcv
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SUBSxi, scratch_x0.cur_reg, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SUBSx_lsl, scratch_x0.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 7, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_VC);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_i64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_mul_i64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   renamable $x8 = MADDXrrr renamable $x0, renamable $x1, $xzr
    //   renamable $x9 = SMULHrr killed renamable $x0, killed renamable $x1
    //   $x0 = ORRXrs $xzr, $x8, 0
    //   $xzr = SUBSXrs killed renamable $x9, killed renamable $x8, 191, implicit-def $nzcv
    //   renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_mul_i64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $x8 = MADDXrrr renamable $x0, renamable $x1, $xzr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MADDx, scratch_x8.cur_reg, op1, op2, DA_ZR);
    }
    }
    // result x8 is marked as alive


    // renamable $x9 = SMULHrr killed renamable $x0, killed renamable $x1
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x9, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x9, 0);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(SMULH, scratch_x9.cur_reg, op1, op2);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x9 is marked as alive


    // $x0 = ORRXrs $xzr, $x8, 0
    {
    if (1) {
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x0 is marked as alive


    // $xzr = SUBSXrs killed renamable $x9, killed renamable $x8, 191, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        ASMD(SUBSx_asr, DA_ZR, op1, op2, 63);
    }
    }
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead


    // renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_EQ);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_u64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_add_u64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   $x0 = ADDSXrs killed renamable $x0, killed renamable $x1, 0, implicit-def $nzcv
    //   renamable $w1 = CSINCWr $wzr, $wzr, 3, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_add_u64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $x0 = ADDSXrs killed renamable $x0, killed renamable $x1, 0, implicit-def $nzcv
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDSxi, scratch_x0.cur_reg, op1, (*cond0));        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_immarith();
    if (cond1) {
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDSxi, scratch_x0.cur_reg, op2, (*cond1));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ADDSx_lsl, scratch_x0.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 3, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_LO);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_u64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_sub_u64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   $x0 = SUBSXrs killed renamable $x0, killed renamable $x1, 0, implicit-def $nzcv
    //   renamable $w1 = CSINCWr $wzr, $wzr, 2, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_sub_u64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};


    // $x0 = SUBSXrs killed renamable $x0, killed renamable $x1, 0, implicit-def $nzcv
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SUBSxi, scratch_x0.cur_reg, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SUBSx_lsl, scratch_x0.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 2, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_HS);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_u64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_mul_u64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $x0, $x1
    //   renamable $x8 = UMULHrr renamable $x0, renamable $x1
    //   renamable $x0 = MADDXrrr killed renamable $x0, killed renamable $x1, $xzr
    //   $xzr = SUBSXrs $xzr, killed renamable $x8, 0, implicit-def $nzcv
    //   renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function of_mul_u64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $x8 = UMULHrr renamable $x0, renamable $x1
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UMULH, scratch_x8.cur_reg, op1, op2);
    }
    }
    // result x8 is marked as alive


    // renamable $x0 = MADDXrrr killed renamable $x0, killed renamable $x1, $xzr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(MADDx, scratch_x0.cur_reg, op1, op2, DA_ZR);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // $xzr = SUBSXrs $xzr, killed renamable $x8, 0, implicit-def $nzcv
    do {
    {
    if (1) {
        AsmReg op2 = scratch_x8.cur_reg;
        ASMD(SUBSx_lsl, DA_ZR, DA_ZR, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x8 is killed and marked as dead


    // renamable $w1 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_EQ);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_addf32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function addf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   renamable $s0 = nofpexcept FADDSrr killed renamable $s0, killed renamable $s1, implicit $fpcr
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function addf32.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $s0 = nofpexcept FADDSrr killed renamable $s0, killed renamable $s1, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_v0, 1);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FADDs, scratch_v0.cur_reg, op1, op2);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_subf32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function subf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   renamable $s0 = nofpexcept FSUBSrr killed renamable $s0, killed renamable $s1, implicit $fpcr
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function subf32.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $s0 = nofpexcept FSUBSrr killed renamable $s0, killed renamable $s1, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_v0, 1);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FSUBs, scratch_v0.cur_reg, op1, op2);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_mulf32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function mulf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   renamable $s0 = nofpexcept FMULSrr killed renamable $s0, killed renamable $s1, implicit $fpcr
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function mulf32.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $s0 = nofpexcept FMULSrr killed renamable $s0, killed renamable $s1, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_v0, 1);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FMULs, scratch_v0.cur_reg, op1, op2);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_divf32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function divf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   renamable $s0 = nofpexcept FDIVSrr killed renamable $s0, killed renamable $s1, implicit $fpcr
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function divf32.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $s0 = nofpexcept FDIVSrr killed renamable $s0, killed renamable $s1, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_v0, 1);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FDIVs, scratch_v0.cur_reg, op1, op2);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_addf64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function addf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   renamable $d0 = nofpexcept FADDDrr killed renamable $d0, killed renamable $d1, implicit $fpcr
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function addf64.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $d0 = nofpexcept FADDDrr killed renamable $d0, killed renamable $d1, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_v0, 1);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FADDd, scratch_v0.cur_reg, op1, op2);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_subf64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function subf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   renamable $d0 = nofpexcept FSUBDrr killed renamable $d0, killed renamable $d1, implicit $fpcr
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function subf64.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $d0 = nofpexcept FSUBDrr killed renamable $d0, killed renamable $d1, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_v0, 1);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FSUBd, scratch_v0.cur_reg, op1, op2);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_mulf64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function mulf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   renamable $d0 = nofpexcept FMULDrr killed renamable $d0, killed renamable $d1, implicit $fpcr
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function mulf64.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $d0 = nofpexcept FMULDrr killed renamable $d0, killed renamable $d1, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_v0, 1);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FMULd, scratch_v0.cur_reg, op1, op2);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_divf64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function divf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   renamable $d0 = nofpexcept FDIVDrr killed renamable $d0, killed renamable $d1, implicit $fpcr
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function divf64.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $d0 = nofpexcept FDIVDrr killed renamable $d0, killed renamable $d1, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_v0, 1);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FDIVd, scratch_v0.cur_reg, op1, op2);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fnegf32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function fnegf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $s0
    //   renamable $s0 = FNEGSr killed renamable $s0
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function fnegf32.
    // 

    // Mapping v0 to param_0
    ScratchReg scratch_v0{derived()};


    // renamable $s0 = FNEGSr killed renamable $s0
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FNEGs, scratch_v0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fnegf64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function fnegf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $d0
    //   renamable $d0 = FNEGDr killed renamable $d0
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function fnegf64.
    // 

    // Mapping v0 to param_0
    ScratchReg scratch_v0{derived()};


    // renamable $d0 = FNEGDr killed renamable $d0
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FNEGd, scratch_v0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fabsf32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function fabsf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $s0
    //   renamable $s0 = FABSSr killed renamable $s0
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function fabsf32.
    // 

    // Mapping v0 to param_0
    ScratchReg scratch_v0{derived()};


    // renamable $s0 = FABSSr killed renamable $s0
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FABSs, scratch_v0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fabsf64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function fabsf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $d0
    //   renamable $d0 = FABSDr killed renamable $d0
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function fabsf64.
    // 

    // Mapping v0 to param_0
    ScratchReg scratch_v0{derived()};


    // renamable $d0 = FABSDr killed renamable $d0
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FABSd, scratch_v0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fmaf32(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0) {
    // # Machine code for function fmaf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1, $s2
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $s0, $s1, $s2
    //   renamable $s0 = nofpexcept FMADDSrrr killed renamable $s0, killed renamable $s1, killed renamable $s2, implicit $fpcr
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function fmaf32.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    // Mapping v2 to param_2
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_v2{derived()};


    // renamable $s0 = nofpexcept FMADDSrrr killed renamable $s0, killed renamable $s1, killed renamable $s2, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_v0, 1);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_v0, 1);
        AsmReg op3 = param_2.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FMADDs, scratch_v0.cur_reg, op1, op2, op3);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();
    // argument v2 is killed and marked as dead
    param_2.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fmaf64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0) {
    // # Machine code for function fmaf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1, $d2
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $d0, $d1, $d2
    //   renamable $d0 = nofpexcept FMADDDrrr killed renamable $d0, killed renamable $d1, killed renamable $d2, implicit $fpcr
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function fmaf64.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    // Mapping v2 to param_2
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_v2{derived()};


    // renamable $d0 = nofpexcept FMADDDrrr killed renamable $d0, killed renamable $d1, killed renamable $d2, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_v0, 1);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_v0, 1);
        AsmReg op3 = param_2.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FMADDd, scratch_v0.cur_reg, op1, op2, op3);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();
    // argument v2 is killed and marked as dead
    param_2.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f64tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f64tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $d0
    //   renamable $s0 = nofpexcept FCVTSDr killed renamable $d0, implicit $fpcr
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function f64tof32.
    // 

    // Mapping v0 to param_0
    ScratchReg scratch_v0{derived()};


    // renamable $s0 = nofpexcept FCVTSDr killed renamable $d0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FCVTsd, scratch_v0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f32tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f32tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $s0
    //   renamable $d0 = nofpexcept FCVTDSr killed renamable $s0, implicit $fpcr
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function f32tof64.
    // 

    // Mapping v0 to param_0
    ScratchReg scratch_v0{derived()};


    // renamable $d0 = nofpexcept FCVTDSr killed renamable $s0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FCVTds, scratch_v0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f32toi32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f32toi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $s0
    //   renamable $w0 = nofpexcept FCVTZSUWSr killed renamable $s0, implicit $fpcr
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function f32toi32.
    // 

    // Mapping v0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $w0 = nofpexcept FCVTZSUWSr killed renamable $s0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(FCVTZSws, scratch_x0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f32tou32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f32tou32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $s0
    //   renamable $w0 = nofpexcept FCVTZUUWSr killed renamable $s0, implicit $fpcr
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function f32tou32.
    // 

    // Mapping v0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $w0 = nofpexcept FCVTZUUWSr killed renamable $s0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(FCVTZUws, scratch_x0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f32toi64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f32toi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $s0
    //   renamable $x0 = nofpexcept FCVTZSUXSr killed renamable $s0, implicit $fpcr
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function f32toi64.
    // 

    // Mapping v0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $x0 = nofpexcept FCVTZSUXSr killed renamable $s0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(FCVTZSxs, scratch_x0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f32tou64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f32tou64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $s0
    //   renamable $x0 = nofpexcept FCVTZUUXSr killed renamable $s0, implicit $fpcr
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function f32tou64.
    // 

    // Mapping v0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $x0 = nofpexcept FCVTZUUXSr killed renamable $s0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(FCVTZUxs, scratch_x0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f64toi32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f64toi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $d0
    //   renamable $w0 = nofpexcept FCVTZSUWDr killed renamable $d0, implicit $fpcr
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function f64toi32.
    // 

    // Mapping v0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $w0 = nofpexcept FCVTZSUWDr killed renamable $d0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(FCVTZSwd, scratch_x0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f64tou32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f64tou32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $d0
    //   renamable $w0 = nofpexcept FCVTZUUWDr killed renamable $d0, implicit $fpcr
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function f64tou32.
    // 

    // Mapping v0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $w0 = nofpexcept FCVTZUUWDr killed renamable $d0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(FCVTZUwd, scratch_x0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f64toi64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f64toi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $d0
    //   renamable $x0 = nofpexcept FCVTZSUXDr killed renamable $d0, implicit $fpcr
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function f64toi64.
    // 

    // Mapping v0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $x0 = nofpexcept FCVTZSUXDr killed renamable $d0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(FCVTZSxd, scratch_x0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f64tou64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f64tou64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $d0
    //   renamable $x0 = nofpexcept FCVTZUUXDr killed renamable $d0, implicit $fpcr
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function f64tou64.
    // 

    // Mapping v0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $x0 = nofpexcept FCVTZUUXDr killed renamable $d0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(FCVTZUxd, scratch_x0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_i8tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function i8tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w8 = SBFMWri killed renamable $w0, 0, 7
    //   renamable $s0 = nofpexcept SCVTFUWSri killed renamable $w8, implicit $fpcr
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function i8tof32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = SBFMWri killed renamable $w0, 0, 7
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SBFMw, scratch_x8.cur_reg, op1, 0x0, 0x7);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $s0 = nofpexcept SCVTFUWSri killed renamable $w8, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(SCVTFsw, scratch_v0.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_i16tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function i16tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w8 = SBFMWri killed renamable $w0, 0, 15
    //   renamable $s0 = nofpexcept SCVTFUWSri killed renamable $w8, implicit $fpcr
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function i16tof32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = SBFMWri killed renamable $w0, 0, 15
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SBFMw, scratch_x8.cur_reg, op1, 0x0, 0xf);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $s0 = nofpexcept SCVTFUWSri killed renamable $w8, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(SCVTFsw, scratch_v0.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_i32tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function i32tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $s0 = nofpexcept SCVTFUWSri killed renamable $w0, implicit $fpcr
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function i32tof32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $s0 = nofpexcept SCVTFUWSri killed renamable $w0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(SCVTFsw, scratch_v0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_i64tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function i64tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $s0 = nofpexcept SCVTFUXSri killed renamable $x0, implicit $fpcr
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function i64tof32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $s0 = nofpexcept SCVTFUXSri killed renamable $x0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(SCVTFsx, scratch_v0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_u8tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function u8tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w8 = ANDWri killed renamable $w0, 7
    //   renamable $s0 = nofpexcept UCVTFUWSri killed renamable $w8, implicit $fpcr
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function u8tof32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = ANDWri killed renamable $w0, 7
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x8.cur_reg, op1, 0xff);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $s0 = nofpexcept UCVTFUWSri killed renamable $w8, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(UCVTFsw, scratch_v0.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_u16tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function u16tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w8 = ANDWri killed renamable $w0, 15
    //   renamable $s0 = nofpexcept UCVTFUWSri killed renamable $w8, implicit $fpcr
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function u16tof32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = ANDWri killed renamable $w0, 15
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x8.cur_reg, op1, 0xffff);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $s0 = nofpexcept UCVTFUWSri killed renamable $w8, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(UCVTFsw, scratch_v0.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_u32tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function u32tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $s0 = nofpexcept UCVTFUWSri killed renamable $w0, implicit $fpcr
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function u32tof32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $s0 = nofpexcept UCVTFUWSri killed renamable $w0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(UCVTFsw, scratch_v0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_u64tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function u64tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $s0 = nofpexcept UCVTFUXSri killed renamable $x0, implicit $fpcr
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function u64tof32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $s0 = nofpexcept UCVTFUXSri killed renamable $x0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(UCVTFsx, scratch_v0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_i8tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function i8tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w8 = SBFMWri killed renamable $w0, 0, 7
    //   renamable $d0 = nofpexcept SCVTFUWDri killed renamable $w8, implicit $fpcr
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function i8tof64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = SBFMWri killed renamable $w0, 0, 7
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SBFMw, scratch_x8.cur_reg, op1, 0x0, 0x7);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $d0 = nofpexcept SCVTFUWDri killed renamable $w8, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(SCVTFdw, scratch_v0.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_i16tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function i16tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w8 = SBFMWri killed renamable $w0, 0, 15
    //   renamable $d0 = nofpexcept SCVTFUWDri killed renamable $w8, implicit $fpcr
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function i16tof64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = SBFMWri killed renamable $w0, 0, 15
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SBFMw, scratch_x8.cur_reg, op1, 0x0, 0xf);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $d0 = nofpexcept SCVTFUWDri killed renamable $w8, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(SCVTFdw, scratch_v0.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_i32tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function i32tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $d0 = nofpexcept SCVTFUWDri killed renamable $w0, implicit $fpcr
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function i32tof64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $d0 = nofpexcept SCVTFUWDri killed renamable $w0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(SCVTFdw, scratch_v0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_i64tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function i64tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $d0 = nofpexcept SCVTFUXDri killed renamable $x0, implicit $fpcr
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function i64tof64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $d0 = nofpexcept SCVTFUXDri killed renamable $x0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(SCVTFdx, scratch_v0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_u8tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function u8tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w8 = ANDWri killed renamable $w0, 7
    //   renamable $d0 = nofpexcept UCVTFUWDri killed renamable $w8, implicit $fpcr
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function u8tof64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = ANDWri killed renamable $w0, 7
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x8.cur_reg, op1, 0xff);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $d0 = nofpexcept UCVTFUWDri killed renamable $w8, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(UCVTFdw, scratch_v0.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_u16tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function u16tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w8 = ANDWri killed renamable $w0, 15
    //   renamable $d0 = nofpexcept UCVTFUWDri killed renamable $w8, implicit $fpcr
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function u16tof64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = ANDWri killed renamable $w0, 15
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x8.cur_reg, op1, 0xffff);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $d0 = nofpexcept UCVTFUWDri killed renamable $w8, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(UCVTFdw, scratch_v0.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_u32tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function u32tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $d0 = nofpexcept UCVTFUWDri killed renamable $w0, implicit $fpcr
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function u32tof64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $d0 = nofpexcept UCVTFUWDri killed renamable $w0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(UCVTFdw, scratch_v0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_u64tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function u64tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $d0 = nofpexcept UCVTFUXDri killed renamable $x0, implicit $fpcr
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function u64tof64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};


    // renamable $d0 = nofpexcept UCVTFUXDri killed renamable $x0, implicit $fpcr
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(UCVTFdx, scratch_v0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sext_8_to_32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function sext_8_to_32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w0 = SBFMWri killed renamable $w0, 0, 7
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function sext_8_to_32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = SBFMWri killed renamable $w0, 0, 7
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SBFMw, scratch_x0.cur_reg, op1, 0x0, 0x7);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sext_8_to_64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function sext_8_to_64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w0 = KILL killed $w0, implicit-def $x0
    //   renamable $x0 = SBFMXri killed renamable $x0, 0, 7
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function sext_8_to_64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = KILL killed $w0, implicit-def $x0
    // KILL is a no-op


    // renamable $x0 = SBFMXri killed renamable $x0, 0, 7
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SBFMx, scratch_x0.cur_reg, op1, 0x0, 0x7);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sext_16_to_32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function sext_16_to_32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w0 = SBFMWri killed renamable $w0, 0, 15
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function sext_16_to_32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = SBFMWri killed renamable $w0, 0, 15
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SBFMw, scratch_x0.cur_reg, op1, 0x0, 0xf);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sext_16_to_64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function sext_16_to_64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w0 = KILL killed $w0, implicit-def $x0
    //   renamable $x0 = SBFMXri killed renamable $x0, 0, 15
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function sext_16_to_64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = KILL killed $w0, implicit-def $x0
    // KILL is a no-op


    // renamable $x0 = SBFMXri killed renamable $x0, 0, 15
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SBFMx, scratch_x0.cur_reg, op1, 0x0, 0xf);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sext_32_to_64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function sext_32_to_64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w0 = KILL killed $w0, implicit-def $x0
    //   renamable $x0 = SBFMXri killed renamable $x0, 0, 31
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function sext_32_to_64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = KILL killed $w0, implicit-def $x0
    // KILL is a no-op


    // renamable $x0 = SBFMXri killed renamable $x0, 0, 31
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SBFMx, scratch_x0.cur_reg, op1, 0x0, 0x1f);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sext_arbitrary_to_32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sext_arbitrary_to_32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w0, $w1
    //   renamable $w8 = LSLVWr killed renamable $w0, renamable $w1
    //   renamable $w0 = exact ASRVWr killed renamable $w8, killed renamable $w1
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function sext_arbitrary_to_32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = LSLVWr killed renamable $w0, renamable $w1
    do {
    {
    auto cond0 = param_1.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LSLwi, scratch_x8.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LSLVw, scratch_x8.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $w0 = exact ASRVWr killed renamable $w8, killed renamable $w1
    do {
    {
    auto cond1 = param_1.encodeable_as_imm();
    if (cond1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ASRwi, scratch_x0.cur_reg, op1, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ASRVw, scratch_x0.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x8 is killed and marked as dead
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sext_arbitrary_to_64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sext_arbitrary_to_64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $w1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $w1, $x0
    //   renamable $w1 = KILL killed $w1, implicit-def $x1
    //   renamable $x8 = LSLVXr killed renamable $x0, renamable $x1
    //   renamable $x0 = exact ASRVXr killed renamable $x8, killed renamable $x1
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function sext_arbitrary_to_64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w1 = KILL killed $w1, implicit-def $x1
    // KILL is a no-op


    // renamable $x8 = LSLVXr killed renamable $x0, renamable $x1
    do {
    {
    auto cond0 = param_1.encodeable_as_imm();
    if (cond0) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LSLxi, scratch_x8.cur_reg, op1, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x8, 0);
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(LSLVx, scratch_x8.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // renamable $x0 = exact ASRVXr killed renamable $x8, killed renamable $x1
    do {
    {
    auto cond1 = param_1.encodeable_as_imm();
    if (cond1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ASRxi, scratch_x0.cur_reg, op1, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ASRVx, scratch_x0.cur_reg, op1, op2);
        break;
    }
    }
    } while (false);
    // argument x8 is killed and marked as dead
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fill_with_sign64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function fill_with_sign64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $x0 = SBFMXri killed renamable $x0, 63, 63
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function fill_with_sign64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $x0 = SBFMXri killed renamable $x0, 63, 63
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(SBFMx, scratch_x0.cur_reg, op1, 0x3f, 0x3f);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_zext_8_to_32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function zext_8_to_32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   $w0 = ANDWri killed renamable $w0, 7
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function zext_8_to_32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // $w0 = ANDWri killed renamable $w0, 7
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x0.cur_reg, op1, 0xff);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_zext_16_to_32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function zext_16_to_32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   $w0 = ANDWri killed renamable $w0, 15
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function zext_16_to_32.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // $w0 = ANDWri killed renamable $w0, 15
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x0.cur_reg, op1, 0xffff);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_zext_32_to_64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function zext_32_to_64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $w0
    //   renamable $w0 = ORRWrs $wzr, killed renamable $w0, 0, implicit-def $x0
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function zext_32_to_64.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = ORRWrs $wzr, killed renamable $w0, 0, implicit-def $x0
    {
    if (1) {
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, DA_ZR, op2, 0);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_monotonic_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_monotonic_monotonic: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $x0, $x1, $x2
    //   $x8 = ORRXrs $xzr, $x1, 0
    //   renamable $x8 = CASX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store monotonic monotonic (s64) on %ir.0)
    //   $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    //   $x0 = ORRXrs $xzr, killed $x8, 0
    //   renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function cmpxchg_u64_monotonic_monotonic.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // $x8 = ORRXrs $xzr, $x1, 0
    {
    if (1) {
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x8.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x8 is marked as alive


    // renamable $x8 = CASX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store monotonic monotonic (s64) on %ir.0)
    {
    if (1) {
        // operand 1(x8) is the same as its tied destination
        assert(scratch_x8.cur_reg.valid());
        AsmReg op2 = param_2.as_reg(this);
        AsmReg op3 = param_0.as_reg(this);
        ASMD(CASx, scratch_x8.cur_reg, op2, op3);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSxi, DA_ZR, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SUBSx_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();


    // $x0 = ORRXrs $xzr, killed $x8, 0
    {
    if (1) {
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, DA_ZR, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_acquire_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_acquire_monotonic: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $x0, $x1, $x2
    //   $x8 = ORRXrs $xzr, $x1, 0
    //   renamable $x8 = CASAX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store acquire monotonic (s64) on %ir.0)
    //   $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    //   $x0 = ORRXrs $xzr, killed $x8, 0
    //   renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function cmpxchg_u64_acquire_monotonic.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // $x8 = ORRXrs $xzr, $x1, 0
    {
    if (1) {
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x8.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x8 is marked as alive


    // renamable $x8 = CASAX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store acquire monotonic (s64) on %ir.0)
    {
    if (1) {
        // operand 1(x8) is the same as its tied destination
        assert(scratch_x8.cur_reg.valid());
        AsmReg op2 = param_2.as_reg(this);
        AsmReg op3 = param_0.as_reg(this);
        ASMD(CASAx, scratch_x8.cur_reg, op2, op3);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSxi, DA_ZR, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SUBSx_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();


    // $x0 = ORRXrs $xzr, killed $x8, 0
    {
    if (1) {
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, DA_ZR, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_acquire_acquire(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_acquire_acquire: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $x0, $x1, $x2
    //   $x8 = ORRXrs $xzr, $x1, 0
    //   renamable $x8 = CASAX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store acquire acquire (s64) on %ir.0)
    //   $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    //   $x0 = ORRXrs $xzr, killed $x8, 0
    //   renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function cmpxchg_u64_acquire_acquire.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // $x8 = ORRXrs $xzr, $x1, 0
    {
    if (1) {
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x8.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x8 is marked as alive


    // renamable $x8 = CASAX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store acquire acquire (s64) on %ir.0)
    {
    if (1) {
        // operand 1(x8) is the same as its tied destination
        assert(scratch_x8.cur_reg.valid());
        AsmReg op2 = param_2.as_reg(this);
        AsmReg op3 = param_0.as_reg(this);
        ASMD(CASAx, scratch_x8.cur_reg, op2, op3);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSxi, DA_ZR, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SUBSx_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();


    // $x0 = ORRXrs $xzr, killed $x8, 0
    {
    if (1) {
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, DA_ZR, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_release_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_release_monotonic: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $x0, $x1, $x2
    //   $x8 = ORRXrs $xzr, $x1, 0
    //   renamable $x8 = CASLX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store release monotonic (s64) on %ir.0)
    //   $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    //   $x0 = ORRXrs $xzr, killed $x8, 0
    //   renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function cmpxchg_u64_release_monotonic.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // $x8 = ORRXrs $xzr, $x1, 0
    {
    if (1) {
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x8.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x8 is marked as alive


    // renamable $x8 = CASLX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store release monotonic (s64) on %ir.0)
    {
    if (1) {
        // operand 1(x8) is the same as its tied destination
        assert(scratch_x8.cur_reg.valid());
        AsmReg op2 = param_2.as_reg(this);
        AsmReg op3 = param_0.as_reg(this);
        ASMD(CASLx, scratch_x8.cur_reg, op2, op3);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSxi, DA_ZR, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SUBSx_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();


    // $x0 = ORRXrs $xzr, killed $x8, 0
    {
    if (1) {
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, DA_ZR, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_release_acquire(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_release_acquire: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $x0, $x1, $x2
    //   $x8 = ORRXrs $xzr, $x1, 0
    //   renamable $x8 = CASALX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store release acquire (s64) on %ir.0)
    //   $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    //   $x0 = ORRXrs $xzr, killed $x8, 0
    //   renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function cmpxchg_u64_release_acquire.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // $x8 = ORRXrs $xzr, $x1, 0
    {
    if (1) {
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x8.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x8 is marked as alive


    // renamable $x8 = CASALX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store release acquire (s64) on %ir.0)
    {
    if (1) {
        // operand 1(x8) is the same as its tied destination
        assert(scratch_x8.cur_reg.valid());
        AsmReg op2 = param_2.as_reg(this);
        AsmReg op3 = param_0.as_reg(this);
        ASMD(CASALx, scratch_x8.cur_reg, op2, op3);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSxi, DA_ZR, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SUBSx_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();


    // $x0 = ORRXrs $xzr, killed $x8, 0
    {
    if (1) {
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, DA_ZR, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_acqrel_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_acqrel_monotonic: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $x0, $x1, $x2
    //   $x8 = ORRXrs $xzr, $x1, 0
    //   renamable $x8 = CASALX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store acq_rel monotonic (s64) on %ir.0)
    //   $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    //   $x0 = ORRXrs $xzr, killed $x8, 0
    //   renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function cmpxchg_u64_acqrel_monotonic.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // $x8 = ORRXrs $xzr, $x1, 0
    {
    if (1) {
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x8.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x8 is marked as alive


    // renamable $x8 = CASALX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store acq_rel monotonic (s64) on %ir.0)
    {
    if (1) {
        // operand 1(x8) is the same as its tied destination
        assert(scratch_x8.cur_reg.valid());
        AsmReg op2 = param_2.as_reg(this);
        AsmReg op3 = param_0.as_reg(this);
        ASMD(CASALx, scratch_x8.cur_reg, op2, op3);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSxi, DA_ZR, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SUBSx_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();


    // $x0 = ORRXrs $xzr, killed $x8, 0
    {
    if (1) {
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, DA_ZR, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_acqrel_acquire(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_acqrel_acquire: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $x0, $x1, $x2
    //   $x8 = ORRXrs $xzr, $x1, 0
    //   renamable $x8 = CASALX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store acq_rel acquire (s64) on %ir.0)
    //   $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    //   $x0 = ORRXrs $xzr, killed $x8, 0
    //   renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function cmpxchg_u64_acqrel_acquire.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // $x8 = ORRXrs $xzr, $x1, 0
    {
    if (1) {
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x8.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x8 is marked as alive


    // renamable $x8 = CASALX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store acq_rel acquire (s64) on %ir.0)
    {
    if (1) {
        // operand 1(x8) is the same as its tied destination
        assert(scratch_x8.cur_reg.valid());
        AsmReg op2 = param_2.as_reg(this);
        AsmReg op3 = param_0.as_reg(this);
        ASMD(CASALx, scratch_x8.cur_reg, op2, op3);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSxi, DA_ZR, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SUBSx_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();


    // $x0 = ORRXrs $xzr, killed $x8, 0
    {
    if (1) {
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, DA_ZR, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_seqcst_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_seqcst_monotonic: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $x0, $x1, $x2
    //   $x8 = ORRXrs $xzr, $x1, 0
    //   renamable $x8 = CASALX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store seq_cst monotonic (s64) on %ir.0)
    //   $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    //   $x0 = ORRXrs $xzr, killed $x8, 0
    //   renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function cmpxchg_u64_seqcst_monotonic.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // $x8 = ORRXrs $xzr, $x1, 0
    {
    if (1) {
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x8.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x8 is marked as alive


    // renamable $x8 = CASALX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store seq_cst monotonic (s64) on %ir.0)
    {
    if (1) {
        // operand 1(x8) is the same as its tied destination
        assert(scratch_x8.cur_reg.valid());
        AsmReg op2 = param_2.as_reg(this);
        AsmReg op3 = param_0.as_reg(this);
        ASMD(CASALx, scratch_x8.cur_reg, op2, op3);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSxi, DA_ZR, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SUBSx_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();


    // $x0 = ORRXrs $xzr, killed $x8, 0
    {
    if (1) {
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, DA_ZR, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_seqcst_acquire(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_seqcst_acquire: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $x0, $x1, $x2
    //   $x8 = ORRXrs $xzr, $x1, 0
    //   renamable $x8 = CASALX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store seq_cst acquire (s64) on %ir.0)
    //   $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    //   $x0 = ORRXrs $xzr, killed $x8, 0
    //   renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function cmpxchg_u64_seqcst_acquire.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // $x8 = ORRXrs $xzr, $x1, 0
    {
    if (1) {
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x8.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x8 is marked as alive


    // renamable $x8 = CASALX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store seq_cst acquire (s64) on %ir.0)
    {
    if (1) {
        // operand 1(x8) is the same as its tied destination
        assert(scratch_x8.cur_reg.valid());
        AsmReg op2 = param_2.as_reg(this);
        AsmReg op3 = param_0.as_reg(this);
        ASMD(CASALx, scratch_x8.cur_reg, op2, op3);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSxi, DA_ZR, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SUBSx_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();


    // $x0 = ORRXrs $xzr, killed $x8, 0
    {
    if (1) {
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, DA_ZR, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_seqcst_seqcst(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_seqcst_seqcst: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0, $x1, $x2
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $x0, $x1, $x2
    //   $x8 = ORRXrs $xzr, $x1, 0
    //   renamable $x8 = CASALX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store seq_cst seq_cst (s64) on %ir.0)
    //   $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    //   $x0 = ORRXrs $xzr, killed $x8, 0
    //   renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function cmpxchg_u64_seqcst_seqcst.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x8{derived()};


    // $x8 = ORRXrs $xzr, $x1, 0
    {
    if (1) {
        AsmReg op2 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x8.cur_reg, DA_ZR, op2, 0);
    }
    }
    // result x8 is marked as alive


    // renamable $x8 = CASALX killed renamable $x8(tied-def 0), killed renamable $x2, killed renamable $x0 :: (load store seq_cst seq_cst (s64) on %ir.0)
    {
    if (1) {
        // operand 1(x8) is the same as its tied destination
        assert(scratch_x8.cur_reg.valid());
        AsmReg op2 = param_2.as_reg(this);
        AsmReg op3 = param_0.as_reg(this);
        ASMD(CASALx, scratch_x8.cur_reg, op2, op3);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x8 is marked as alive


    // $xzr = SUBSXrs renamable $x8, killed renamable $x1, 0, implicit-def $nzcv
    do {
    {
    auto cond0 = param_1.encodeable_as_immarith();
    if (cond0) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSxi, DA_ZR, op1, (*cond0));        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SUBSx_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x1 is killed and marked as dead
    param_1.reset();


    // $x0 = ORRXrs $xzr, killed $x8, 0
    {
    if (1) {
        AsmReg op2 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRx_lsl, scratch_x0.cur_reg, DA_ZR, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // renamable $w1 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv, implicit-def $x1
    {
    if (1) {
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x1.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x1 is marked as alive
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u8_mono(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u8_mono: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $w0 = LDRBBui killed renamable $x0, 0 :: (load monotonic (s8) from %ir.0)
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function atomic_load_u8_mono.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = LDRBBui killed renamable $x0, 0 :: (load monotonic (s8) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 0);
    if (cond0) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDRBu, scratch_x0.cur_reg, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDRBu, scratch_x0.cur_reg, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u16_mono(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u16_mono: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $w0 = LDRHHui killed renamable $x0, 0 :: (load monotonic (s16) from %ir.0)
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function atomic_load_u16_mono.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = LDRHHui killed renamable $x0, 0 :: (load monotonic (s16) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 1);
    if (cond0) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDRHu, scratch_x0.cur_reg, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDRHu, scratch_x0.cur_reg, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u32_mono(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u32_mono: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $w0 = LDRWui killed renamable $x0, 0 :: (load monotonic (s32) from %ir.0)
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function atomic_load_u32_mono.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = LDRWui killed renamable $x0, 0 :: (load monotonic (s32) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 2);
    if (cond0) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDRwu, scratch_x0.cur_reg, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDRwu, scratch_x0.cur_reg, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u64_mono(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u64_mono: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $x0 = LDRXui killed renamable $x0, 0 :: (load monotonic (s64) from %ir.0)
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function atomic_load_u64_mono.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $x0 = LDRXui killed renamable $x0, 0 :: (load monotonic (s64) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 3);
    if (cond0) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDRxu, scratch_x0.cur_reg, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDRxu, scratch_x0.cur_reg, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u8_acq(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u8_acq: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $w0 = LDARB killed renamable $x0 :: (load acquire (s8) from %ir.0)
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function atomic_load_u8_acq.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = LDARB killed renamable $x0 :: (load acquire (s8) from %ir.0)
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDARB, scratch_x0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u16_acq(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u16_acq: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $w0 = LDARH killed renamable $x0 :: (load acquire (s16) from %ir.0)
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function atomic_load_u16_acq.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = LDARH killed renamable $x0 :: (load acquire (s16) from %ir.0)
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDARH, scratch_x0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u32_acq(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u32_acq: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $w0 = LDARW killed renamable $x0 :: (load acquire (s32) from %ir.0)
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function atomic_load_u32_acq.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = LDARW killed renamable $x0 :: (load acquire (s32) from %ir.0)
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDARw, scratch_x0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u64_acq(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u64_acq: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $x0 = LDARX killed renamable $x0 :: (load acquire (s64) from %ir.0)
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function atomic_load_u64_acq.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $x0 = LDARX killed renamable $x0 :: (load acquire (s64) from %ir.0)
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDARx, scratch_x0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u8_seqcst(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u8_seqcst: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $w0 = LDARB killed renamable $x0 :: (load seq_cst (s8) from %ir.0)
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function atomic_load_u8_seqcst.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = LDARB killed renamable $x0 :: (load seq_cst (s8) from %ir.0)
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDARB, scratch_x0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u16_seqcst(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u16_seqcst: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $w0 = LDARH killed renamable $x0 :: (load seq_cst (s16) from %ir.0)
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function atomic_load_u16_seqcst.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = LDARH killed renamable $x0 :: (load seq_cst (s16) from %ir.0)
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDARH, scratch_x0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u32_seqcst(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u32_seqcst: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $w0 = LDARW killed renamable $x0 :: (load seq_cst (s32) from %ir.0)
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function atomic_load_u32_seqcst.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $w0 = LDARW killed renamable $x0 :: (load seq_cst (s32) from %ir.0)
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDARw, scratch_x0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u64_seqcst(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u64_seqcst: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   renamable $x0 = LDARX killed renamable $x0 :: (load seq_cst (s64) from %ir.0)
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function atomic_load_u64_seqcst.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // renamable $x0 = LDARX killed renamable $x0 :: (load seq_cst (s64) from %ir.0)
    {
    if (1) {
        AsmReg op1 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(LDARx, scratch_x0.cur_reg, op1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_select_i32(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0) {
    // # Machine code for function select_i32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $w1, $w2
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $w0, $w1, $w2
    //   $wzr = ANDSWri killed renamable $w0, 0, implicit-def $nzcv
    //   renamable $w0 = CSELWr killed renamable $w2, killed renamable $w1, 0, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function select_i32.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};


    // $wzr = ANDSWri killed renamable $w0, 0, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(ANDSwi, DA_ZR, op1, 0x1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();


    // renamable $w0 = CSELWr killed renamable $w2, killed renamable $w1, 0, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = param_2.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSELw, scratch_x0.cur_reg, op1, op2, DA_EQ);
    }
    }
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_select_i64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0) {
    // # Machine code for function select_i64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $x1, $x2
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $w0, $x1, $x2
    //   $wzr = ANDSWri killed renamable $w0, 0, implicit-def $nzcv
    //   renamable $x0 = CSELXr killed renamable $x2, killed renamable $x1, 0, implicit killed $nzcv
    //   RET undef $lr, implicit killed $x0
    // 
    // # End machine code for function select_i64.
    // 

    // Mapping x0 to param_0
    // Mapping x1 to param_1
    // Mapping x2 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x1{derived()};


    // $wzr = ANDSWri killed renamable $w0, 0, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(ANDSwi, DA_ZR, op1, 0x1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();


    // renamable $x0 = CSELXr killed renamable $x2, killed renamable $x1, 0, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = param_2.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSELx, scratch_x0.cur_reg, op1, op2, DA_EQ);
    }
    }
    // argument x2 is killed and marked as dead
    param_2.reset();
    // argument x1 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $x0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_select_i128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, AsmOperand param_4, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function select_i128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $x2, $x3, $x4, $x5
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $w0, $x2, $x3, $x4, $x5
    //   $wzr = ANDSWri killed renamable $w0, 0, implicit-def $nzcv
    //   renamable $x0 = CSELXr killed renamable $x4, killed renamable $x2, 0, implicit $nzcv
    //   renamable $x1 = CSELXr killed renamable $x5, killed renamable $x3, 0, implicit killed $nzcv
    //   RET undef $lr, implicit killed $x0, implicit killed $x1
    // 
    // # End machine code for function select_i128.
    // 

    // Mapping x0 to param_0
    // Mapping x2 to param_1
    // Mapping x3 to param_2
    // Mapping x4 to param_3
    // Mapping x5 to param_4
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x2{derived()};
    ScratchReg scratch_x4{derived()};
    ScratchReg scratch_x1{derived()};
    ScratchReg scratch_x3{derived()};
    ScratchReg scratch_x5{derived()};


    // $wzr = ANDSWri killed renamable $w0, 0, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(ANDSwi, DA_ZR, op1, 0x1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();


    // renamable $x0 = CSELXr killed renamable $x4, killed renamable $x2, 0, implicit $nzcv
    {
    if (1) {
        AsmReg op1 = param_3.as_reg_try_salvage(this, scratch_x0, 0);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSELx, scratch_x0.cur_reg, op1, op2, DA_EQ);
    }
    }
    // argument x4 is killed and marked as dead
    param_3.reset();
    // argument x2 is killed and marked as dead
    param_1.reset();
    // result x0 is marked as alive


    // renamable $x1 = CSELXr killed renamable $x5, killed renamable $x3, 0, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = param_4.as_reg_try_salvage(this, scratch_x1, 0);
        AsmReg op2 = param_2.as_reg_try_salvage(this, scratch_x1, 0);
        // def x1 has not been allocated yet
        scratch_x1.alloc_from_bank(0);
        ASMD(CSELx, scratch_x1.cur_reg, op1, op2, DA_EQ);
    }
    }
    // argument x5 is killed and marked as dead
    param_4.reset();
    // argument x3 is killed and marked as dead
    param_2.reset();
    // result x1 is marked as alive


    // RET undef $lr, implicit killed $x0, implicit killed $x1
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    // returning reg x1 as result_1
    result_1 = std::move(scratch_x1);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_select_f32(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0) {
    // # Machine code for function select_f32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $s0, $s1
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $s0, $s1, $w0
    //   $wzr = ANDSWri killed renamable $w0, 0, implicit-def $nzcv
    //   renamable $s0 = FCSELSrrr killed renamable $s1, killed renamable $s0, 0, implicit killed $nzcv
    //   RET undef $lr, implicit killed $s0
    // 
    // # End machine code for function select_f32.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    // Mapping v1 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // $wzr = ANDSWri killed renamable $w0, 0, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(ANDSwi, DA_ZR, op1, 0x1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();


    // renamable $s0 = FCSELSrrr killed renamable $s1, killed renamable $s0, 0, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = param_2.as_reg_try_salvage(this, scratch_v0, 1);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FCSELs, scratch_v0.cur_reg, op1, op2, DA_EQ);
    }
    }
    // argument v1 is killed and marked as dead
    param_2.reset();
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $s0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_select_f64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0) {
    // # Machine code for function select_f64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $d0, $d1
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $d0, $d1, $w0
    //   $wzr = ANDSWri killed renamable $w0, 0, implicit-def $nzcv
    //   renamable $d0 = FCSELDrrr killed renamable $d1, killed renamable $d0, 0, implicit killed $nzcv
    //   RET undef $lr, implicit killed $d0
    // 
    // # End machine code for function select_f64.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    // Mapping v1 to param_2
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // $wzr = ANDSWri killed renamable $w0, 0, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(ANDSwi, DA_ZR, op1, 0x1);
    }
    }
    // argument x0 is killed and marked as dead
    param_0.reset();


    // renamable $d0 = FCSELDrrr killed renamable $d1, killed renamable $d0, 0, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = param_2.as_reg_try_salvage(this, scratch_v0, 1);
        AsmReg op2 = param_1.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FCSELd, scratch_v0.cur_reg, op1, op2, DA_EQ);
    }
    }
    // argument v1 is killed and marked as dead
    param_2.reset();
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result v0 is marked as alive


    // RET undef $lr, implicit killed $d0
    // returning reg v0 as result_0
    result_0 = std::move(scratch_v0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_oeq_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_oeq_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_oeq_float.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ogt_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ogt_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 13, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_ogt_float.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 13, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_LE);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_oge_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_oge_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 11, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_oge_float.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 11, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_LT);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_olt_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_olt_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 5, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_olt_float.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 5, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_PL);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ole_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ole_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 8, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_ole_float.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 8, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_HI);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_one_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_one_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w8 = CSINCWr $wzr, $wzr, 5, implicit $nzcv
    //   renamable $w0 = CSINCWr killed renamable $w8, $wzr, 13, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_one_float.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w8 = CSINCWr $wzr, $wzr, 5, implicit $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_PL);
    }
    }
    // result x8 is marked as alive


    // renamable $w0 = CSINCWr killed renamable $w8, $wzr, 13, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, op1, DA_ZR, DA_LE);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ord_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ord_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 6, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_ord_float.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 6, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_VS);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ueq_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ueq_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit $nzcv
    //   renamable $w0 = CSINCWr killed renamable $w8, $wzr, 7, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_ueq_float.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x8 is marked as alive


    // renamable $w0 = CSINCWr killed renamable $w8, $wzr, 7, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, op1, DA_ZR, DA_VC);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ugt_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ugt_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 9, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_ugt_float.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 9, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_LS);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_uge_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_uge_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 4, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_uge_float.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 4, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_MI);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ult_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ult_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 10, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_ult_float.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 10, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_GE);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ule_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ule_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 12, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_ule_float.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 12, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_GT);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_une_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_une_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_une_float.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_EQ);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_uno_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_uno_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $s0, $s1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $s1
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 7, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_uno_float.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 7, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_VC);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_oeq_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_oeq_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_oeq_double.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ogt_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ogt_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 13, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_ogt_double.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 13, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_LE);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_oge_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_oge_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 11, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_oge_double.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 11, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_LT);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_olt_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_olt_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 5, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_olt_double.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 5, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_PL);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ole_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ole_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 8, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_ole_double.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 8, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_HI);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_one_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_one_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w8 = CSINCWr $wzr, $wzr, 5, implicit $nzcv
    //   renamable $w0 = CSINCWr killed renamable $w8, $wzr, 13, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_one_double.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w8 = CSINCWr $wzr, $wzr, 5, implicit $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_PL);
    }
    }
    // result x8 is marked as alive


    // renamable $w0 = CSINCWr killed renamable $w8, $wzr, 13, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, op1, DA_ZR, DA_LE);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ord_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ord_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 6, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_ord_double.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 6, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_VS);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ueq_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ueq_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit $nzcv
    //   renamable $w0 = CSINCWr killed renamable $w8, $wzr, 7, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_ueq_double.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x8 is marked as alive


    // renamable $w0 = CSINCWr killed renamable $w8, $wzr, 7, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, op1, DA_ZR, DA_VC);
    }
    }
    // argument x8 is killed and marked as dead
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ugt_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ugt_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 9, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_ugt_double.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 9, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_LS);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_uge_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_uge_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 4, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_uge_double.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 4, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_MI);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ult_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ult_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 10, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_ult_double.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 10, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_GE);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ule_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ule_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 12, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_ule_double.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 12, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_GT);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_une_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_une_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_une_double.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 0, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_EQ);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_uno_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_uno_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $d0, $d1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $d1
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w0 = CSINCWr $wzr, $wzr, 7, implicit killed $nzcv
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function fcmp_uno_double.
    // 

    // Mapping v0 to param_0
    // Mapping v1 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_0.reset();
    // argument v1 is killed and marked as dead
    param_1.reset();


    // renamable $w0 = CSINCWr $wzr, $wzr, 7, implicit killed $nzcv
    {
    if (1) {
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x0.cur_reg, DA_ZR, DA_ZR, DA_VC);
    }
    }
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_snan_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_snan_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $s0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $w0
    //   $w9 = FMOVSWr killed $s0
    //   renamable $w8 = MOVZWi 32640, 16
    //   renamable $w9 = ANDWri killed renamable $w9, 30
    //   $wzr = SUBSWrs renamable $w9, killed renamable $w8, 0, implicit-def $nzcv
    //   renamable $w8 = MOVZWi 32704, 16
    //   CCMPWr killed renamable $w9, killed renamable $w8, 0, 12, implicit-def $nzcv, implicit killed $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 10, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_snan_float.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // $w9 = FMOVSWr killed $s0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(FMOVsw, scratch_x9.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x9 is marked as alive


    // renamable $w8 = MOVZWi 32640, 16
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZw_shift, scratch_x8.cur_reg, 0x7f80, 1);
    }
    }
    // result x8 is marked as alive


    // renamable $w9 = ANDWri killed renamable $w9, 30
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x9.cur_reg, op1, 0x7fffffff);
    }
    }
    // argument x9 is killed and marked as dead
    // result x9 is marked as alive


    // $wzr = SUBSWrs renamable $w9, killed renamable $w8, 0, implicit-def $nzcv
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        ASMD(SUBSw_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x8 is killed and marked as dead


    // renamable $w8 = MOVZWi 32704, 16
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZw_shift, scratch_x8.cur_reg, 0x7fc0, 1);
    }
    }
    // result x8 is marked as alive


    // CCMPWr killed renamable $w9, killed renamable $w8, 0, 12, implicit-def $nzcv, implicit killed $nzcv
    {
    if (1) {
        AsmReg op0 = scratch_x9.cur_reg;
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(CCMPw, op0, op1, DA_EQ, DA_GT);
    }
    }
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 10, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_GE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_qnan_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_qnan_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $s0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $w0
    //   $w9 = FMOVSWr killed $s0
    //   renamable $w8 = MOVNWi 32832, 16
    //   renamable $w9 = ANDWri killed renamable $w9, 30
    //   $wzr = SUBSWrs killed renamable $w9, killed renamable $w8, 0, implicit-def $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 13, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_qnan_float.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // $w9 = FMOVSWr killed $s0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(FMOVsw, scratch_x9.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x9 is marked as alive


    // renamable $w8 = MOVNWi 32832, 16
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVNw_shift, scratch_x8.cur_reg, 0x8040, 1);
    }
    }
    // result x8 is marked as alive


    // renamable $w9 = ANDWri killed renamable $w9, 30
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x9.cur_reg, op1, 0x7fffffff);
    }
    }
    // argument x9 is killed and marked as dead
    // result x9 is marked as alive


    // $wzr = SUBSWrs killed renamable $w9, killed renamable $w8, 0, implicit-def $nzcv
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        ASMD(SUBSw_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 13, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_LE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_ninf_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_ninf_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $s0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $w0
    //   renamable $w8 = MOVZWi 65408, 16
    //   $s1 = FMOVWSr killed $w8
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_ninf_float.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = MOVZWi 65408, 16
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZw_shift, scratch_x8.cur_reg, 0xff80, 1);
    }
    }
    // result x8 is marked as alive


    // $s1 = FMOVWSr killed $w8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def v1 has not been allocated yet
        scratch_v1.alloc_from_bank(1);
        ASMD(FMOVws, scratch_v1.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result v1 is marked as alive


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = scratch_v1.cur_reg;
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // argument v1 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_nnorm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_nnorm_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $s0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $w0
    //   $w8 = FMOVSWr killed $s0
    //   renamable $w9 = ANDWri renamable $w8, 30
    //   renamable $w9 = SUBWri killed renamable $w9, 2048, 12
    //   renamable $w9 = UBFMWri killed renamable $w9, 24, 31
    //   $wzr = SUBSWri killed renamable $w9, 127, 0, implicit-def $nzcv
    //   CCMPWi killed renamable $w8, 0, 0, 3, implicit-def $nzcv, implicit killed $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 10, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_nnorm_float.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // $w8 = FMOVSWr killed $s0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(FMOVsw, scratch_x8.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive


    // renamable $w9 = ANDWri renamable $w8, 30
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x9.cur_reg, op1, 0x7fffffff);
    }
    }
    // result x9 is marked as alive


    // renamable $w9 = SUBWri killed renamable $w9, 2048, 12
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(SUBwi, scratch_x9.cur_reg, op1, 8388608);
    }
    }
    // argument x9 is killed and marked as dead
    // result x9 is marked as alive


    // renamable $w9 = UBFMWri killed renamable $w9, 24, 31
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(UBFMw, scratch_x9.cur_reg, op1, 0x18, 0x1f);
    }
    }
    // argument x9 is killed and marked as dead
    // result x9 is marked as alive


    // $wzr = SUBSWri killed renamable $w9, 127, 0, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        ASMD(SUBSwi, DA_ZR, op1, 127);
    }
    }
    // argument x9 is killed and marked as dead


    // CCMPWi killed renamable $w8, 0, 0, 3, implicit-def $nzcv, implicit killed $nzcv
    {
    if (1) {
        AsmReg op0 = scratch_x8.cur_reg;
        ASMD(CCMPwi, op0, DA_EQ, DA_EQ, DA_LO);
    }
    }
    // argument x8 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 10, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_GE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_nsnorm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_nsnorm_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $s0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $w0
    //   $w9 = FMOVSWr killed $s0
    //   renamable $w8 = MOVNWi 65408, 16
    //   renamable $w10 = ANDWri renamable $w9, 30
    //   renamable $w10 = SUBWri killed renamable $w10, 1, 0
    //   $wzr = SUBSWrs killed renamable $w10, killed renamable $w8, 0, implicit-def $nzcv
    //   CCMPWi killed renamable $w9, 0, 0, 3, implicit-def $nzcv, implicit killed $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 10, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_nsnorm_float.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};
    ScratchReg scratch_x10{derived()};


    // $w9 = FMOVSWr killed $s0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(FMOVsw, scratch_x9.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x9 is marked as alive


    // renamable $w8 = MOVNWi 65408, 16
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVNw_shift, scratch_x8.cur_reg, 0xff80, 1);
    }
    }
    // result x8 is marked as alive


    // renamable $w10 = ANDWri renamable $w9, 30
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x10.cur_reg, op1, 0x7fffffff);
    }
    }
    // result x10 is marked as alive


    // renamable $w10 = SUBWri killed renamable $w10, 1, 0
    {
    if (1) {
        AsmReg op1 = scratch_x10.cur_reg;
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(SUBwi, scratch_x10.cur_reg, op1, 1);
    }
    }
    // argument x10 is killed and marked as dead
    // result x10 is marked as alive


    // $wzr = SUBSWrs killed renamable $w10, killed renamable $w8, 0, implicit-def $nzcv
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x10.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        ASMD(SUBSw_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x10 is killed and marked as dead
    // argument x8 is killed and marked as dead


    // CCMPWi killed renamable $w9, 0, 0, 3, implicit-def $nzcv, implicit killed $nzcv
    {
    if (1) {
        AsmReg op0 = scratch_x9.cur_reg;
        ASMD(CCMPwi, op0, DA_EQ, DA_EQ, DA_LO);
    }
    }
    // argument x9 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 10, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_GE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_nzero_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_nzero_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $s0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $w0
    //   $w9 = FMOVSWr killed $s0
    //   renamable $w8 = MOVZWi 32768, 16
    //   $wzr = SUBSWrs killed renamable $w9, killed renamable $w8, 0, implicit-def $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_nzero_float.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // $w9 = FMOVSWr killed $s0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(FMOVsw, scratch_x9.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x9 is marked as alive


    // renamable $w8 = MOVZWi 32768, 16
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZw_shift, scratch_x8.cur_reg, 0x8000, 1);
    }
    }
    // result x8 is marked as alive


    // $wzr = SUBSWrs killed renamable $w9, killed renamable $w8, 0, implicit-def $nzcv
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        ASMD(SUBSw_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_pzero_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_pzero_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $s0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $w0
    //   $w8 = FMOVSWr killed $s0
    //   $wzr = SUBSWri killed renamable $w8, 0, 0, implicit-def $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_pzero_float.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // $w8 = FMOVSWr killed $s0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(FMOVsw, scratch_x8.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive


    // $wzr = SUBSWri killed renamable $w8, 0, 0, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSwi, DA_ZR, op1, 0);
    }
    }
    // argument x8 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_psnorm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_psnorm_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $s0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $w0
    //   $w9 = FMOVSWr killed $s0
    //   renamable $w8 = MOVNWi 65408, 16
    //   renamable $w9 = SUBWri killed renamable $w9, 1, 0
    //   $wzr = SUBSWrs killed renamable $w9, killed renamable $w8, 0, implicit-def $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 2, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_psnorm_float.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // $w9 = FMOVSWr killed $s0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(FMOVsw, scratch_x9.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x9 is marked as alive


    // renamable $w8 = MOVNWi 65408, 16
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVNw_shift, scratch_x8.cur_reg, 0xff80, 1);
    }
    }
    // result x8 is marked as alive


    // renamable $w9 = SUBWri killed renamable $w9, 1, 0
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(SUBwi, scratch_x9.cur_reg, op1, 1);
    }
    }
    // argument x9 is killed and marked as dead
    // result x9 is marked as alive


    // $wzr = SUBSWrs killed renamable $w9, killed renamable $w8, 0, implicit-def $nzcv
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        ASMD(SUBSw_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 2, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_HS);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_pnorm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_pnorm_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $s0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $w0
    //   $w8 = FMOVSWr killed $s0
    //   renamable $w9 = ANDWri renamable $w8, 30
    //   renamable $w9 = SUBWri killed renamable $w9, 2048, 12
    //   renamable $w9 = UBFMWri killed renamable $w9, 24, 31
    //   $wzr = SUBSWri killed renamable $w9, 127, 0, implicit-def $nzcv
    //   CCMPWi killed renamable $w8, 0, 8, 3, implicit-def $nzcv, implicit killed $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 11, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_pnorm_float.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // $w8 = FMOVSWr killed $s0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(FMOVsw, scratch_x8.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive


    // renamable $w9 = ANDWri renamable $w8, 30
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x9.cur_reg, op1, 0x7fffffff);
    }
    }
    // result x9 is marked as alive


    // renamable $w9 = SUBWri killed renamable $w9, 2048, 12
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(SUBwi, scratch_x9.cur_reg, op1, 8388608);
    }
    }
    // argument x9 is killed and marked as dead
    // result x9 is marked as alive


    // renamable $w9 = UBFMWri killed renamable $w9, 24, 31
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(UBFMw, scratch_x9.cur_reg, op1, 0x18, 0x1f);
    }
    }
    // argument x9 is killed and marked as dead
    // result x9 is marked as alive


    // $wzr = SUBSWri killed renamable $w9, 127, 0, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        ASMD(SUBSwi, DA_ZR, op1, 127);
    }
    }
    // argument x9 is killed and marked as dead


    // CCMPWi killed renamable $w8, 0, 8, 3, implicit-def $nzcv, implicit killed $nzcv
    {
    if (1) {
        AsmReg op0 = scratch_x8.cur_reg;
        ASMD(CCMPwi, op0, DA_EQ, DA_HI, DA_LO);
    }
    }
    // argument x8 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 11, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_LT);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_pinf_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_pinf_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $s0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $w0
    //   renamable $w8 = MOVZWi 32640, 16
    //   $s1 = FMOVWSr killed $w8
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_pinf_float.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $w8 = MOVZWi 32640, 16
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZw_shift, scratch_x8.cur_reg, 0x7f80, 1);
    }
    }
    // result x8 is marked as alive


    // $s1 = FMOVWSr killed $w8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def v1 has not been allocated yet
        scratch_v1.alloc_from_bank(1);
        ASMD(FMOVws, scratch_v1.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result v1 is marked as alive


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = scratch_v1.cur_reg;
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // argument v1 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_nan_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_nan_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $s0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $w0
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s0, implicit-def $nzcv, implicit $fpcr
    //   renamable $w8 = CSINCWr $wzr, $wzr, 7, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_nan_float.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s0, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(FCMP_s, op0, op0);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // argument v0 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 7, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_VC);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_inf_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_inf_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $s0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $w0
    //   renamable $s0 = FABSSr killed renamable $s0
    //   renamable $w8 = MOVZWi 32640, 16
    //   $s1 = FMOVWSr killed $w8
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_inf_float.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $s0 = FABSSr killed renamable $s0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FABSs, scratch_v0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result v0 is marked as alive


    // renamable $w8 = MOVZWi 32640, 16
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZw_shift, scratch_x8.cur_reg, 0x7f80, 1);
    }
    }
    // result x8 is marked as alive


    // $s1 = FMOVWSr killed $w8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def v1 has not been allocated yet
        scratch_v1.alloc_from_bank(1);
        ASMD(FMOVws, scratch_v1.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result v1 is marked as alive


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = scratch_v0.cur_reg;
        AsmReg op1 = scratch_v1.cur_reg;
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    // argument v1 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_norm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_norm_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $s0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $w0
    //   $w8 = FMOVSWr killed $s0
    //   renamable $w8 = ANDWri killed renamable $w8, 30
    //   renamable $w8 = SUBWri killed renamable $w8, 2048, 12
    //   renamable $w8 = UBFMWri killed renamable $w8, 24, 31
    //   $wzr = SUBSWri killed renamable $w8, 127, 0, implicit-def $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 2, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_norm_float.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // $w8 = FMOVSWr killed $s0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(FMOVsw, scratch_x8.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive


    // renamable $w8 = ANDWri killed renamable $w8, 30
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ANDwi, scratch_x8.cur_reg, op1, 0x7fffffff);
    }
    }
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // renamable $w8 = SUBWri killed renamable $w8, 2048, 12
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(SUBwi, scratch_x8.cur_reg, op1, 8388608);
    }
    }
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // renamable $w8 = UBFMWri killed renamable $w8, 24, 31
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UBFMw, scratch_x8.cur_reg, op1, 0x18, 0x1f);
    }
    }
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // $wzr = SUBSWri killed renamable $w8, 127, 0, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSwi, DA_ZR, op1, 127);
    }
    }
    // argument x8 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 2, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_HS);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_finite_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_finite_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $s0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $s0, $w0
    //   renamable $s0 = FABSSr killed renamable $s0
    //   renamable $w8 = MOVZWi 32640, 16
    //   $s1 = FMOVWSr killed $w8
    //   nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w8 = CSINCWr $wzr, $wzr, 5, implicit $nzcv
    //   renamable $w8 = CSINCWr killed renamable $w8, $wzr, 13, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_finite_float.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $s0 = FABSSr killed renamable $s0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FABSs, scratch_v0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result v0 is marked as alive


    // renamable $w8 = MOVZWi 32640, 16
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZw_shift, scratch_x8.cur_reg, 0x7f80, 1);
    }
    }
    // result x8 is marked as alive


    // $s1 = FMOVWSr killed $w8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def v1 has not been allocated yet
        scratch_v1.alloc_from_bank(1);
        ASMD(FMOVws, scratch_v1.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result v1 is marked as alive


    // nofpexcept FCMPSrr killed renamable $s0, killed renamable $s1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = scratch_v0.cur_reg;
        AsmReg op1 = scratch_v1.cur_reg;
        ASMD(FCMP_s, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    // argument v1 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 5, implicit $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_PL);
    }
    }
    // result x8 is marked as alive


    // renamable $w8 = CSINCWr killed renamable $w8, $wzr, 13, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, op1, DA_ZR, DA_LE);
    }
    }
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_snan_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_snan_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $d0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $w0
    //   $x9 = FMOVDXr killed $d0
    //   renamable $x8 = MOVZXi 32752, 48
    //   renamable $x9 = ANDXri killed renamable $x9, 4158
    //   $xzr = SUBSXrs renamable $x9, killed renamable $x8, 0, implicit-def $nzcv
    //   renamable $x8 = MOVZXi 32760, 48
    //   CCMPXr killed renamable $x9, killed renamable $x8, 0, 12, implicit-def $nzcv, implicit killed $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 10, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_snan_double.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // $x9 = FMOVDXr killed $d0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(FMOVdx, scratch_x9.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x9 is marked as alive


    // renamable $x8 = MOVZXi 32752, 48
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZx_shift, scratch_x8.cur_reg, 0x7ff0, 3);
    }
    }
    // result x8 is marked as alive


    // renamable $x9 = ANDXri killed renamable $x9, 4158
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x9.cur_reg, op1, 0x7fffffffffffffff);
    }
    }
    // argument x9 is killed and marked as dead
    // result x9 is marked as alive


    // $xzr = SUBSXrs renamable $x9, killed renamable $x8, 0, implicit-def $nzcv
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        ASMD(SUBSx_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x8 is killed and marked as dead


    // renamable $x8 = MOVZXi 32760, 48
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZx_shift, scratch_x8.cur_reg, 0x7ff8, 3);
    }
    }
    // result x8 is marked as alive


    // CCMPXr killed renamable $x9, killed renamable $x8, 0, 12, implicit-def $nzcv, implicit killed $nzcv
    {
    if (1) {
        AsmReg op0 = scratch_x9.cur_reg;
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(CCMPx, op0, op1, DA_EQ, DA_GT);
    }
    }
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 10, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_GE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_qnan_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_qnan_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $d0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $w0
    //   $x9 = FMOVDXr killed $d0
    //   renamable $x8 = MOVNXi 32776, 48
    //   renamable $x9 = ANDXri killed renamable $x9, 4158
    //   $xzr = SUBSXrs killed renamable $x9, killed renamable $x8, 0, implicit-def $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 13, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_qnan_double.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // $x9 = FMOVDXr killed $d0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(FMOVdx, scratch_x9.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x9 is marked as alive


    // renamable $x8 = MOVNXi 32776, 48
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVNx_shift, scratch_x8.cur_reg, 0x8008, 3);
    }
    }
    // result x8 is marked as alive


    // renamable $x9 = ANDXri killed renamable $x9, 4158
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x9.cur_reg, op1, 0x7fffffffffffffff);
    }
    }
    // argument x9 is killed and marked as dead
    // result x9 is marked as alive


    // $xzr = SUBSXrs killed renamable $x9, killed renamable $x8, 0, implicit-def $nzcv
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        ASMD(SUBSx_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 13, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_LE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_ninf_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_ninf_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $d0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $w0
    //   renamable $x8 = MOVZXi 65520, 48
    //   $d1 = FMOVXDr killed $x8
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_ninf_double.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $x8 = MOVZXi 65520, 48
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZx_shift, scratch_x8.cur_reg, 0xfff0, 3);
    }
    }
    // result x8 is marked as alive


    // $d1 = FMOVXDr killed $x8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def v1 has not been allocated yet
        scratch_v1.alloc_from_bank(1);
        ASMD(FMOVxd, scratch_v1.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result v1 is marked as alive


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = scratch_v1.cur_reg;
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // argument v1 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_nnorm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_nnorm_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $d0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $w0
    //   $x9 = FMOVDXr killed $d0
    //   renamable $x8 = MOVZXi 65520, 48
    //   renamable $x10 = ANDXri renamable $x9, 4158
    //   $x8 = ADDXrs killed renamable $x10, killed renamable $x8, 0
    //   renamable $x8 = UBFMXri killed renamable $x8, 53, 63
    //   $xzr = SUBSXri killed renamable $x8, 1023, 0, implicit-def $nzcv
    //   CCMPXi killed renamable $x9, 0, 0, 3, implicit-def $nzcv, implicit killed $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 10, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_nnorm_double.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};
    ScratchReg scratch_x10{derived()};


    // $x9 = FMOVDXr killed $d0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(FMOVdx, scratch_x9.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x9 is marked as alive


    // renamable $x8 = MOVZXi 65520, 48
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZx_shift, scratch_x8.cur_reg, 0xfff0, 3);
    }
    }
    // result x8 is marked as alive


    // renamable $x10 = ANDXri renamable $x9, 4158
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x10.cur_reg, op1, 0x7fffffffffffffff);
    }
    }
    // result x10 is marked as alive


    // $x8 = ADDXrs killed renamable $x10, killed renamable $x8, 0
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x10.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ADDx_lsl, scratch_x8.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x10 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // renamable $x8 = UBFMXri killed renamable $x8, 53, 63
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UBFMx, scratch_x8.cur_reg, op1, 0x35, 0x3f);
    }
    }
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // $xzr = SUBSXri killed renamable $x8, 1023, 0, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSxi, DA_ZR, op1, 1023);
    }
    }
    // argument x8 is killed and marked as dead


    // CCMPXi killed renamable $x9, 0, 0, 3, implicit-def $nzcv, implicit killed $nzcv
    {
    if (1) {
        AsmReg op0 = scratch_x9.cur_reg;
        ASMD(CCMPxi, op0, DA_EQ, DA_EQ, DA_LO);
    }
    }
    // argument x9 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 10, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_GE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_nsnorm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_nsnorm_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $d0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $w0
    //   $x9 = FMOVDXr killed $d0
    //   renamable $x8 = MOVNXi 65520, 48
    //   renamable $x10 = ANDXri renamable $x9, 4158
    //   renamable $x10 = SUBXri killed renamable $x10, 1, 0
    //   $xzr = SUBSXrs killed renamable $x10, killed renamable $x8, 0, implicit-def $nzcv
    //   CCMPXi killed renamable $x9, 0, 0, 3, implicit-def $nzcv, implicit killed $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 10, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_nsnorm_double.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};
    ScratchReg scratch_x10{derived()};


    // $x9 = FMOVDXr killed $d0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(FMOVdx, scratch_x9.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x9 is marked as alive


    // renamable $x8 = MOVNXi 65520, 48
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVNx_shift, scratch_x8.cur_reg, 0xfff0, 3);
    }
    }
    // result x8 is marked as alive


    // renamable $x10 = ANDXri renamable $x9, 4158
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x10.cur_reg, op1, 0x7fffffffffffffff);
    }
    }
    // result x10 is marked as alive


    // renamable $x10 = SUBXri killed renamable $x10, 1, 0
    {
    if (1) {
        AsmReg op1 = scratch_x10.cur_reg;
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(SUBxi, scratch_x10.cur_reg, op1, 1);
    }
    }
    // argument x10 is killed and marked as dead
    // result x10 is marked as alive


    // $xzr = SUBSXrs killed renamable $x10, killed renamable $x8, 0, implicit-def $nzcv
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x10.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        ASMD(SUBSx_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x10 is killed and marked as dead
    // argument x8 is killed and marked as dead


    // CCMPXi killed renamable $x9, 0, 0, 3, implicit-def $nzcv, implicit killed $nzcv
    {
    if (1) {
        AsmReg op0 = scratch_x9.cur_reg;
        ASMD(CCMPxi, op0, DA_EQ, DA_EQ, DA_LO);
    }
    }
    // argument x9 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 10, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_GE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_nzero_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_nzero_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $d0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $w0
    //   $x9 = FMOVDXr killed $d0
    //   renamable $x8 = MOVZXi 32768, 48
    //   $xzr = SUBSXrs killed renamable $x9, killed renamable $x8, 0, implicit-def $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_nzero_double.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // $x9 = FMOVDXr killed $d0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(FMOVdx, scratch_x9.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x9 is marked as alive


    // renamable $x8 = MOVZXi 32768, 48
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZx_shift, scratch_x8.cur_reg, 0x8000, 3);
    }
    }
    // result x8 is marked as alive


    // $xzr = SUBSXrs killed renamable $x9, killed renamable $x8, 0, implicit-def $nzcv
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        ASMD(SUBSx_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_pzero_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_pzero_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $d0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $w0
    //   $x8 = FMOVDXr killed $d0
    //   $xzr = SUBSXri killed renamable $x8, 0, 0, implicit-def $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_pzero_double.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // $x8 = FMOVDXr killed $d0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(FMOVdx, scratch_x8.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x8 is marked as alive


    // $xzr = SUBSXri killed renamable $x8, 0, 0, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSxi, DA_ZR, op1, 0);
    }
    }
    // argument x8 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_psnorm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_psnorm_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $d0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $w0
    //   $x9 = FMOVDXr killed $d0
    //   renamable $x8 = MOVNXi 65520, 48
    //   renamable $x9 = SUBXri killed renamable $x9, 1, 0
    //   $xzr = SUBSXrs killed renamable $x9, killed renamable $x8, 0, implicit-def $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 2, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_psnorm_double.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // $x9 = FMOVDXr killed $d0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(FMOVdx, scratch_x9.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x9 is marked as alive


    // renamable $x8 = MOVNXi 65520, 48
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVNx_shift, scratch_x8.cur_reg, 0xfff0, 3);
    }
    }
    // result x8 is marked as alive


    // renamable $x9 = SUBXri killed renamable $x9, 1, 0
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(SUBxi, scratch_x9.cur_reg, op1, 1);
    }
    }
    // argument x9 is killed and marked as dead
    // result x9 is marked as alive


    // $xzr = SUBSXrs killed renamable $x9, killed renamable $x8, 0, implicit-def $nzcv
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        ASMD(SUBSx_lsl, DA_ZR, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 2, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_HS);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_pnorm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_pnorm_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $d0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $w0
    //   $x9 = FMOVDXr killed $d0
    //   renamable $x8 = MOVZXi 65520, 48
    //   renamable $x10 = ANDXri renamable $x9, 4158
    //   $x8 = ADDXrs killed renamable $x10, killed renamable $x8, 0
    //   renamable $x8 = UBFMXri killed renamable $x8, 53, 63
    //   $xzr = SUBSXri killed renamable $x8, 1023, 0, implicit-def $nzcv
    //   CCMPXi killed renamable $x9, 0, 8, 3, implicit-def $nzcv, implicit killed $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 11, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_pnorm_double.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};
    ScratchReg scratch_x10{derived()};


    // $x9 = FMOVDXr killed $d0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(FMOVdx, scratch_x9.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x9 is marked as alive


    // renamable $x8 = MOVZXi 65520, 48
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZx_shift, scratch_x8.cur_reg, 0xfff0, 3);
    }
    }
    // result x8 is marked as alive


    // renamable $x10 = ANDXri renamable $x9, 4158
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x10 has not been allocated yet
        scratch_x10.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x10.cur_reg, op1, 0x7fffffffffffffff);
    }
    }
    // result x10 is marked as alive


    // $x8 = ADDXrs killed renamable $x10, killed renamable $x8, 0
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x10.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ADDx_lsl, scratch_x8.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x10 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // renamable $x8 = UBFMXri killed renamable $x8, 53, 63
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UBFMx, scratch_x8.cur_reg, op1, 0x35, 0x3f);
    }
    }
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // $xzr = SUBSXri killed renamable $x8, 1023, 0, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSxi, DA_ZR, op1, 1023);
    }
    }
    // argument x8 is killed and marked as dead


    // CCMPXi killed renamable $x9, 0, 8, 3, implicit-def $nzcv, implicit killed $nzcv
    {
    if (1) {
        AsmReg op0 = scratch_x9.cur_reg;
        ASMD(CCMPxi, op0, DA_EQ, DA_HI, DA_LO);
    }
    }
    // argument x9 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 11, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_LT);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_pinf_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_pinf_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $d0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $w0
    //   renamable $x8 = MOVZXi 32752, 48
    //   $d1 = FMOVXDr killed $x8
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_pinf_double.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $x8 = MOVZXi 32752, 48
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZx_shift, scratch_x8.cur_reg, 0x7ff0, 3);
    }
    }
    // result x8 is marked as alive


    // $d1 = FMOVXDr killed $x8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def v1 has not been allocated yet
        scratch_v1.alloc_from_bank(1);
        ASMD(FMOVxd, scratch_v1.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result v1 is marked as alive


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = scratch_v1.cur_reg;
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // argument v1 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_nan_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_nan_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $d0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $w0
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d0, implicit-def $nzcv, implicit $fpcr
    //   renamable $w8 = CSINCWr $wzr, $wzr, 7, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_nan_double.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d0, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(FCMP_d, op0, op0);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // argument v0 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 7, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_VC);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_inf_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_inf_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $d0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $w0
    //   renamable $d0 = FABSDr killed renamable $d0
    //   renamable $x8 = MOVZXi 32752, 48
    //   $d1 = FMOVXDr killed $x8
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_inf_double.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $d0 = FABSDr killed renamable $d0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FABSd, scratch_v0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result v0 is marked as alive


    // renamable $x8 = MOVZXi 32752, 48
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZx_shift, scratch_x8.cur_reg, 0x7ff0, 3);
    }
    }
    // result x8 is marked as alive


    // $d1 = FMOVXDr killed $x8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def v1 has not been allocated yet
        scratch_v1.alloc_from_bank(1);
        ASMD(FMOVxd, scratch_v1.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result v1 is marked as alive


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = scratch_v0.cur_reg;
        AsmReg op1 = scratch_v1.cur_reg;
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    // argument v1 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 1, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_NE);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_norm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_norm_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $d0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $w0
    //   $x9 = FMOVDXr killed $d0
    //   renamable $x8 = MOVZXi 65520, 48
    //   renamable $x9 = ANDXri killed renamable $x9, 4158
    //   $x8 = ADDXrs killed renamable $x9, killed renamable $x8, 0
    //   renamable $x8 = UBFMXri killed renamable $x8, 53, 63
    //   $xzr = SUBSXri killed renamable $x8, 1023, 0, implicit-def $nzcv
    //   renamable $w8 = CSINCWr $wzr, $wzr, 2, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_norm_double.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_x9{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // $x9 = FMOVDXr killed $d0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(FMOVdx, scratch_x9.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result x9 is marked as alive


    // renamable $x8 = MOVZXi 65520, 48
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZx_shift, scratch_x8.cur_reg, 0xfff0, 3);
    }
    }
    // result x8 is marked as alive


    // renamable $x9 = ANDXri killed renamable $x9, 4158
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        // def x9 has not been allocated yet
        scratch_x9.alloc_from_bank(0);
        ASMD(ANDxi, scratch_x9.cur_reg, op1, 0x7fffffffffffffff);
    }
    }
    // argument x9 is killed and marked as dead
    // result x9 is marked as alive


    // $x8 = ADDXrs killed renamable $x9, killed renamable $x8, 0
    do {
    {
    if (1) {
        AsmReg op1 = scratch_x9.cur_reg;
        AsmReg op2 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(ADDx_lsl, scratch_x8.cur_reg, op1, op2, 0);
        break;
    }
    }
    } while (false);
    // argument x9 is killed and marked as dead
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // renamable $x8 = UBFMXri killed renamable $x8, 53, 63
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(UBFMx, scratch_x8.cur_reg, op1, 0x35, 0x3f);
    }
    }
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // $xzr = SUBSXri killed renamable $x8, 1023, 0, implicit-def $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        ASMD(SUBSxi, DA_ZR, op1, 1023);
    }
    }
    // argument x8 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 2, implicit killed $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_HS);
    }
    }
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_finite_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_finite_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $w0, $d0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $d0, $w0
    //   renamable $d0 = FABSDr killed renamable $d0
    //   renamable $x8 = MOVZXi 32752, 48
    //   $d1 = FMOVXDr killed $x8
    //   nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    //   renamable $w8 = CSINCWr $wzr, $wzr, 5, implicit $nzcv
    //   renamable $w8 = CSINCWr killed renamable $w8, $wzr, 13, implicit killed $nzcv
    //   $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    //   RET undef $lr, implicit killed $w0
    // 
    // # End machine code for function is_fpclass_finite_double.
    // 

    // Mapping x0 to param_0
    // Mapping v0 to param_1
    ScratchReg scratch_x0{derived()};
    ScratchReg scratch_v1{derived()};
    ScratchReg scratch_v0{derived()};
    ScratchReg scratch_x8{derived()};


    // renamable $d0 = FABSDr killed renamable $d0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg_try_salvage(this, scratch_v0, 1);
        // def v0 has not been allocated yet
        scratch_v0.alloc_from_bank(1);
        ASMD(FABSd, scratch_v0.cur_reg, op1);
    }
    }
    // argument v0 is killed and marked as dead
    param_1.reset();
    // result v0 is marked as alive


    // renamable $x8 = MOVZXi 32752, 48
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(MOVZx_shift, scratch_x8.cur_reg, 0x7ff0, 3);
    }
    }
    // result x8 is marked as alive


    // $d1 = FMOVXDr killed $x8
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def v1 has not been allocated yet
        scratch_v1.alloc_from_bank(1);
        ASMD(FMOVxd, scratch_v1.cur_reg, op1);
    }
    }
    // argument x8 is killed and marked as dead
    // result v1 is marked as alive


    // nofpexcept FCMPDrr killed renamable $d0, killed renamable $d1, implicit-def $nzcv, implicit $fpcr
    {
    if (1) {
        AsmReg op0 = scratch_v0.cur_reg;
        AsmReg op1 = scratch_v1.cur_reg;
        ASMD(FCMP_d, op0, op1);
    }
    }
    // argument v0 is killed and marked as dead
    // argument v1 is killed and marked as dead


    // renamable $w8 = CSINCWr $wzr, $wzr, 5, implicit $nzcv
    {
    if (1) {
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, DA_ZR, DA_ZR, DA_PL);
    }
    }
    // result x8 is marked as alive


    // renamable $w8 = CSINCWr killed renamable $w8, $wzr, 13, implicit killed $nzcv
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        // def x8 has not been allocated yet
        scratch_x8.alloc_from_bank(0);
        ASMD(CSINCw, scratch_x8.cur_reg, op1, DA_ZR, DA_LE);
    }
    }
    // argument x8 is killed and marked as dead
    // result x8 is marked as alive


    // $w0 = ORRWrs killed renamable $w8, killed renamable $w0, 0
    {
    if (1) {
        AsmReg op1 = scratch_x8.cur_reg;
        AsmReg op2 = param_0.as_reg_try_salvage(this, scratch_x0, 0);
        // def x0 has not been allocated yet
        scratch_x0.alloc_from_bank(0);
        ASMD(ORRw_lsl, scratch_x0.cur_reg, op1, op2, 0);
    }
    }
    // argument x8 is killed and marked as dead
    // argument x0 is killed and marked as dead
    param_0.reset();
    // result x0 is marked as alive


    // RET undef $lr, implicit killed $w0
    // returning reg x0 as result_0
    result_0 = std::move(scratch_x0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_prefetch_rl0(AsmOperand param_0) {
    // # Machine code for function prefetch_rl0: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   PRFMui 1, killed renamable $x0, 0
    //   RET undef $lr
    // 
    // # End machine code for function prefetch_rl0.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // PRFMui 1, killed renamable $x0, 0
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 3);
    if (cond0) {
        ASMD(PRFMu, (Da64PrfOp)1, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(PRFMu, (Da64PrfOp)1, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_prefetch_rl1(AsmOperand param_0) {
    // # Machine code for function prefetch_rl1: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   PRFMui 4, killed renamable $x0, 0
    //   RET undef $lr
    // 
    // # End machine code for function prefetch_rl1.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // PRFMui 4, killed renamable $x0, 0
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 3);
    if (cond0) {
        ASMD(PRFMu, (Da64PrfOp)4, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(PRFMu, (Da64PrfOp)4, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_prefetch_rl2(AsmOperand param_0) {
    // # Machine code for function prefetch_rl2: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   PRFMui 2, killed renamable $x0, 0
    //   RET undef $lr
    // 
    // # End machine code for function prefetch_rl2.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // PRFMui 2, killed renamable $x0, 0
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 3);
    if (cond0) {
        ASMD(PRFMu, (Da64PrfOp)2, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(PRFMu, (Da64PrfOp)2, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_prefetch_rl3(AsmOperand param_0) {
    // # Machine code for function prefetch_rl3: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   PRFMui 0, killed renamable $x0, 0
    //   RET undef $lr
    // 
    // # End machine code for function prefetch_rl3.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // PRFMui 0, killed renamable $x0, 0
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 3);
    if (cond0) {
        ASMD(PRFMu, (Da64PrfOp)0, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(PRFMu, (Da64PrfOp)0, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_prefetch_wl0(AsmOperand param_0) {
    // # Machine code for function prefetch_wl0: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   PRFMui 17, killed renamable $x0, 0
    //   RET undef $lr
    // 
    // # End machine code for function prefetch_wl0.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // PRFMui 17, killed renamable $x0, 0
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 3);
    if (cond0) {
        ASMD(PRFMu, (Da64PrfOp)17, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(PRFMu, (Da64PrfOp)17, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_prefetch_wl1(AsmOperand param_0) {
    // # Machine code for function prefetch_wl1: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   PRFMui 20, killed renamable $x0, 0
    //   RET undef $lr
    // 
    // # End machine code for function prefetch_wl1.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // PRFMui 20, killed renamable $x0, 0
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 3);
    if (cond0) {
        ASMD(PRFMu, (Da64PrfOp)20, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(PRFMu, (Da64PrfOp)20, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_prefetch_wl2(AsmOperand param_0) {
    // # Machine code for function prefetch_wl2: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   PRFMui 18, killed renamable $x0, 0
    //   RET undef $lr
    // 
    // # End machine code for function prefetch_wl2.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // PRFMui 18, killed renamable $x0, 0
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 3);
    if (cond0) {
        ASMD(PRFMu, (Da64PrfOp)18, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(PRFMu, (Da64PrfOp)18, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();


    // RET undef $lr
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_prefetch_wl3(AsmOperand param_0) {
    // # Machine code for function prefetch_wl3: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $x0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $x0
    //   PRFMui 16, killed renamable $x0, 0
    //   RET undef $lr
    // 
    // # End machine code for function prefetch_wl3.
    // 

    // Mapping x0 to param_0
    ScratchReg scratch_x0{derived()};


    // PRFMui 16, killed renamable $x0, 0
    do {
    {
    auto cond0 = param_0.encodeable_with_mem_uoff12(this, 0x0, 3);
    if (cond0) {
        ASMD(PRFMu, (Da64PrfOp)16, (*cond0).first, (*cond0).second);
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(PRFMu, (Da64PrfOp)16, op1, 0x0);
        break;
    }
    }
    } while (false);
    // argument x0 is killed and marked as dead
    param_0.reset();


    // RET undef $lr
    return true;

}



} // namespace tpde_encodegen

#undef ASMD
// SPDX-SnippetEnd
