// SPDX-FileCopyrightText: 2024 Tobias Schwarz <tobias.schwarz@tum.de>
// SPDX-FileCopyrightText: 2024 Tobias Kamm <tobias.kamm@tum.de>
//
// SPDX-License-Identifier: LicenseRef-Proprietary AND CC0-1.0

// NOTE: This file is autogenerated by tpde-encodegen. Please DO NOT edit this file
// as all changes will be overwritten once the file is generated again.
// NOTE: Some parts of this file are subject to the default license of TPDE
// and only the autogenerated code falls under the CC0-1.0 license

// SPDX-SnippetBegin
// SPDX-License-Identifier: LicenseRef-Proprietary
#pragma once

#include <optional>
#include <variant>

#include "tpde/base.hpp"
#include "tpde/x64/CompilerX64.hpp"

// Helper macros for assembling in the compiler
#if defined(ASMD)
    #error Got definition for ASM macros from somewhere else. Maybe you included compilers for multiple architectures?
#endif

#define ASMD(...) ASMC(this->derived(), __VA_ARGS__)

namespace tpde_encodegen {

using namespace tpde;

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          typename BaseTy,
          typename Config>
struct EncodeCompiler {
    using CompilerX64  = tpde::x64::CompilerX64<Adaptor, Derived, BaseTy, Config>;
    using ScratchReg   = typename CompilerX64::ScratchReg;
    using AsmReg       = typename CompilerX64::AsmReg;
    using ValuePartRef = typename CompilerX64::ValuePartRef;
    using Assembler    = typename CompilerX64::Assembler;
    using Label        = typename Assembler::Label;
    using ValLocalIdx  = typename CompilerX64::ValLocalIdx;
    using SymRef       = typename Assembler::SymRef;

    struct AsmOperand {
        struct Expr {
            std::variant<AsmReg, ScratchReg> base;
            std::variant<AsmReg, ScratchReg> index;
            i64                              scale;
            i64                              disp;

            explicit Expr()
                : base{AsmReg::make_invalid()}, scale{0}, disp{0} {}

            explicit Expr(AsmReg base, i64 disp = 0)
                : base(base), scale(0), disp(disp) {}

            explicit Expr(ScratchReg &&base, i64 disp = 0)
                : base(std::move(base)), scale(0), disp(disp) {}

            AsmReg base_reg() const noexcept {
                if (std::holds_alternative<AsmReg>(base)) {
                    return std::get<AsmReg>(base);
                }
                return std::get<ScratchReg>(base).cur_reg;
            }

            [[nodiscard]] bool has_base() const noexcept {
                if (std::holds_alternative<AsmReg>(base)) {
                    return std::get<AsmReg>(base).valid();
                }
                return true;
            }

            AsmReg index_reg() const noexcept {
                assert(scale != 0 && "index_reg() called on invalid index");
                assert((scale != 1 || has_base()) &&
                       "Expr with unscaled index must have base");
                if (std::holds_alternative<AsmReg>(index)) {
                    return std::get<AsmReg>(index);
                }
                return std::get<ScratchReg>(index).cur_reg;
            }

            [[nodiscard]] bool has_index() const noexcept { return scale != 0; }
        };

        struct Immediate {
            union {
                u64                const_u64;
                std::array<u8, 64> const_bytes;
            };

            u32 bank, size;
        };

        // TODO(ts): evaluate the use of std::variant
        // TODO(ts): I don't like the ValuePartRefs but we also don't want to
        // force all the operands into registers at the start of the encoding...
        std::variant<std::monostate,
                     ValuePartRef,
                     ValuePartRef *,
                     ScratchReg,
                     Expr,
                     Immediate>
            state;

        AsmOperand() = default;

        AsmOperand(AsmOperand &) = delete;

        AsmOperand(AsmOperand &&other) noexcept {
            state       = std::move(other.state);
            other.state = std::monostate{};
        }

        AsmOperand &operator=(const AsmOperand &) noexcept = delete;

        AsmOperand &operator=(AsmOperand &&other) noexcept {
            if (this == &other) {
                return *this;
            }
            state       = std::move(other.state);
            other.state = std::monostate{};
            return *this;
        }

        // ReSharper disable CppNonExplicitConvertingConstructor
        // NOLINTBEGIN(*-explicit-constructor)

        // reg can't be overwritten
        AsmOperand(AsmReg reg) noexcept : state{Expr(reg)} {}

        // no salvaging
        AsmOperand(const ScratchReg &reg) noexcept {
            assert(!reg.cur_reg.invalid());
            state = Expr(reg.cur_reg);
        }

        // salvaging
        AsmOperand(ScratchReg &&reg) noexcept {
            assert(!reg.cur_reg.invalid());
            state = std::move(reg);
        }

        // no salvaging
        AsmOperand(ValuePartRef &ref) noexcept {
            if (ref.is_const) {
                state = Immediate{.const_bytes = ref.state.c.const_data,
                                  .bank        = ref.state.c.bank,
                                  .size        = ref.state.c.size};
                return;
            }
            // TODO(ts): check if it is a variable_ref/frame_ptr and then
            // turning it into an Address?
            state = &ref;
        }

        // salvaging
        AsmOperand(ValuePartRef &&ref) noexcept {
            if (ref.is_const) {
                state = Immediate{.const_bytes = ref.state.c.const_data,
                                  .bank        = ref.state.c.bank,
                                  .size        = ref.state.c.size};
                return;
            }
            state = std::move(ref);
        }

        AsmOperand(Expr &&expr) noexcept {
            ScratchReg *base_scratch = std::get_if<ScratchReg>(&expr.base);
            if (base_scratch && !expr.has_index() && expr.disp == 0) {
                state = std::move(*base_scratch);
            } else {
                state = std::move(expr);
            }
        }

        AsmOperand(Immediate imm) noexcept { state = imm; }

        // NOLINTEND(*-explicit-constructor)
        // ReSharper restore CppNonExplicitConvertingConstructor

        [[nodiscard]] bool is_expr() const noexcept {
            return std::holds_alternative<Expr>(state);
        }

        [[nodiscard]] bool is_imm() const noexcept {
            return std::holds_alternative<Immediate>(state);
        }

        [[nodiscard]] Immediate &imm() noexcept {
            return std::get<Immediate>(state);
        }

        [[nodiscard]] ValuePartRef &val_ref() noexcept {
            return std::get<ValuePartRef>(state);
        }

        [[nodiscard]] std::optional<i32> encodeable_as_imm32_sext() const noexcept;
        [[nodiscard]] std::optional<FeMem> encodeable_as_mem() const noexcept;
        [[nodiscard]] std::optional<FeMem> encodeable_with(FeMem other) const noexcept;
        AsmReg             as_reg(EncodeCompiler *compiler) noexcept;
        bool               try_salvage(ScratchReg &, u8 bank) noexcept;
        bool          try_salvage_if_nonalloc(ScratchReg &, u8 bank) noexcept;
        void          try_salvage_or_materialize(EncodeCompiler *compiler,
                                                 ScratchReg     &dst_scratch,
                                                 u8              bank,
                                                 u32             size) noexcept;
        // compatibility
        bool          try_salvage(AsmReg &, ScratchReg &, u8 bank) noexcept;
        void          try_salvage_or_materialize(EncodeCompiler *compiler,
                                                 AsmReg         &dst_reg,
                                                 ScratchReg     &dst_scratch,
                                                 u8              bank,
                                                 u32             size) noexcept;
        void          reset() noexcept;
    };

    CompilerX64 *derived() noexcept {
        return static_cast<CompilerX64 *>(static_cast<Derived *>(this));
    }

    const CompilerX64 *derived() const noexcept {
        return static_cast<const CompilerX64 *>(
            static_cast<const Derived *>(this));
    }

    static bool reg_needs_avx512(AsmReg reg) noexcept {
        if (reg.id() > AsmReg::XMM15) {
            return true;
        }
        return false;
    }

    [[nodiscard]] bool has_avx() const noexcept {
        return derived()->has_cpu_feats(CompilerX64::CPU_AVX);
    }

    [[nodiscard]] static bool disp_add_encodeable(int32_t disp,
                                                  int32_t add) noexcept {
        const auto tmp = static_cast<int64_t>(disp) + add;
        return (static_cast<int64_t>(static_cast<int32_t>(tmp)) == tmp);
    }

    struct FixedRegBackup {
        ScratchReg  scratch;
        ValLocalIdx local_idx;
        u32         part;
        u32         lock_count;
    };

    void scratch_alloc_specific(AsmReg                              reg,
                                ScratchReg                         &scratch,
                                std::initializer_list<AsmOperand *> operands,
                                FixedRegBackup &backup_reg) noexcept;

    void scratch_check_fixed_backup(ScratchReg     &scratch,
                                    FixedRegBackup &backup_reg,
                                    bool            is_ret_reg) noexcept;

// SPDX-SnippetEnd
// SPDX-SnippetBegin
// SPDX-License-Identifier: CC0-1.0
// clang-format off

    bool encode_loadi8(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi16(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi24(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi40(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi48(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi56(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi128(AsmOperand param_0, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_loadf32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadf64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadv128(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadv256(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadv512(AsmOperand param_0, ScratchReg &result_0);
    bool encode_storei8(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei16(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei32(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei64(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei24(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei40(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei48(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei56(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2);
    bool encode_storef32(AsmOperand param_0, AsmOperand param_1);
    bool encode_storef64(AsmOperand param_0, AsmOperand param_1);
    bool encode_storev128(AsmOperand param_0, AsmOperand param_1);
    bool encode_storev256(AsmOperand param_0, AsmOperand param_1);
    bool encode_storev512(AsmOperand param_0, AsmOperand param_1);
    bool encode_addi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_subi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_muli32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_udivi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_sdivi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_uremi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_sremi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_landi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_lori32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_lxori32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_shli32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_shri32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_ashri32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_absi32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_addi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_subi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_muli64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_udivi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_sdivi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_uremi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_sremi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_landi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_lori64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_lxori64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_shli64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_shri64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_ashri64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_absi64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_addi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_subi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_muli128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_landi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_lori128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_lxori128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_shli128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_shri128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_ashri128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_shli128_lt64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_shli128_ge64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_shri128_lt64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_shri128_ge64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_ashri128_lt64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_ashri128_ge64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cttzi32_zero_poison(AsmOperand param_0, ScratchReg &result_0);
    bool encode_cttzi64_zero_poison(AsmOperand param_0, ScratchReg &result_0);
    bool encode_cttzi8(AsmOperand param_0, ScratchReg &result_0);
    bool encode_cttzi16(AsmOperand param_0, ScratchReg &result_0);
    bool encode_cttzi32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_cttzi64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_ctlzi8_zero_poison(AsmOperand param_0, ScratchReg &result_0);
    bool encode_ctlzi16_zero_poison(AsmOperand param_0, ScratchReg &result_0);
    bool encode_ctlzi32_zero_poison(AsmOperand param_0, ScratchReg &result_0);
    bool encode_ctlzi64_zero_poison(AsmOperand param_0, ScratchReg &result_0);
    bool encode_ctlzi8(AsmOperand param_0, ScratchReg &result_0);
    bool encode_ctlzi16(AsmOperand param_0, ScratchReg &result_0);
    bool encode_ctlzi32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_ctlzi64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_of_add_i8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_sub_i8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_mul_i8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_add_u8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_sub_u8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_mul_u8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_add_i16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_sub_i16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_mul_i16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_add_u16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_sub_u16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_mul_u16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_add_i32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_sub_i32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_mul_i32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_add_u32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_sub_u32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_mul_u32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_add_i64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_sub_i64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_mul_i64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_add_u64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_sub_u64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_mul_u64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_of_add_i128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1, ScratchReg &result_2);
    bool encode_of_sub_i128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1, ScratchReg &result_2);
    bool encode_of_mul_i128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1, ScratchReg &result_2);
    bool encode_of_add_u128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1, ScratchReg &result_2);
    bool encode_of_sub_u128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1, ScratchReg &result_2);
    bool encode_of_mul_u128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1, ScratchReg &result_2);
    bool encode_addf32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_subf32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_mulf32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_divf32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_addf64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_subf64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_mulf64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_divf64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fnegf32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_fnegf64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_fabsf32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_fabsf64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_fmaf32(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0);
    bool encode_fmaf64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0);
    bool encode_f64tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f32tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f32toi32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f32tou32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f32toi64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f32tou64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f64toi32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f64tou32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f64toi64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_f64tou64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_i8tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_i16tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_i32tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_i64tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_u8tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_u16tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_u32tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_u64tof32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_i8tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_i16tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_i32tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_i64tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_u8tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_u16tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_u32tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_u64tof64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_sext_8_to_32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_sext_8_to_64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_sext_16_to_32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_sext_16_to_64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_sext_32_to_64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_sext_arbitrary_to_32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_sext_arbitrary_to_64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fill_with_sign64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_zext_8_to_32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_zext_16_to_32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_zext_32_to_64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_cmpxchg_u64_monotonic_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_acquire_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_acquire_acquire(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_release_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_release_acquire(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_acqrel_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_acqrel_acquire(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_seqcst_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_seqcst_acquire(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_cmpxchg_u64_seqcst_seqcst(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_atomic_load_u8_mono(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u16_mono(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u32_mono(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u64_mono(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u8_acq(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u16_acq(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u32_acq(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u64_acq(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u8_seqcst(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u16_seqcst(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u32_seqcst(AsmOperand param_0, ScratchReg &result_0);
    bool encode_atomic_load_u64_seqcst(AsmOperand param_0, ScratchReg &result_0);
    bool encode_select_i32(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0);
    bool encode_select_i64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0);
    bool encode_select_i128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, AsmOperand param_4, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_select_f32(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0);
    bool encode_select_f64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0);
    bool encode_fcmp_oeq_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ogt_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_oge_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_olt_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ole_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_one_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ord_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ueq_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ugt_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_uge_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ult_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ule_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_une_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_uno_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_oeq_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ogt_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_oge_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_olt_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ole_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_one_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ord_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ueq_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ugt_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_uge_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ult_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_ule_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_une_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_fcmp_uno_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_snan_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_qnan_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_ninf_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_nnorm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_nsnorm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_nzero_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_pzero_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_psnorm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_pnorm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_pinf_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_nan_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_inf_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_norm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_finite_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_snan_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_qnan_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_ninf_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_nnorm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_nsnorm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_nzero_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_pzero_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_psnorm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_pnorm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_pinf_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_nan_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_inf_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_norm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_is_fpclass_finite_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_prefetch_rl0(AsmOperand param_0);
    bool encode_prefetch_rl1(AsmOperand param_0);
    bool encode_prefetch_rl2(AsmOperand param_0);
    bool encode_prefetch_rl3(AsmOperand param_0);
    bool encode_prefetch_wl0(AsmOperand param_0);
    bool encode_prefetch_wl1(AsmOperand param_0);
    bool encode_prefetch_wl2(AsmOperand param_0);
    bool encode_prefetch_wl3(AsmOperand param_0);


    SymRef sym_fnegf32_cp0 = Assembler::INVALID_SYM_REF;
    SymRef sym_fnegf64_cp0 = Assembler::INVALID_SYM_REF;
    SymRef sym_fabsf32_cp0 = Assembler::INVALID_SYM_REF;
    SymRef sym_fabsf64_cp0 = Assembler::INVALID_SYM_REF;
    SymRef sym_f32tou64_cp0 = Assembler::INVALID_SYM_REF;
    SymRef sym_f64tou64_cp0 = Assembler::INVALID_SYM_REF;
    SymRef sym_u64tof64_cp1 = Assembler::INVALID_SYM_REF;
    SymRef sym_u64tof64_cp0 = Assembler::INVALID_SYM_REF;
    SymRef sym_is_fpclass_ninf_float_cp0 = Assembler::INVALID_SYM_REF;
    SymRef sym_is_fpclass_pinf_float_cp0 = Assembler::INVALID_SYM_REF;
    SymRef sym_is_fpclass_ninf_double_cp0 = Assembler::INVALID_SYM_REF;
    SymRef sym_is_fpclass_pinf_double_cp0 = Assembler::INVALID_SYM_REF;


};
// SPDX-SnippetEnd



// SPDX-SnippetBegin
// SPDX-License-Identifier: LicenseRef-Proprietary
// clang-format on
template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
std::optional<i32> EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::
    encodeable_as_imm32_sext() const noexcept {
    if (!is_imm()) {
        return std::nullopt;
    }

    const auto &data = std::get<Immediate>(state);
    assert(data.size <= 8);
    const u64 imm = data.const_u64;
    if (data.size <= 4 || static_cast<i64>(static_cast<i32>(imm)) == static_cast<i64>(imm)) {
        // always encodeable
        return static_cast<i32>(data.const_u64);
    }

    return std::nullopt;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
std::optional<FeMem> EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::
    encodeable_as_mem() const noexcept {
    const ValuePartRef *ptr;
    if (std::holds_alternative<ValuePartRef>(state)) {
        ptr = &std::get<ValuePartRef>(state);
    } else if (std::holds_alternative<ValuePartRef *>(state)) {
        ptr = std::get<ValuePartRef *>(state);
    } else {
        return std::nullopt;
    }

    if (ptr->is_const) {
        return std::nullopt;
    }

    const auto ap = ptr->assignment();
    if (ap.register_valid() || ap.variable_ref())
        return std::nullopt;
    return FE_MEM(FE_BP, 0, FE_NOREG, -static_cast<i32>(ap.frame_off()));
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
std::optional<FeMem> EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::
    encodeable_with(FeMem other) const noexcept {
    const auto disp_encodeable = [](u64 a, u64 b) -> std::optional<i32> {
        auto sum = static_cast<i32>(a + b);
        if (static_cast<i64>(sum) == static_cast<i64>(a + b))
            return sum;
        return std::nullopt;
    };
    const auto is_noreg = [](FeRegGP gp) {
        return gp.idx == FE_NOREG.idx;
    };

    if (const auto *imm = std::get_if<Immediate>(&state)) {
        if (imm->size > 8)
            return std::nullopt;
        if (auto disp = disp_encodeable(imm->const_u64, other.off))
            return FE_MEM(other.base, other.scale, other.idx, *disp);
        return std::nullopt;
    }
    if (const auto *reg = std::get_if<ScratchReg>(&state)) {
        if (is_noreg(other.base))
            return FE_MEM(reg->cur_reg, other.scale, other.idx, other.off);
        if (is_noreg(other.idx))
            return FE_MEM(other.base, 1, reg->cur_reg, other.off);
        return std::nullopt;
    }
    if (const auto *expr = std::get_if<Expr>(&state)) {
        // TODO: check completeness
        auto disp = disp_encodeable(expr->disp, other.off);
        if (!disp)
            return std::nullopt;
        if (!expr->has_index()) {
            if (!expr->has_base())
                return FE_MEM(other.base, other.scale, other.idx, *disp);
            if (is_noreg(other.base))
                return FE_MEM(expr->base_reg(), other.scale, other.idx, *disp);
            if (is_noreg(other.idx))
                return FE_MEM(other.base, 1, expr->base_reg(), *disp);
            return std::nullopt;
        }
        if (expr->scale != 1 && expr->scale != 2 && expr->scale != 4 && expr->scale != 8)
            return std::nullopt;
        auto scale = static_cast<u8>(expr->scale);
        if (!is_noreg(other.idx))
            return std::nullopt;
        if (!expr->has_base())
            return FE_MEM(other.base, scale, expr->index_reg(), *disp);
        if (is_noreg(other.base) && expr->has_base())
            return FE_MEM(expr->base_reg(), scale, expr->index_reg(), *disp);
        return std::nullopt;
    }
    // TODO: ValuePartRef?
    return std::nullopt;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
typename EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmReg
    EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::as_reg(
        EncodeCompiler<Adaptor, Derived, BaseTy, Config> *compiler) noexcept {
    if (std::holds_alternative<ScratchReg>(state)) {
        return std::get<ScratchReg>(state).cur_reg;
    }
    if (std::holds_alternative<ValuePartRef>(state)) {
        auto      &val_ref = std::get<ValuePartRef>(state);
        const auto reg     = val_ref.alloc_reg();
        val_ref.lock();
        return reg;
    }
    if (std::holds_alternative<ValuePartRef *>(state)) {
        auto      &val_ref = *std::get<ValuePartRef *>(state);
        const auto reg     = val_ref.alloc_reg();
        val_ref.lock();
        return reg;
    }
    if (is_imm()) {
        const auto &data = std::get<Immediate>(state);
        ScratchReg  dst{compiler->derived()};
        const auto  dst_reg = dst.alloc_from_bank(data.bank);
        compiler->derived()->materialize_constant(
            data.const_bytes, data.bank, data.size, dst_reg);
        state = std::move(dst);
        return dst_reg;
    }
    if (Expr *expr = std::get_if<Expr>(&state)) {
        if (expr->has_base() && !expr->has_index() && expr->disp == 0) {
            return expr->base_reg();
        }

        ScratchReg scratch{compiler->derived()};
        if (auto mem_op = encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0))) {
            if (std::holds_alternative<ScratchReg>(expr->base)) {
                scratch = std::move(std::get<ScratchReg>(expr->base));
            } else if (std::holds_alternative<ScratchReg>(expr->index)) {
                scratch = std::move(std::get<ScratchReg>(expr->index));
            } else {
                (void)scratch.alloc_gp();
            }
            ASMC(compiler->derived(), LEA64rm, scratch.cur_reg, *mem_op);
        } else {
            AsmReg index_reg;
            if (expr->has_index())
                index_reg = expr->index_reg();
            if (std::holds_alternative<ScratchReg>(expr->index)) {
                scratch = std::move(std::get<ScratchReg>(expr->index));
            } else {
                (void)scratch.alloc_gp();
            }
            auto dst = scratch.cur_reg;
            if (index_reg.valid()) {
                if ((expr->scale & (expr->scale - 1)) == 0) {
                    const auto shift = __builtin_ctzl(expr->scale);
                    if (dst != index_reg) {
                        ASMC(compiler->derived(), MOV64rr, dst, index_reg);
                    }
                    ASMC(compiler->derived(), SHL64ri, dst, shift);
                } else {
                    if (expr->scale >= std::numeric_limits<i32>::min()
                        && expr->scale <= std::numeric_limits<i32>::max()) {
                        ASMC(compiler->derived(),
                             IMUL64rri,
                             dst,
                             index_reg,
                             expr->scale);
                    } else {
                        ScratchReg scratch2{compiler->derived()};
                        auto       tmp2 = scratch2.alloc_gp();
                        ASMC(compiler->derived(), MOV64ri, tmp2, expr->scale);
                        if (dst != index_reg) {
                            ASMC(compiler->derived(), MOV64rr, dst, index_reg);
                        }
                        ASMC(compiler->derived(), IMUL64rr, dst, tmp2);
                    }
                }
                if (expr->has_base()) {
                    if (static_cast<i64>(expr->disp) >= std::numeric_limits<i32>::min()
                        && expr->disp <= std::numeric_limits<i32>::max()) {
                        ASMC(compiler->derived(), LEA64rm, dst, FE_MEM(expr->base_reg(), 1, dst, static_cast<i32>(expr->disp)));
                        expr->disp = 0;
                    } else {
                        ASMC(compiler->derived(), ADD64rr, dst, expr->base_reg());
                    }
                }
            } else if (expr->has_base()) {
                if (static_cast<i64>(expr->disp) >= std::numeric_limits<i32>::min()
                    && expr->disp <= std::numeric_limits<i32>::max()) {
                    ASMC(compiler->derived(), LEA64rm, dst, FE_MEM(expr->base_reg(), 0, FE_NOREG, static_cast<i32>(expr->disp)));
                    expr->disp = 0;
                }
            }
            if (expr->disp) {
                ScratchReg scratch2{compiler->derived()};
                auto       tmp2 = scratch2.alloc_gp();
                ASMC(compiler->derived(), MOV64ri, tmp2, expr->disp);
                ASMC(compiler->derived(), ADD64rr, dst, tmp2);
            }
        }
        auto dst = scratch.cur_reg;
        state = std::move(scratch);
        return dst;
    }
    // TODO(ts): allow mem operands with scratchreg param?
    assert(0);
    exit(1);
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::try_salvage(
    ScratchReg &dst_scratch, const u8 bank) noexcept {
    if (!dst_scratch.cur_reg.invalid()) {
        return false;
    }

    if (std::holds_alternative<ScratchReg>(state)) {
        assert(std::get<ScratchReg>(state).compiler->register_file.reg_bank(
                   std::get<ScratchReg>(state).cur_reg)
               == bank);
        dst_scratch = std::move(std::get<ScratchReg>(state));
        state       = std::monostate{};
        return true;
    } else if (std::holds_alternative<ValuePartRef>(state)) {
        auto &ref = std::get<ValuePartRef>(state);
        assert(ref.bank() == bank);
        if (ref.can_salvage()) {
            auto reg = ref.salvage();
            dst_scratch.alloc_specific(reg);
            return true;
        }
        // dst = std::get<ValuePartRef>(state).alloc_reg();
        // return;
    } else if (std::holds_alternative<Immediate>(state)) {
        this->as_reg(static_cast<Derived *>(dst_scratch.compiler));
        assert(std::holds_alternative<ScratchReg>(state));
        assert(std::get<ScratchReg>(state).compiler->register_file.reg_bank(
                   std::get<ScratchReg>(state).cur_reg)
               == bank);

        dst_scratch = std::move(std::get<ScratchReg>(state));
        state       = std::monostate{};
        return true;
    }

    dst_scratch.alloc_from_bank(bank);
    return false;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::
    try_salvage_if_nonalloc(ScratchReg &dst_scratch, const u8 bank) noexcept {
    if (!dst_scratch.cur_reg.invalid()) {
        return false;
    }
    return try_salvage(dst_scratch, bank);
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::try_salvage(
    AsmReg &dst_reg, ScratchReg &dst_scratch, const u8 bank) noexcept {
    const auto res = try_salvage(dst_scratch, bank);
    dst_reg        = dst_scratch.cur_reg;
    return res;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
void EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::
    try_salvage_or_materialize(EncodeCompiler *compiler,
                               AsmReg         &dst_reg,
                               ScratchReg     &dst_scratch,
                               u8              bank,
                               u32             size) noexcept {
    try_salvage_or_materialize(compiler, dst_scratch, bank, size);
    dst_reg = dst_scratch.cur_reg;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
void EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::
    try_salvage_or_materialize(EncodeCompiler *compiler,
                               ScratchReg     &dst_scratch,
                               u8              bank,
                               u32             size) noexcept {
    if (!this->try_salvage(dst_scratch, bank)) {
        if (bank == 0) {
            if (std::holds_alternative<Immediate>(state)) {
                const auto &data = std::get<Immediate>(state);
                compiler->derived()->materialize_constant(data.const_bytes,
                                                          data.bank,
                                                          data.size,
                                                          dst_scratch.cur_reg);
                return;
            }

            AsmReg val = this->as_reg(compiler);
            if (size <= 4) {
                ASMC(compiler->derived(), MOV32rr, dst_scratch.cur_reg, val);
            } else {
                ASMC(compiler->derived(), MOV64rr, dst_scratch.cur_reg, val);
            }
        } else {
            AsmReg val = this->as_reg(compiler);
            if (size <= 16) {
                if (compiler->derived()->has_cpu_feats(CompilerX64::CPU_AVX)) {
                    ASMC(compiler->derived(),
                         VMOVAPD128rr,
                         dst_scratch.cur_reg,
                         val);
                } else {
                    ASMC(compiler->derived(),
                         SSE_MOVAPDrr,
                         dst_scratch.cur_reg,
                         val);
                }
            } else if (size <= 32) {
                assert(
                    compiler->derived()->has_cpu_feats(CompilerX64::CPU_AVX));
                ASMC(compiler->derived(),
                     VMOVAPD256rr,
                     dst_scratch.cur_reg,
                     val);
            } else {
                assert(size <= 64);
                assert(compiler->derived()->has_cpu_feats(
                    CompilerX64::CPU_AVX512F));
                ASMC(compiler->derived(),
                     VMOVAPD512rr,
                     dst_scratch.cur_reg,
                     val);
            }
        }
    }
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
void EncodeCompiler<Adaptor, Derived, BaseTy, Config>::AsmOperand::
    reset() noexcept {
    state = std::monostate{};
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
void EncodeCompiler<Adaptor, Derived, BaseTy, Config>::scratch_alloc_specific(
    AsmReg                              reg,
    ScratchReg                         &scratch,
    std::initializer_list<AsmOperand *> operands,
    FixedRegBackup                     &backup_reg) noexcept {
    if (!derived()->register_file.is_fixed(reg)) [[likely]] {
        scratch.alloc_specific(reg);
        return;
    }

    const auto bank = derived()->register_file.reg_bank(reg);
    if (bank != 0) {
        // TODO(ts): need to know the size
        assert(0);
        exit(1);
    }

    const auto alloc_backup = [this, &backup_reg, &scratch, reg, bank]() {
        const auto bak_reg    = backup_reg.scratch.alloc_from_bank(bank);
        auto      &reg_file   = derived()->register_file;
        auto      &assignment = reg_file.assignments[reg.id()];
        backup_reg.local_idx  = assignment.local_idx;
        backup_reg.part       = assignment.part;
        backup_reg.lock_count = assignment.lock_count;

        assignment.local_idx  = CompilerX64::INVALID_VAL_LOCAL_IDX;
        assignment.part       = 0;
        assignment.lock_count = 0;

        assert(scratch.cur_reg.invalid());
        scratch.cur_reg = reg;

        ASMD(MOV64rr, bak_reg, reg);
    };

    // check if one of the operands holds the fixed register
    for (auto *op_ptr : operands) {
        auto &op = op_ptr->state;
        if (std::holds_alternative<ScratchReg>(op)) {
            auto &op_scratch = std::get<ScratchReg>(op);
            if (op_scratch.cur_reg == reg) {
                scratch = std::move(op_scratch);
                op_scratch.alloc_from_bank(bank);
                ASMD(MOV64rr, op_scratch.cur_reg, reg);
                return;
            }
            continue;
        }

        if (std::holds_alternative<ValuePartRef>(op)) {
            auto &op_ref = std::get<ValuePartRef>(op);
            if (!op_ref.is_const) {
                assert(!op_ref.state.v.locked);
                const auto ap = op_ref.assignment();
                if (ap.register_valid()) {
                    assert(AsmReg{ap.full_reg_id()} != reg);
                }
            }
            continue;
        }

        if (std::holds_alternative<ValuePartRef *>(op)) {
            auto &op_ref = *std::get<ValuePartRef *>(op);
            if (!op_ref.is_const) {
                assert(!op_ref.state.v.locked);
                const auto ap = op_ref.assignment();
                if (ap.register_valid()) {
                    assert(AsmReg{ap.full_reg_id()} != reg);
                }
            }
            continue;
        }

        if (std::holds_alternative<typename AsmOperand::Expr>(op)) {
            auto &expr = std::get<typename AsmOperand::Expr>(op);
            if (expr.base_reg() == reg) {
                if (std::holds_alternative<ScratchReg>(expr.base)) {
                    auto &op_scratch = std::get<ScratchReg>(expr.base);
                    scratch          = std::move(op_scratch);
                    op_scratch.alloc_from_bank(bank);
                    ASMD(MOV64rr, op_scratch.cur_reg, reg);
                } else {
                    alloc_backup();
                    expr.base = backup_reg.scratch.cur_reg;
                }
                return;
            }
            if (expr.scale != 0 && expr.index_reg() == reg) {
                if (std::holds_alternative<ScratchReg>(expr.index)) {
                    auto &op_scratch = std::get<ScratchReg>(expr.index);
                    scratch          = std::move(op_scratch);
                    op_scratch.alloc_from_bank(bank);
                    ASMD(MOV64rr, op_scratch.cur_reg, reg);
                } else {
                    alloc_backup();
                    expr.index = backup_reg.scratch.cur_reg;
                }
                return;
            }
            continue;
        }
    }

    // otherwise temporarily store it somewhere else
    alloc_backup();
    return;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>
void EncodeCompiler<Adaptor, Derived, BaseTy, Config>::
    scratch_check_fixed_backup(ScratchReg     &scratch,
                               FixedRegBackup &backup_reg,
                               const bool      is_ret_reg) noexcept {
    if (backup_reg.scratch.cur_reg.invalid()) [[likely]] {
        return;
    }

    assert(!scratch.cur_reg.invalid());
    auto &reg_file        = derived()->register_file;
    auto &assignment      = reg_file.assignments[scratch.cur_reg.id()];
    assignment.local_idx  = backup_reg.local_idx;
    assignment.part       = backup_reg.part;
    assignment.lock_count = backup_reg.lock_count;

    assert(reg_file.reg_bank(scratch.cur_reg) == 0);
    if (is_ret_reg) {
        // TODO(ts): allocate another scratch? Though at this point the scratch
        // regs have not been released yet so we might need to spill...

        // need to switch around backup and reg so it can be returned as a
        // ScratchReg
        ASMD(XCHG64rr, scratch.cur_reg, backup_reg.scratch.cur_reg);
        scratch.cur_reg            = backup_reg.scratch.cur_reg;
        backup_reg.scratch.cur_reg = AsmReg::make_invalid();
    } else {
        ASMD(MOV64rr, scratch.cur_reg, backup_reg.scratch.cur_reg);

        scratch.cur_reg = AsmReg::make_invalid();
        backup_reg.scratch.reset();
    }
}

// clang-format off
// SPDX-SnippetEnd
// SPDX-SnippetBegin
// SPDX-License-Identifier: CC0-1.0

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi8(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s8) from %ir.0, !tbaa !5)
    //   RET64 killed $eax
    // 
    // # End machine code for function loadi8.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s8) from %ir.0, !tbaa !5)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m8, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m8, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi16(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $eax = MOVZX32rm16 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s16) from %ir.0, !tbaa !8)
    //   RET64 killed $eax
    // 
    // # End machine code for function loadi16.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOVZX32rm16 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s16) from %ir.0, !tbaa !8)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m16, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m16, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $eax = MOV32rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s32) from %ir.0, !tbaa !10)
    //   RET64 killed $eax
    // 
    // # End machine code for function loadi32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOV32rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s32) from %ir.0, !tbaa !10)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $rax = MOV64rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s64) from %ir.0, !tbaa !12)
    //   RET64 killed $rax
    // 
    // # End machine code for function loadi64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $rax = MOV64rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s64) from %ir.0, !tbaa !12)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV64rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV64rm, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi24(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi24: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $ecx = MOVZX32rm16 renamable $rdi, 1, $noreg, 0, $noreg :: (load (s16) from %ir.0, align 1)
    //   renamable $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 2, $noreg :: (load (s8) from %ir.0 + 2)
    //   renamable $eax = SHL32ri killed renamable $eax(tied-def 0), 16, implicit-def dead $eflags
    //   renamable $eax = OR32rr killed renamable $eax(tied-def 0), killed renamable $ecx, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function loadi24.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $ecx = MOVZX32rm16 renamable $rdi, 1, $noreg, 0, $noreg :: (load (s16) from %ir.0, align 1)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOVZXr32m16, scratch_cx.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOVZXr32m16, scratch_cx.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // result cx is marked as alive


    // renamable $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 2, $noreg :: (load (s8) from %ir.0 + 2)
    do {
    {
    auto cond1 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 2));
    if (cond1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m8, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m8, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 2));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = SHL32ri killed renamable $eax(tied-def 0), 16, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(SHL32ri, scratch_ax.cur_reg, 0x10);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = OR32rr killed renamable $eax(tied-def 0), killed renamable $ecx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(OR32rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi40(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi40: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $ecx = MOV32rm renamable $rdi, 1, $noreg, 0, $noreg, implicit-def $rcx :: (load (s32) from %ir.0, align 1)
    //   renamable $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 4, $noreg, implicit-def $rax :: (load (s8) from %ir.0 + 4)
    //   renamable $rax = SHL64ri killed renamable $rax(tied-def 0), 32, implicit-def dead $eflags
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function loadi40.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $ecx = MOV32rm renamable $rdi, 1, $noreg, 0, $noreg, implicit-def $rcx :: (load (s32) from %ir.0, align 1)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_cx.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_cx.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // result cx is marked as alive
    // result cx is marked as alive


    // renamable $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 4, $noreg, implicit-def $rax :: (load (s8) from %ir.0 + 4)
    do {
    {
    auto cond1 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 4));
    if (cond1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m8, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m8, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 4));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $rax = SHL64ri killed renamable $rax(tied-def 0), 32, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(SHL64ri, scratch_ax.cur_reg, 0x20);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(OR64rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi48(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi48: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $ecx = MOV32rm renamable $rdi, 1, $noreg, 0, $noreg, implicit-def $rcx :: (load (s32) from %ir.0, align 1)
    //   renamable $eax = MOVZX32rm16 killed renamable $rdi, 1, $noreg, 4, $noreg, implicit-def $rax :: (load (s16) from %ir.0 + 4, align 1)
    //   renamable $rax = SHL64ri killed renamable $rax(tied-def 0), 32, implicit-def dead $eflags
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function loadi48.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $ecx = MOV32rm renamable $rdi, 1, $noreg, 0, $noreg, implicit-def $rcx :: (load (s32) from %ir.0, align 1)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_cx.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_cx.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // result cx is marked as alive
    // result cx is marked as alive


    // renamable $eax = MOVZX32rm16 killed renamable $rdi, 1, $noreg, 4, $noreg, implicit-def $rax :: (load (s16) from %ir.0 + 4, align 1)
    do {
    {
    auto cond1 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 4));
    if (cond1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m16, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m16, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 4));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $rax = SHL64ri killed renamable $rax(tied-def 0), 32, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(SHL64ri, scratch_ax.cur_reg, 0x20);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(OR64rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi56(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi56: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $eax = MOVZX32rm16 renamable $rdi, 1, $noreg, 4, $noreg :: (load (s16) from %ir.0 + 4, align 1)
    //   renamable $ecx = MOVZX32rm8 renamable $rdi, 1, $noreg, 6, $noreg, implicit-def $rcx :: (load (s8) from %ir.0 + 6)
    //   renamable $ecx = SHL32ri killed renamable $ecx(tied-def 0), 16, implicit-def dead $eflags, implicit killed $rcx, implicit-def $rcx
    //   renamable $ecx = OR32rr killed renamable $ecx(tied-def 0), killed renamable $eax, implicit-def dead $eflags, implicit killed $rcx, implicit-def $rcx
    //   renamable $rcx = SHL64ri killed renamable $rcx(tied-def 0), 32, implicit-def dead $eflags
    //   renamable $eax = MOV32rm killed renamable $rdi, 1, $noreg, 0, $noreg, implicit-def $rax :: (load (s32) from %ir.0, align 1)
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function loadi56.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $eax = MOVZX32rm16 renamable $rdi, 1, $noreg, 4, $noreg :: (load (s16) from %ir.0 + 4, align 1)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 4));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m16, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m16, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 4));
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // renamable $ecx = MOVZX32rm8 renamable $rdi, 1, $noreg, 6, $noreg, implicit-def $rcx :: (load (s8) from %ir.0 + 6)
    do {
    {
    auto cond1 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 6));
    if (cond1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOVZXr32m8, scratch_cx.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOVZXr32m8, scratch_cx.cur_reg, FE_MEM(op1, 0, FE_NOREG, 6));
        break;
    }
    }
    } while (false);
    // result cx is marked as alive
    // result cx is marked as alive


    // renamable $ecx = SHL32ri killed renamable $ecx(tied-def 0), 16, implicit-def dead $eflags, implicit killed $rcx, implicit-def $rcx
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(SHL32ri, scratch_cx.cur_reg, 0x10);
    }
    }
    // argument cx is killed and marked as dead
    // argument cx is killed and marked as dead
    // result cx is marked as alive
    // result cx is marked as alive


    // renamable $ecx = OR32rr killed renamable $ecx(tied-def 0), killed renamable $eax, implicit-def dead $eflags, implicit killed $rcx, implicit-def $rcx
    do {
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR32rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result cx is marked as alive
    // result cx is marked as alive


    // renamable $rcx = SHL64ri killed renamable $rcx(tied-def 0), 32, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(SHL64ri, scratch_cx.cur_reg, 0x20);
    }
    }
    // argument cx is killed and marked as dead
    // result cx is marked as alive


    // renamable $eax = MOV32rm killed renamable $rdi, 1, $noreg, 0, $noreg, implicit-def $rax :: (load (s32) from %ir.0, align 1)
    do {
    {
    auto cond2 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond2) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_ax.cur_reg, (*cond2));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(OR64rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadi128(AsmOperand param_0, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function loadi128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $rax = MOV64rm renamable $rdi, 1, $noreg, 0, $noreg :: (load (s64) from %ir.0, align 16, !tbaa !18)
    //   renamable $rdx = MOV64rm killed renamable $rdi, 1, $noreg, 8, $noreg :: (load (s64) from %ir.0 + 8, basealign 16, !tbaa !18)
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function loadi128.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};


    // renamable $rax = MOV64rm renamable $rdi, 1, $noreg, 0, $noreg :: (load (s64) from %ir.0, align 16, !tbaa !18)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV64rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV64rm, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // renamable $rdx = MOV64rm killed renamable $rdi, 1, $noreg, 8, $noreg :: (load (s64) from %ir.0 + 8, basealign 16, !tbaa !18)
    do {
    {
    auto cond1 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 8));
    if (cond1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(MOV64rm, scratch_dx.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_dx, 0)) {
            op1 = scratch_dx.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(MOV64rm, scratch_dx.cur_reg, FE_MEM(op1, 0, FE_NOREG, 8));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result dx is marked as alive


    // RET64 killed $rax, killed $rdx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadf32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $xmm0 = MOVSSrm_alt killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s32) from %ir.0, !tbaa !20)
    //   RET64 killed $xmm0
    // 
    // # End machine code for function loadf32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = MOVSSrm_alt killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s32) from %ir.0, !tbaa !20)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_MOVSSrm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_MOVSSrm, scratch_xmm0.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadf64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $xmm0 = MOVSDrm_alt killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s64) from %ir.0, !tbaa !22)
    //   RET64 killed $xmm0
    // 
    // # End machine code for function loadf64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = MOVSDrm_alt killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s64) from %ir.0, !tbaa !22)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_MOVSDrm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_MOVSDrm, scratch_xmm0.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadv128(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadv128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $xmm0 = MOVAPSrm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s128) from %ir.0, !tbaa !5)
    //   RET64 killed $xmm0
    // 
    // # End machine code for function loadv128.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = MOVAPSrm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s128) from %ir.0, !tbaa !5)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_MOVAPSrm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_MOVAPSrm, scratch_xmm0.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadv256(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadv256: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $ymm0 = VMOVAPSYrm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s256) from %ir.0, !tbaa !5)
    //   RET64 killed $ymm0
    // 
    // # End machine code for function loadv256.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $ymm0 = VMOVAPSYrm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s256) from %ir.0, !tbaa !5)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(VMOVAPS256rm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(VMOVAPS256rm, scratch_xmm0.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $ymm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_loadv512(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadv512: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $zmm0 = VMOVAPSZrm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s512) from %ir.0, !tbaa !5)
    //   RET64 killed $zmm0
    // 
    // # End machine code for function loadv512.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $zmm0 = VMOVAPSZrm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s512) from %ir.0, !tbaa !5)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(VMOVAPS512rm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(VMOVAPS512rm, scratch_xmm0.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $zmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei8(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $esi, $rdi
    //   MOV8mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $sil, implicit killed $esi :: (store (s8) into %ir.0, !tbaa !5)
    //   RET64
    // 
    // # End machine code for function storei8.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // MOV8mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $sil, implicit killed $esi :: (store (s8) into %ir.0, !tbaa !5)
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    auto cond1 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0 && cond1) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV8mi, (*cond1), (*cond0));
        break;
    }
    }
    {
    auto cond2 = param_1.encodeable_as_imm32_sext();
    if (cond2) {
        AsmReg op0 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV8mi, FE_MEM(op0, 0, FE_NOREG, 0), (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond3) {
        AsmReg op5 = param_1.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV8mr, (*cond3), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_1.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV8mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei16(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $esi, $rdi
    //   MOV16mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $si, implicit killed $esi :: (store (s16) into %ir.0, !tbaa !8)
    //   RET64
    // 
    // # End machine code for function storei16.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // MOV16mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $si, implicit killed $esi :: (store (s16) into %ir.0, !tbaa !8)
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    auto cond1 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0 && cond1) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV16mi, (*cond1), (*cond0));
        break;
    }
    }
    {
    auto cond2 = param_1.encodeable_as_imm32_sext();
    if (cond2) {
        AsmReg op0 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV16mi, FE_MEM(op0, 0, FE_NOREG, 0), (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond3) {
        AsmReg op5 = param_1.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV16mr, (*cond3), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_1.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV16mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei32(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $esi, $rdi
    //   MOV32mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $esi :: (store (s32) into %ir.0, !tbaa !10)
    //   RET64
    // 
    // # End machine code for function storei32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // MOV32mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $esi :: (store (s32) into %ir.0, !tbaa !10)
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    auto cond1 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0 && cond1) {
        ASMD(MOV32mi, (*cond1), (*cond0));
        break;
    }
    }
    {
    auto cond2 = param_1.encodeable_as_imm32_sext();
    if (cond2) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(MOV32mi, FE_MEM(op0, 0, FE_NOREG, 0), (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond3) {
        AsmReg op5 = param_1.as_reg(this);
        ASMD(MOV32mr, (*cond3), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_1.as_reg(this);
        ASMD(MOV32mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei64(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   MOV64mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rsi :: (store (s64) into %ir.0, !tbaa !12)
    //   RET64
    // 
    // # End machine code for function storei64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // MOV64mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rsi :: (store (s64) into %ir.0, !tbaa !12)
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    auto cond1 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0 && cond1) {
        ASMD(MOV64mi, (*cond1), (*cond0));
        break;
    }
    }
    {
    auto cond2 = param_1.encodeable_as_imm32_sext();
    if (cond2) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(MOV64mi, FE_MEM(op0, 0, FE_NOREG, 0), (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond3) {
        AsmReg op5 = param_1.as_reg(this);
        ASMD(MOV64mr, (*cond3), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_1.as_reg(this);
        ASMD(MOV64mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei24(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei24: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $esi, $rdi
    //   MOV16mr renamable $rdi, 1, $noreg, 0, $noreg, renamable $si :: (store (s16) into %ir.0, align 1)
    //   renamable $esi = SHR32ri killed renamable $esi(tied-def 0), 16, implicit-def dead $eflags
    //   MOV8mr killed renamable $rdi, 1, $noreg, 2, $noreg, killed renamable $sil, implicit killed $esi :: (store (s8) into %ir.0 + 2)
    //   RET64
    // 
    // # End machine code for function storei24.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // MOV16mr renamable $rdi, 1, $noreg, 0, $noreg, renamable $si :: (store (s16) into %ir.0, align 1)
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    auto cond1 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0 && cond1) {
        ASMD(MOV16mi, (*cond1), (*cond0));
        break;
    }
    }
    {
    auto cond2 = param_1.encodeable_as_imm32_sext();
    if (cond2) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(MOV16mi, FE_MEM(op0, 0, FE_NOREG, 0), (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond3) {
        AsmReg op5 = param_1.as_reg(this);
        ASMD(MOV16mr, (*cond3), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_1.as_reg(this);
        ASMD(MOV16mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);


    // renamable $esi = SHR32ri killed renamable $esi(tied-def 0), 16, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 4);
        ASMD(SHR32ri, scratch_si.cur_reg, 0x10);
    }
    }
    // argument si is killed and marked as dead
    // result si is marked as alive


    // MOV8mr killed renamable $rdi, 1, $noreg, 2, $noreg, killed renamable $sil, implicit killed $esi :: (store (s8) into %ir.0 + 2)
    do {
    {
    auto cond4 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 2));
    if (cond4) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV8mr, (*cond4), scratch_si.cur_reg);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV8mr, FE_MEM(op0, 0, FE_NOREG, 2), scratch_si.cur_reg);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei40(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei40: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   MOV32mr renamable $rdi, 1, $noreg, 0, $noreg, renamable $esi :: (store (s32) into %ir.0, align 1)
    //   renamable $rsi = SHR64ri killed renamable $rsi(tied-def 0), 32, implicit-def dead $eflags
    //   MOV8mr killed renamable $rdi, 1, $noreg, 4, $noreg, killed renamable $sil, implicit killed $rsi :: (store (s8) into %ir.0 + 4)
    //   RET64
    // 
    // # End machine code for function storei40.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // MOV32mr renamable $rdi, 1, $noreg, 0, $noreg, renamable $esi :: (store (s32) into %ir.0, align 1)
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    auto cond1 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0 && cond1) {
        ASMD(MOV32mi, (*cond1), (*cond0));
        break;
    }
    }
    {
    auto cond2 = param_1.encodeable_as_imm32_sext();
    if (cond2) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(MOV32mi, FE_MEM(op0, 0, FE_NOREG, 0), (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond3) {
        AsmReg op5 = param_1.as_reg(this);
        ASMD(MOV32mr, (*cond3), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_1.as_reg(this);
        ASMD(MOV32mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);


    // renamable $rsi = SHR64ri killed renamable $rsi(tied-def 0), 32, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(SHR64ri, scratch_si.cur_reg, 0x20);
    }
    }
    // argument si is killed and marked as dead
    // result si is marked as alive


    // MOV8mr killed renamable $rdi, 1, $noreg, 4, $noreg, killed renamable $sil, implicit killed $rsi :: (store (s8) into %ir.0 + 4)
    do {
    {
    auto cond4 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 4));
    if (cond4) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV8mr, (*cond4), scratch_si.cur_reg);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV8mr, FE_MEM(op0, 0, FE_NOREG, 4), scratch_si.cur_reg);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei48(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei48: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   MOV32mr renamable $rdi, 1, $noreg, 0, $noreg, renamable $esi :: (store (s32) into %ir.0, align 1)
    //   renamable $rsi = SHR64ri killed renamable $rsi(tied-def 0), 32, implicit-def dead $eflags
    //   MOV16mr killed renamable $rdi, 1, $noreg, 4, $noreg, killed renamable $si, implicit killed $rsi :: (store (s16) into %ir.0 + 4, align 1)
    //   RET64
    // 
    // # End machine code for function storei48.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // MOV32mr renamable $rdi, 1, $noreg, 0, $noreg, renamable $esi :: (store (s32) into %ir.0, align 1)
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    auto cond1 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0 && cond1) {
        ASMD(MOV32mi, (*cond1), (*cond0));
        break;
    }
    }
    {
    auto cond2 = param_1.encodeable_as_imm32_sext();
    if (cond2) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(MOV32mi, FE_MEM(op0, 0, FE_NOREG, 0), (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond3) {
        AsmReg op5 = param_1.as_reg(this);
        ASMD(MOV32mr, (*cond3), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_1.as_reg(this);
        ASMD(MOV32mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);


    // renamable $rsi = SHR64ri killed renamable $rsi(tied-def 0), 32, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(SHR64ri, scratch_si.cur_reg, 0x20);
    }
    }
    // argument si is killed and marked as dead
    // result si is marked as alive


    // MOV16mr killed renamable $rdi, 1, $noreg, 4, $noreg, killed renamable $si, implicit killed $rsi :: (store (s16) into %ir.0 + 4, align 1)
    do {
    {
    auto cond4 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 4));
    if (cond4) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV16mr, (*cond4), scratch_si.cur_reg);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV16mr, FE_MEM(op0, 0, FE_NOREG, 4), scratch_si.cur_reg);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei56(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei56: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   MOV32mr renamable $rdi, 1, $noreg, 0, $noreg, renamable $esi :: (store (s32) into %ir.0, align 1)
    //   $rax = MOV64rr $rsi
    //   renamable $rax = SHR64ri killed renamable $rax(tied-def 0), 48, implicit-def dead $eflags
    //   MOV8mr renamable $rdi, 1, $noreg, 6, $noreg, killed renamable $al, implicit killed $rax :: (store (s8) into %ir.0 + 6)
    //   renamable $rsi = SHR64ri killed renamable $rsi(tied-def 0), 32, implicit-def dead $eflags
    //   MOV16mr killed renamable $rdi, 1, $noreg, 4, $noreg, killed renamable $si, implicit killed $rsi :: (store (s16) into %ir.0 + 4, align 1)
    //   RET64
    // 
    // # End machine code for function storei56.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // MOV32mr renamable $rdi, 1, $noreg, 0, $noreg, renamable $esi :: (store (s32) into %ir.0, align 1)
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    auto cond1 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0 && cond1) {
        ASMD(MOV32mi, (*cond1), (*cond0));
        break;
    }
    }
    {
    auto cond2 = param_1.encodeable_as_imm32_sext();
    if (cond2) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(MOV32mi, FE_MEM(op0, 0, FE_NOREG, 0), (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond3) {
        AsmReg op5 = param_1.as_reg(this);
        ASMD(MOV32mr, (*cond3), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_1.as_reg(this);
        ASMD(MOV32mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);


    // $rax = MOV64rr $rsi
    // aliasing ax to si
    // ax is an alias for operand param_1


    // renamable $rax = SHR64ri killed renamable $rax(tied-def 0), 48, implicit-def dead $eflags
    {
    if (1) {
        AsmReg inst2_op1 = scratch_ax.alloc_from_bank(0);
        AsmReg inst2_op1_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, inst2_op1, inst2_op1_tmp);
        ASMD(SHR64ri, scratch_ax.cur_reg, 0x30);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // MOV8mr renamable $rdi, 1, $noreg, 6, $noreg, killed renamable $al, implicit killed $rax :: (store (s8) into %ir.0 + 6)
    do {
    {
    auto cond4 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 6));
    if (cond4) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV8mr, (*cond4), scratch_ax.cur_reg);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV8mr, FE_MEM(op0, 0, FE_NOREG, 6), scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument ax is killed and marked as dead


    // renamable $rsi = SHR64ri killed renamable $rsi(tied-def 0), 32, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(SHR64ri, scratch_si.cur_reg, 0x20);
    }
    }
    // argument si is killed and marked as dead
    // result si is marked as alive


    // MOV16mr killed renamable $rdi, 1, $noreg, 4, $noreg, killed renamable $si, implicit killed $rsi :: (store (s16) into %ir.0 + 4, align 1)
    do {
    {
    auto cond5 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 4));
    if (cond5) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV16mr, (*cond5), scratch_si.cur_reg);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(MOV16mr, FE_MEM(op0, 0, FE_NOREG, 4), scratch_si.cur_reg);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storei128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2) {
    // # Machine code for function storei128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdi, $rdx, $rsi
    //   MOV64mr renamable $rdi, 1, $noreg, 8, $noreg, killed renamable $rdx :: (store (s64) into %ir.0 + 8, basealign 16, !tbaa !18)
    //   MOV64mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rsi :: (store (s64) into %ir.0, align 16, !tbaa !18)
    //   RET64
    // 
    // # End machine code for function storei128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};


    // MOV64mr renamable $rdi, 1, $noreg, 8, $noreg, killed renamable $rdx :: (store (s64) into %ir.0 + 8, basealign 16, !tbaa !18)
    do {
    {
    auto cond0 = param_2.encodeable_as_imm32_sext();
    auto cond1 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 8));
    if (cond0 && cond1) {
        ASMD(MOV64mi, (*cond1), (*cond0));
        break;
    }
    }
    {
    auto cond2 = param_2.encodeable_as_imm32_sext();
    if (cond2) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(MOV64mi, FE_MEM(op0, 0, FE_NOREG, 8), (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 8));
    if (cond3) {
        AsmReg op5 = param_2.as_reg(this);
        ASMD(MOV64mr, (*cond3), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_2.as_reg(this);
        ASMD(MOV64mr, FE_MEM(op0, 0, FE_NOREG, 8), op5);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead


    // MOV64mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rsi :: (store (s64) into %ir.0, align 16, !tbaa !18)
    do {
    {
    auto cond4 = param_1.encodeable_as_imm32_sext();
    auto cond5 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond4 && cond5) {
        ASMD(MOV64mi, (*cond5), (*cond4));
        break;
    }
    }
    {
    auto cond6 = param_1.encodeable_as_imm32_sext();
    if (cond6) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(MOV64mi, FE_MEM(op0, 0, FE_NOREG, 0), (*cond6));
        break;
    }
    }
    {
    auto cond7 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond7) {
        AsmReg op5 = param_1.as_reg(this);
        ASMD(MOV64mr, (*cond7), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_1.as_reg(this);
        ASMD(MOV64mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storef32(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storef32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $xmm0
    //   MOVSSmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store (s32) into %ir.0, !tbaa !20)
    //   RET64
    // 
    // # End machine code for function storef32.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // MOVSSmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store (s32) into %ir.0, !tbaa !20)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        AsmReg op5 = param_1.as_reg(this);
        ASMD(SSE_MOVSSmr, (*cond0), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_1.as_reg(this);
        ASMD(SSE_MOVSSmr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storef64(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storef64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $xmm0
    //   MOVSDmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store (s64) into %ir.0, !tbaa !22)
    //   RET64
    // 
    // # End machine code for function storef64.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // MOVSDmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store (s64) into %ir.0, !tbaa !22)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        AsmReg op5 = param_1.as_reg(this);
        ASMD(SSE_MOVSDmr, (*cond0), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_1.as_reg(this);
        ASMD(SSE_MOVSDmr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storev128(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storev128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $xmm0
    //   MOVAPSmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store (s128) into %ir.0, !tbaa !5)
    //   RET64
    // 
    // # End machine code for function storev128.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // MOVAPSmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store (s128) into %ir.0, !tbaa !5)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        AsmReg op5 = param_1.as_reg(this);
        ASMD(SSE_MOVAPSmr, (*cond0), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_1.as_reg(this);
        ASMD(SSE_MOVAPSmr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storev256(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storev256: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $ymm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $ymm0
    //   VMOVAPSYmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $ymm0 :: (store (s256) into %ir.0, !tbaa !5)
    //   VZEROUPPER implicit-def dead $ymm0, implicit-def dead $ymm1, implicit-def dead $ymm2, implicit-def dead $ymm3, implicit-def dead $ymm4, implicit-def dead $ymm5, implicit-def dead $ymm6, implicit-def dead $ymm7, implicit-def dead $ymm8, implicit-def dead $ymm9, implicit-def dead $ymm10, implicit-def dead $ymm11, implicit-def dead $ymm12, implicit-def dead $ymm13, implicit-def dead $ymm14, implicit-def dead $ymm15
    //   RET64
    // 
    // # End machine code for function storev256.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // VMOVAPSYmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $ymm0 :: (store (s256) into %ir.0, !tbaa !5)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        AsmReg op5 = param_1.as_reg(this);
        ASMD(VMOVAPS256mr, (*cond0), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_1.as_reg(this);
        ASMD(VMOVAPS256mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // VZEROUPPER implicit-def dead $ymm0, implicit-def dead $ymm1, implicit-def dead $ymm2, implicit-def dead $ymm3, implicit-def dead $ymm4, implicit-def dead $ymm5, implicit-def dead $ymm6, implicit-def dead $ymm7, implicit-def dead $ymm8, implicit-def dead $ymm9, implicit-def dead $ymm10, implicit-def dead $ymm11, implicit-def dead $ymm12, implicit-def dead $ymm13, implicit-def dead $ymm14, implicit-def dead $ymm15
    // Skipping


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_storev512(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storev512: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $zmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $zmm0
    //   VMOVAPSZmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $zmm0 :: (store (s512) into %ir.0, !tbaa !5)
    //   VZEROUPPER implicit-def dead $ymm0, implicit-def dead $ymm1, implicit-def dead $ymm2, implicit-def dead $ymm3, implicit-def dead $ymm4, implicit-def dead $ymm5, implicit-def dead $ymm6, implicit-def dead $ymm7, implicit-def dead $ymm8, implicit-def dead $ymm9, implicit-def dead $ymm10, implicit-def dead $ymm11, implicit-def dead $ymm12, implicit-def dead $ymm13, implicit-def dead $ymm14, implicit-def dead $ymm15
    //   RET64
    // 
    // # End machine code for function storev512.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // VMOVAPSZmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $zmm0 :: (store (s512) into %ir.0, !tbaa !5)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        AsmReg op5 = param_1.as_reg(this);
        ASMD(VMOVAPS512mr, (*cond0), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_1.as_reg(this);
        ASMD(VMOVAPS512mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // VZEROUPPER implicit-def dead $ymm0, implicit-def dead $ymm1, implicit-def dead $ymm2, implicit-def dead $ymm3, implicit-def dead $ymm4, implicit-def dead $ymm5, implicit-def dead $ymm6, implicit-def dead $ymm7, implicit-def dead $ymm8, implicit-def dead $ymm9, implicit-def dead $ymm10, implicit-def dead $ymm11, implicit-def dead $ymm12, implicit-def dead $ymm13, implicit-def dead $ymm14, implicit-def dead $ymm15
    // Skipping


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_addi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function addi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   renamable $esi = KILL killed $esi, implicit-def $rsi
    //   renamable $edi = KILL killed $edi, implicit-def $rdi
    //   renamable $eax = LEA64_32r killed renamable $rdi, 1, killed renamable $rsi, 0, $noreg
    //   RET64 killed $eax
    // 
    // # End machine code for function addi32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // renamable $esi = KILL killed $esi, implicit-def $rsi
    // KILL is a no-op


    // renamable $edi = KILL killed $edi, implicit-def $rdi
    // KILL is a no-op


    // renamable $eax = LEA64_32r killed renamable $rdi, 1, killed renamable $rsi, 0, $noreg
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 1, FE_AX, 0));
    if (cond0) {
        AsmReg op3;
        if (param_1.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op3 = scratch_ax.cur_reg;
        } else {
            op3 = param_1.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA32rm, scratch_ax.cur_reg, FE_MEM((*cond0).base, (*cond0).scale, op3, (*cond0).off));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_with(FE_MEM(FE_AX, 0, FE_NOREG, 0));
    if (cond1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA32rm, scratch_ax.cur_reg, FE_MEM(op1, (*cond1).scale, (*cond1).idx, (*cond1).off));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        AsmReg op3;
        if (param_1.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op3 = scratch_ax.cur_reg;
        } else {
            op3 = param_1.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA32rm, scratch_ax.cur_reg, FE_MEM(op1, 1, op3, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_subi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function subi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   renamable $eax = SUB32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function subi32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $eax = SUB32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(SUB32ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(SUB32rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SUB32rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_muli32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function muli32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   renamable $eax = IMUL32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function muli32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $eax = IMUL32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(IMUL32rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(IMUL32rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_udivi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function udivi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   DIV32r killed renamable $esi, implicit-def $eax, implicit-def dead $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
    //   RET64 killed $eax
    // 
    // # End machine code for function udivi32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst1_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst1_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // DIV32r killed renamable $esi, implicit-def $eax, implicit-def dead $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // fixing reg 0 for cond (cond0)
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, op4_tmp);
        // fixing reg 2 for cond (cond0)
        ASMD(DIV32m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, op4_tmp);
        // fixing reg 2 for cond ()
        ASMD(DIV32r, op0);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as dead


    // RET64 killed $eax
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sdivi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sdivi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   CDQ implicit-def $eax, implicit-def $edx, implicit killed $eax
    //   IDIV32r killed renamable $esi, implicit-def $eax, implicit-def dead $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
    //   RET64 killed $eax
    // 
    // # End machine code for function sdivi32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // CDQ implicit-def $eax, implicit-def $edx, implicit killed $eax
    {
    if (1) {
        // fixing reg 0 for cond ()
        AsmReg op2_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, op2_tmp);
        ASMD(CDQ);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // IDIV32r killed renamable $esi, implicit-def $eax, implicit-def dead $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // fixing reg 0 for cond (cond0)
        // fixing reg 2 for cond (cond0)
        ASMD(IDIV32m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        // fixing reg 0 for cond ()
        // fixing reg 2 for cond ()
        ASMD(IDIV32r, op0);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as dead


    // RET64 killed $eax
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_uremi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function uremi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   DIV32r killed renamable $esi, implicit-def dead $eax, implicit-def $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
    //   $eax = MOV32rr killed $edx
    //   RET64 killed $eax
    // 
    // # End machine code for function uremi32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst1_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst1_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // DIV32r killed renamable $esi, implicit-def dead $eax, implicit-def $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // fixing reg 0 for cond (cond0)
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, op4_tmp);
        // fixing reg 2 for cond (cond0)
        ASMD(DIV32m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, op4_tmp);
        // fixing reg 2 for cond ()
        ASMD(DIV32r, op0);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as dead
    // result dx is marked as alive


    // $eax = MOV32rr killed $edx
    // aliasing ax to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $eax
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    // ax is an alias for dx
    result_0 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sremi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sremi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   CDQ implicit-def $eax, implicit-def $edx, implicit killed $eax
    //   IDIV32r killed renamable $esi, implicit-def dead $eax, implicit-def $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
    //   $eax = MOV32rr killed $edx
    //   RET64 killed $eax
    // 
    // # End machine code for function sremi32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // CDQ implicit-def $eax, implicit-def $edx, implicit killed $eax
    {
    if (1) {
        // fixing reg 0 for cond ()
        AsmReg op2_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, op2_tmp);
        ASMD(CDQ);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // IDIV32r killed renamable $esi, implicit-def dead $eax, implicit-def $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // fixing reg 0 for cond (cond0)
        // fixing reg 2 for cond (cond0)
        ASMD(IDIV32m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        // fixing reg 0 for cond ()
        // fixing reg 2 for cond ()
        ASMD(IDIV32r, op0);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as dead
    // result dx is marked as alive


    // $eax = MOV32rr killed $edx
    // aliasing ax to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $eax
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    // ax is an alias for dx
    result_0 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_landi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function landi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   renamable $eax = AND32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function landi32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $eax = AND32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(AND32ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(AND32rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(AND32rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_lori32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function lori32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   renamable $eax = OR32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function lori32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $eax = OR32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(OR32ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(OR32rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(OR32rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_lxori32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function lxori32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   renamable $eax = XOR32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function lxori32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $eax = XOR32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(XOR32ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(XOR32rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(XOR32rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shli32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function shli32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $ecx = MOV32rr killed $esi
    //   $eax = MOV32rr killed $edi
    //   $cl = KILL killed renamable $cl, implicit killed $ecx
    //   renamable $eax = SHL32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $eax
    // 
    // # End machine code for function shli32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    auto cond0 = param_1.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond0)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $ecx = MOV32rr killed $esi
    // aliasing cx to si
    // cx is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // $cl = KILL killed renamable $cl, implicit killed $ecx
    // KILL is a no-op


    // renamable $eax = SHL32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(SHL32ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHL32rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shri32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function shri32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $ecx = MOV32rr killed $esi
    //   $eax = MOV32rr killed $edi
    //   $cl = KILL killed renamable $cl, implicit killed $ecx
    //   renamable $eax = SHR32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $eax
    // 
    // # End machine code for function shri32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    auto cond0 = param_1.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond0)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $ecx = MOV32rr killed $esi
    // aliasing cx to si
    // cx is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // $cl = KILL killed renamable $cl, implicit killed $ecx
    // KILL is a no-op


    // renamable $eax = SHR32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(SHR32ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHR32rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ashri32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function ashri32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $ecx = MOV32rr killed $esi
    //   $eax = MOV32rr killed $edi
    //   $cl = KILL killed renamable $cl, implicit killed $ecx
    //   renamable $eax = SAR32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $eax
    // 
    // # End machine code for function ashri32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    auto cond0 = param_1.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond0)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $ecx = MOV32rr killed $esi
    // aliasing cx to si
    // cx is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // $cl = KILL killed renamable $cl, implicit killed $ecx
    // KILL is a no-op


    // renamable $eax = SAR32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(SAR32ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SAR32rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_absi32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function absi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   $eax = MOV32rr $edi
    //   renamable $eax = NEG32r killed renamable $eax(tied-def 0), implicit-def $eflags
    //   renamable $eax = CMOV32rr killed renamable $eax(tied-def 0), killed renamable $edi, 8, implicit killed $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function absi32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // $eax = MOV32rr $edi
    // aliasing ax to di
    // ax is an alias for operand param_0


    // renamable $eax = NEG32r killed renamable $eax(tied-def 0), implicit-def $eflags
    {
    if (1) {
        AsmReg inst1_op1 = scratch_ax.alloc_from_bank(0);
        AsmReg inst1_op1_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, inst1_op1, inst1_op1_tmp);
        ASMD(NEG32r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = CMOV32rr killed renamable $eax(tied-def 0), killed renamable $edi, 8, implicit killed $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        ASMD(CMOVS32rr, scratch_ax.cur_reg, op2);
    }
    }
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_addi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function addi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   renamable $rax = LEA64r killed renamable $rdi, 1, killed renamable $rsi, 0, $noreg
    //   RET64 killed $rax
    // 
    // # End machine code for function addi64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // renamable $rax = LEA64r killed renamable $rdi, 1, killed renamable $rsi, 0, $noreg
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 1, FE_AX, 0));
    if (cond0) {
        AsmReg op3;
        if (param_1.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op3 = scratch_ax.cur_reg;
        } else {
            op3 = param_1.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA64rm, scratch_ax.cur_reg, FE_MEM((*cond0).base, (*cond0).scale, op3, (*cond0).off));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_with(FE_MEM(FE_AX, 0, FE_NOREG, 0));
    if (cond1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA64rm, scratch_ax.cur_reg, FE_MEM(op1, (*cond1).scale, (*cond1).idx, (*cond1).off));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        AsmReg op3;
        if (param_1.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op3 = scratch_ax.cur_reg;
        } else {
            op3 = param_1.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA64rm, scratch_ax.cur_reg, FE_MEM(op1, 1, op3, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_subi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function subi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = SUB64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function subi64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = SUB64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SUB64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SUB64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SUB64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_muli64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function muli64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = IMUL64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function muli64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = IMUL64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(IMUL64rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(IMUL64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_udivi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function udivi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags, implicit-def $rdx
    //   DIV64r killed renamable $rsi, implicit-def $rax, implicit-def dead $rdx, implicit-def dead $eflags, implicit killed $rax, implicit killed $rdx
    //   RET64 killed $rax
    // 
    // # End machine code for function udivi64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags, implicit-def $rdx
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst1_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst1_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive
    // result dx is marked as alive


    // DIV64r killed renamable $rsi, implicit-def $rax, implicit-def dead $rdx, implicit-def dead $eflags, implicit killed $rax, implicit killed $rdx
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // fixing reg 0 for cond (cond0)
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        // fixing reg 2 for cond (cond0)
        ASMD(DIV64m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        // fixing reg 2 for cond ()
        ASMD(DIV64r, op0);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as dead


    // RET64 killed $rax
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sdivi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sdivi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   CQO implicit-def $rax, implicit-def $rdx, implicit killed $rax
    //   IDIV64r killed renamable $rsi, implicit-def $rax, implicit-def dead $rdx, implicit-def dead $eflags, implicit killed $rax, implicit killed $rdx
    //   RET64 killed $rax
    // 
    // # End machine code for function sdivi64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // CQO implicit-def $rax, implicit-def $rdx, implicit killed $rax
    {
    if (1) {
        // fixing reg 0 for cond ()
        AsmReg op2_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op2_tmp);
        ASMD(CQO);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // IDIV64r killed renamable $rsi, implicit-def $rax, implicit-def dead $rdx, implicit-def dead $eflags, implicit killed $rax, implicit killed $rdx
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // fixing reg 0 for cond (cond0)
        // fixing reg 2 for cond (cond0)
        ASMD(IDIV64m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        // fixing reg 0 for cond ()
        // fixing reg 2 for cond ()
        ASMD(IDIV64r, op0);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as dead


    // RET64 killed $rax
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_uremi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function uremi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags, implicit-def $rdx
    //   DIV64r killed renamable $rsi, implicit-def dead $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax, implicit killed $rdx
    //   $rax = MOV64rr killed $rdx
    //   RET64 killed $rax
    // 
    // # End machine code for function uremi64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags, implicit-def $rdx
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst1_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst1_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive
    // result dx is marked as alive


    // DIV64r killed renamable $rsi, implicit-def dead $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax, implicit killed $rdx
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // fixing reg 0 for cond (cond0)
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        // fixing reg 2 for cond (cond0)
        ASMD(DIV64m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        // fixing reg 2 for cond ()
        ASMD(DIV64r, op0);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as dead
    // result dx is marked as alive


    // $rax = MOV64rr killed $rdx
    // aliasing ax to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $rax
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    // ax is an alias for dx
    result_0 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sremi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sremi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   CQO implicit-def $rax, implicit-def $rdx, implicit killed $rax
    //   IDIV64r killed renamable $rsi, implicit-def dead $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax, implicit killed $rdx
    //   $rax = MOV64rr killed $rdx
    //   RET64 killed $rax
    // 
    // # End machine code for function sremi64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // CQO implicit-def $rax, implicit-def $rdx, implicit killed $rax
    {
    if (1) {
        // fixing reg 0 for cond ()
        AsmReg op2_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op2_tmp);
        ASMD(CQO);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // IDIV64r killed renamable $rsi, implicit-def dead $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax, implicit killed $rdx
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // fixing reg 0 for cond (cond0)
        // fixing reg 2 for cond (cond0)
        ASMD(IDIV64m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        // fixing reg 0 for cond ()
        // fixing reg 2 for cond ()
        ASMD(IDIV64r, op0);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as dead
    // result dx is marked as alive


    // $rax = MOV64rr killed $rdx
    // aliasing ax to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $rax
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    // ax is an alias for dx
    result_0 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_landi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function landi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = AND64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function landi64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = AND64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(AND64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(AND64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(AND64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_lori64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function lori64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function lori64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(OR64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(OR64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(OR64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_lxori64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function lxori64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = XOR64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function lxori64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = XOR64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(XOR64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(XOR64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(XOR64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shli64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function shli64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rcx = MOV64rr killed $rsi
    //   $rax = MOV64rr killed $rdi
    //   $cl = KILL killed renamable $cl, implicit killed $rcx
    //   renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $rax
    // 
    // # End machine code for function shli64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    auto cond0 = param_1.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond0)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $rcx = MOV64rr killed $rsi
    // aliasing cx to si
    // cx is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // $cl = KILL killed renamable $cl, implicit killed $rcx
    // KILL is a no-op


    // renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SHL64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHL64rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shri64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function shri64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rcx = MOV64rr killed $rsi
    //   $rax = MOV64rr killed $rdi
    //   $cl = KILL killed renamable $cl, implicit killed $rcx
    //   renamable $rax = SHR64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $rax
    // 
    // # End machine code for function shri64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    auto cond0 = param_1.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond0)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $rcx = MOV64rr killed $rsi
    // aliasing cx to si
    // cx is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // $cl = KILL killed renamable $cl, implicit killed $rcx
    // KILL is a no-op


    // renamable $rax = SHR64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SHR64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHR64rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ashri64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function ashri64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rcx = MOV64rr killed $rsi
    //   $rax = MOV64rr killed $rdi
    //   $cl = KILL killed renamable $cl, implicit killed $rcx
    //   renamable $rax = SAR64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $rax
    // 
    // # End machine code for function ashri64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    auto cond0 = param_1.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond0)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $rcx = MOV64rr killed $rsi
    // aliasing cx to si
    // cx is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // $cl = KILL killed renamable $cl, implicit killed $rcx
    // KILL is a no-op


    // renamable $rax = SAR64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SAR64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SAR64rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_absi64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function absi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   $rax = MOV64rr $rdi
    //   renamable $rax = NEG64r killed renamable $rax(tied-def 0), implicit-def $eflags
    //   renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), killed renamable $rdi, 8, implicit killed $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function absi64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // $rax = MOV64rr $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0


    // renamable $rax = NEG64r killed renamable $rax(tied-def 0), implicit-def $eflags
    {
    if (1) {
        AsmReg inst1_op1 = scratch_ax.alloc_from_bank(0);
        AsmReg inst1_op1_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, inst1_op1, inst1_op1_tmp);
        ASMD(NEG64r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), killed renamable $rdi, 8, implicit killed $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        ASMD(CMOVS64rr, scratch_ax.cur_reg, op2);
    }
    }
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_addi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function addi128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx, $rcx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rcx, $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def $eflags
    //   renamable $rsi = ADC64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags, implicit killed $eflags
    //   $rdx = MOV64rr killed $rsi
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function addi128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    // Mapping cx to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def $eflags
    do {
    {
    auto cond0 = param_2.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(ADD64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_2.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(ADD64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_2.as_reg(this);
        ASMD(ADD64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rsi = ADC64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags, implicit killed $eflags
    do {
    {
    auto cond2 = param_3.encodeable_as_imm32_sext();
    if (cond2) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(ADC64ri, scratch_si.cur_reg, (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_3.encodeable_as_mem();
    if (cond3) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(ADC64rm, scratch_si.cur_reg, (*cond3));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        AsmReg op2 = param_3.as_reg(this);
        ASMD(ADC64rr, scratch_si.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument cx is killed and marked as dead
    // result si is marked as alive


    // $rdx = MOV64rr killed $rsi
    // aliasing dx to si
    // source si is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $rdx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    // dx is an alias for si
    result_1 = std::move(scratch_si);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_subi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function subi128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx, $rcx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rcx, $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = SUB64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def $eflags
    //   renamable $rsi = SBB64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags, implicit killed $eflags
    //   $rdx = MOV64rr killed $rsi
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function subi128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    // Mapping cx to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = SUB64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def $eflags
    do {
    {
    auto cond0 = param_2.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SUB64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_2.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SUB64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_2.as_reg(this);
        ASMD(SUB64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rsi = SBB64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags, implicit killed $eflags
    do {
    {
    auto cond2 = param_3.encodeable_as_imm32_sext();
    if (cond2) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(SBB64ri, scratch_si.cur_reg, (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_3.encodeable_as_mem();
    if (cond3) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(SBB64rm, scratch_si.cur_reg, (*cond3));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        AsmReg op2 = param_3.as_reg(this);
        ASMD(SBB64rr, scratch_si.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument cx is killed and marked as dead
    // result si is marked as alive


    // $rdx = MOV64rr killed $rsi
    // aliasing dx to si
    // source si is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $rdx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    // dx is an alias for si
    result_1 = std::move(scratch_si);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_muli128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function muli128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx, $rcx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rcx, $rdi, $rdx, $rsi
    //   $rax = MOV64rr $rdx
    //   renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed $rdx, implicit-def dead $eflags
    //   MUL64r renamable $rdi, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    //   renamable $rdx = ADD64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    //   renamable $rcx = IMUL64rr killed renamable $rcx(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
    //   renamable $rdx = ADD64rr killed renamable $rdx(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function muli128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    // Mapping cx to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1, &param_2, &param_3}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1, &param_2, &param_3}, reg_backup_dx);


    // $rax = MOV64rr $rdx
    // aliasing ax to dx
    // ax is an alias for operand param_2


    // renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed $rdx, implicit-def dead $eflags
    do {
    {
    auto cond0 = param_2.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(IMUL64rm, scratch_si.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        AsmReg op2 = param_2.as_reg(this);
        ASMD(IMUL64rr, scratch_si.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument dx is killed and marked as dead
    // result si is marked as alive


    // MUL64r renamable $rdi, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    do {
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // fixing reg 0 for cond (cond1)
        AsmReg op4_tmp = param_2.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64m, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_2.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64r, op0);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // renamable $rdx = ADD64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(dx) is the same as its tied destination
        assert(scratch_dx.cur_reg.valid());
        ASMD(ADD64rr, scratch_dx.cur_reg, scratch_si.cur_reg);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead
    // argument si is killed and marked as dead
    // result dx is marked as alive


    // renamable $rcx = IMUL64rr killed renamable $rcx(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
    do {
    {
    auto cond2 = param_0.encodeable_as_mem();
    if (cond2) {
        // operand 1(param_3) is tied so try to salvage or materialize
        param_3.try_salvage_or_materialize(this, scratch_cx, 0, 8);
        ASMD(IMUL64rm, scratch_cx.cur_reg, (*cond2));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_3) is tied so try to salvage or materialize
        param_3.try_salvage_or_materialize(this, scratch_cx, 0, 8);
        AsmReg op2 = param_0.as_reg(this);
        ASMD(IMUL64rr, scratch_cx.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument di is killed and marked as dead
    // result cx is marked as alive


    // renamable $rdx = ADD64rr killed renamable $rdx(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(dx) is the same as its tied destination
        assert(scratch_dx.cur_reg.valid());
        ASMD(ADD64rr, scratch_dx.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead
    // argument cx is killed and marked as dead
    // result dx is marked as alive


    // RET64 killed $rax, killed $rdx
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, true);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_landi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function landi128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx, $rcx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rcx, $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = AND64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def dead $eflags
    //   renamable $rsi = AND64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   $rdx = MOV64rr killed $rsi
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function landi128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    // Mapping cx to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = AND64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def dead $eflags
    do {
    {
    auto cond0 = param_2.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(AND64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_2.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(AND64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_2.as_reg(this);
        ASMD(AND64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rsi = AND64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    do {
    {
    auto cond2 = param_3.encodeable_as_imm32_sext();
    if (cond2) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(AND64ri, scratch_si.cur_reg, (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_3.encodeable_as_mem();
    if (cond3) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(AND64rm, scratch_si.cur_reg, (*cond3));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        AsmReg op2 = param_3.as_reg(this);
        ASMD(AND64rr, scratch_si.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument cx is killed and marked as dead
    // result si is marked as alive


    // $rdx = MOV64rr killed $rsi
    // aliasing dx to si
    // source si is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $rdx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    // dx is an alias for si
    result_1 = std::move(scratch_si);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_lori128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function lori128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx, $rcx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rcx, $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def dead $eflags
    //   renamable $rsi = OR64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   $rdx = MOV64rr killed $rsi
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function lori128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    // Mapping cx to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def dead $eflags
    do {
    {
    auto cond0 = param_2.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(OR64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_2.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(OR64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_2.as_reg(this);
        ASMD(OR64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rsi = OR64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    do {
    {
    auto cond2 = param_3.encodeable_as_imm32_sext();
    if (cond2) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(OR64ri, scratch_si.cur_reg, (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_3.encodeable_as_mem();
    if (cond3) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(OR64rm, scratch_si.cur_reg, (*cond3));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        AsmReg op2 = param_3.as_reg(this);
        ASMD(OR64rr, scratch_si.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument cx is killed and marked as dead
    // result si is marked as alive


    // $rdx = MOV64rr killed $rsi
    // aliasing dx to si
    // source si is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $rdx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    // dx is an alias for si
    result_1 = std::move(scratch_si);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_lxori128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function lxori128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx, $rcx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rcx, $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = XOR64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def dead $eflags
    //   renamable $rsi = XOR64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   $rdx = MOV64rr killed $rsi
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function lxori128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    // Mapping cx to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = XOR64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def dead $eflags
    do {
    {
    auto cond0 = param_2.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(XOR64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_2.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(XOR64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_2.as_reg(this);
        ASMD(XOR64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rsi = XOR64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    do {
    {
    auto cond2 = param_3.encodeable_as_imm32_sext();
    if (cond2) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(XOR64ri, scratch_si.cur_reg, (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_3.encodeable_as_mem();
    if (cond3) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(XOR64rm, scratch_si.cur_reg, (*cond3));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        AsmReg op2 = param_3.as_reg(this);
        ASMD(XOR64rr, scratch_si.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument cx is killed and marked as dead
    // result si is marked as alive


    // $rdx = MOV64rr killed $rsi
    // aliasing dx to si
    // source si is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $rdx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    // dx is an alias for si
    result_1 = std::move(scratch_si);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shli128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function shli128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rdi, $rdx, $rsi
    //   $r8 = MOV64rr killed $rdx
    //   $ecx = MOV32rr undef $r8d, implicit $r8b
    //   renamable $rsi = SHL64rCL killed renamable $rsi(tied-def 0), implicit-def dead $eflags, implicit $cl
    //   $rdx = MOV64rr $rdi
    //   renamable $rdx = SHR64ri killed renamable $rdx(tied-def 0), 1, implicit-def dead $eflags
    //   renamable $cl = NOT8r killed renamable $cl(tied-def 0)
    //   renamable $rdx = SHR64rCL killed renamable $rdx(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   renamable $rdx = OR64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    //   $ecx = MOV32rr undef $r8d, implicit $r8b
    //   renamable $rdi = SHL64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $rax
    //   TEST8ri killed renamable $r8b, 64, implicit-def $eflags, implicit killed $r8
    //   renamable $rdx = CMOV64rr killed renamable $rdx(tied-def 0), renamable $rdi, 5, implicit $eflags
    //   renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), killed renamable $rdi, 4, implicit killed $eflags
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function shli128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    ScratchReg scratch_r8{derived()};
    auto cond0 = param_2.encodeable_as_imm32_sext();;
    auto cond1 = param_2.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond0)&&1) || (!(0)&&1) || (!(0||cond1)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1, &param_2}, reg_backup_cx);
    }


    // $r8 = MOV64rr killed $rdx
    // aliasing r8 to dx
    // r8 is an alias for operand param_2
    // source dx is killed, all aliases redirected and marked as dead


    // $ecx = MOV32rr undef $r8d, implicit $r8b
    // aliasing cx to r8
    // cx is an alias for operand param_2


    // renamable $rsi = SHL64rCL killed renamable $rsi(tied-def 0), implicit-def dead $eflags, implicit $cl
    do {
    {
    if (cond0) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(SHL64ri, scratch_si.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHL64rr, scratch_si.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // result si is marked as alive


    // $rdx = MOV64rr $rdi
    // aliasing dx to di
    // dx is an alias for operand param_0


    // renamable $rdx = SHR64ri killed renamable $rdx(tied-def 0), 1, implicit-def dead $eflags
    {
    if (1) {
        AsmReg inst4_op1 = scratch_dx.alloc_from_bank(0);
        AsmReg inst4_op1_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, inst4_op1, inst4_op1_tmp);
        ASMD(SHR64ri, scratch_dx.cur_reg, 0x1);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive


    // renamable $cl = NOT8r killed renamable $cl(tied-def 0)
    {
    if (1) {
        AsmReg inst5_op1 = scratch_cx.alloc_from_bank(0);
        AsmReg inst5_op1_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, inst5_op1, inst5_op1_tmp);
        ASMD(NOT8r, scratch_cx.cur_reg);
    }
    }
    // argument cx is killed and marked as dead
    // result cx is marked as alive


    // renamable $rdx = SHR64rCL killed renamable $rdx(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (1) {
        // operand 1(dx) is the same as its tied destination
        assert(scratch_dx.cur_reg.valid());
        // fixing reg 1 for cond ()
        ASMD(SHR64rr, scratch_dx.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead
    // argument cx is killed and marked as dead
    // result dx is marked as alive


    // renamable $rdx = OR64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(dx) is the same as its tied destination
        assert(scratch_dx.cur_reg.valid());
        ASMD(OR64rr, scratch_dx.cur_reg, scratch_si.cur_reg);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead
    // argument si is killed and marked as dead
    // result dx is marked as alive


    // $ecx = MOV32rr undef $r8d, implicit $r8b
    // aliasing cx to r8
    // cx is an alias for operand param_2


    // renamable $rdi = SHL64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        ASMD(SHL64ri, scratch_di.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHL64rr, scratch_di.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument cx is killed and marked as dead
    // result di is marked as alive


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $rax
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst10_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst10_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive
    // result ax is marked as alive


    // TEST8ri killed renamable $r8b, 64, implicit-def $eflags, implicit killed $r8
    do {
    {
    auto cond2 = param_2.encodeable_as_mem();
    if (cond2) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8mi, (*cond2), 0x40);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_2.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8ri, op0, 0x40);
        break;
    }
    }
    } while (false);
    // argument r8 is killed and marked as dead
    // argument r8 is killed and marked as dead


    // renamable $rdx = CMOV64rr killed renamable $rdx(tied-def 0), renamable $rdi, 5, implicit $eflags
    {
    if (1) {
        // operand 1(dx) is the same as its tied destination
        assert(scratch_dx.cur_reg.valid());
        ASMD(CMOVNZ64rr, scratch_dx.cur_reg, scratch_di.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive


    // renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), killed renamable $rdi, 4, implicit killed $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(CMOVZ64rr, scratch_ax.cur_reg, scratch_di.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax, killed $rdx
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shri128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function shri128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rdi, $rdx, $rsi
    //   $r8 = MOV64rr killed $rdx
    //   $ecx = MOV32rr undef $r8d, implicit $r8b
    //   renamable $rdi = SHR64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit $cl
    //   renamable $rax = LEA64r renamable $rsi, 1, renamable $rsi, 0, $noreg
    //   renamable $cl = NOT8r killed renamable $cl(tied-def 0)
    //   renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
    //   $ecx = MOV32rr undef $r8d, implicit $r8b
    //   renamable $rsi = SHR64rCL killed renamable $rsi(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags, implicit-def $rdx
    //   TEST8ri killed renamable $r8b, 64, implicit-def $eflags, implicit killed $r8
    //   renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), renamable $rsi, 5, implicit $eflags
    //   renamable $rdx = CMOV64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, 4, implicit killed $eflags
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function shri128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    ScratchReg scratch_r8{derived()};
    auto cond0 = param_2.encodeable_as_imm32_sext();;
    auto cond3 = param_2.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond0)&&1) || (!(0)&&1) || (!(0||cond3)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1, &param_2}, reg_backup_cx);
    }


    // $r8 = MOV64rr killed $rdx
    // aliasing r8 to dx
    // r8 is an alias for operand param_2
    // source dx is killed, all aliases redirected and marked as dead


    // $ecx = MOV32rr undef $r8d, implicit $r8b
    // aliasing cx to r8
    // cx is an alias for operand param_2


    // renamable $rdi = SHR64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit $cl
    do {
    {
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        ASMD(SHR64ri, scratch_di.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHR64rr, scratch_di.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result di is marked as alive


    // renamable $rax = LEA64r renamable $rsi, 1, renamable $rsi, 0, $noreg
    do {
    {
    auto cond1 = param_1.encodeable_with(FE_MEM(FE_NOREG, 1, FE_AX, 0));
    if (cond1) {
        AsmReg op3 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA64rm, scratch_ax.cur_reg, FE_MEM((*cond1).base, (*cond1).scale, op3, (*cond1).off));
        break;
    }
    }
    {
    auto cond2 = param_1.encodeable_with(FE_MEM(FE_AX, 0, FE_NOREG, 0));
    if (cond2) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA64rm, scratch_ax.cur_reg, FE_MEM(op1, (*cond2).scale, (*cond2).idx, (*cond2).off));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        AsmReg op3 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA64rm, scratch_ax.cur_reg, FE_MEM(op1, 1, op3, 0));
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // renamable $cl = NOT8r killed renamable $cl(tied-def 0)
    {
    if (1) {
        AsmReg inst4_op1 = scratch_cx.alloc_from_bank(0);
        AsmReg inst4_op1_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, inst4_op1, inst4_op1_tmp);
        ASMD(NOT8r, scratch_cx.cur_reg);
    }
    }
    // argument cx is killed and marked as dead
    // result cx is marked as alive


    // renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // fixing reg 1 for cond ()
        ASMD(SHL64rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(OR64rr, scratch_ax.cur_reg, scratch_di.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // $ecx = MOV32rr undef $r8d, implicit $r8b
    // aliasing cx to r8
    // cx is an alias for operand param_2


    // renamable $rsi = SHR64rCL killed renamable $rsi(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (cond3) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(SHR64ri, scratch_si.cur_reg, (*cond3));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHR64rr, scratch_si.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument cx is killed and marked as dead
    // result si is marked as alive


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags, implicit-def $rdx
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst9_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst9_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive
    // result dx is marked as alive


    // TEST8ri killed renamable $r8b, 64, implicit-def $eflags, implicit killed $r8
    do {
    {
    auto cond4 = param_2.encodeable_as_mem();
    if (cond4) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8mi, (*cond4), 0x40);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_2.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8ri, op0, 0x40);
        break;
    }
    }
    } while (false);
    // argument r8 is killed and marked as dead
    // argument r8 is killed and marked as dead


    // renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), renamable $rsi, 5, implicit $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(CMOVNZ64rr, scratch_ax.cur_reg, scratch_si.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $rdx = CMOV64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, 4, implicit killed $eflags
    {
    if (1) {
        // operand 1(dx) is the same as its tied destination
        assert(scratch_dx.cur_reg.valid());
        ASMD(CMOVZ64rr, scratch_dx.cur_reg, scratch_si.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // argument si is killed and marked as dead
    // result dx is marked as alive


    // RET64 killed $rax, killed $rdx
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ashri128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function ashri128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rdi, $rdx, $rsi
    //   $r8 = MOV64rr killed $rdx
    //   $ecx = MOV32rr undef $r8d, implicit $r8b
    //   renamable $rdi = SHR64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit $cl
    //   renamable $rax = LEA64r renamable $rsi, 1, renamable $rsi, 0, $noreg
    //   renamable $cl = NOT8r killed renamable $cl(tied-def 0)
    //   renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
    //   $rdx = MOV64rr $rsi
    //   $ecx = MOV32rr undef $r8d, implicit $r8b
    //   renamable $rdx = SAR64rCL killed renamable $rdx(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   renamable $rsi = SAR64ri killed renamable $rsi(tied-def 0), 63, implicit-def dead $eflags
    //   TEST8ri killed renamable $r8b, 64, implicit-def $eflags, implicit killed $r8
    //   renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), renamable $rdx, 5, implicit $eflags
    //   renamable $rdx = CMOV64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, 5, implicit killed $eflags
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function ashri128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    ScratchReg scratch_r8{derived()};
    auto cond0 = param_2.encodeable_as_imm32_sext();;
    auto cond3 = param_2.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond0)&&1) || (!(0)&&1) || (!(0||cond3)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1, &param_2}, reg_backup_cx);
    }


    // $r8 = MOV64rr killed $rdx
    // aliasing r8 to dx
    // r8 is an alias for operand param_2
    // source dx is killed, all aliases redirected and marked as dead


    // $ecx = MOV32rr undef $r8d, implicit $r8b
    // aliasing cx to r8
    // cx is an alias for operand param_2


    // renamable $rdi = SHR64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit $cl
    do {
    {
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        ASMD(SHR64ri, scratch_di.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHR64rr, scratch_di.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result di is marked as alive


    // renamable $rax = LEA64r renamable $rsi, 1, renamable $rsi, 0, $noreg
    do {
    {
    auto cond1 = param_1.encodeable_with(FE_MEM(FE_NOREG, 1, FE_AX, 0));
    if (cond1) {
        AsmReg op3 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA64rm, scratch_ax.cur_reg, FE_MEM((*cond1).base, (*cond1).scale, op3, (*cond1).off));
        break;
    }
    }
    {
    auto cond2 = param_1.encodeable_with(FE_MEM(FE_AX, 0, FE_NOREG, 0));
    if (cond2) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA64rm, scratch_ax.cur_reg, FE_MEM(op1, (*cond2).scale, (*cond2).idx, (*cond2).off));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        AsmReg op3 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA64rm, scratch_ax.cur_reg, FE_MEM(op1, 1, op3, 0));
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // renamable $cl = NOT8r killed renamable $cl(tied-def 0)
    {
    if (1) {
        AsmReg inst4_op1 = scratch_cx.alloc_from_bank(0);
        AsmReg inst4_op1_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, inst4_op1, inst4_op1_tmp);
        ASMD(NOT8r, scratch_cx.cur_reg);
    }
    }
    // argument cx is killed and marked as dead
    // result cx is marked as alive


    // renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // fixing reg 1 for cond ()
        ASMD(SHL64rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(OR64rr, scratch_ax.cur_reg, scratch_di.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // $rdx = MOV64rr $rsi
    // aliasing dx to si
    // dx is an alias for operand param_1


    // $ecx = MOV32rr undef $r8d, implicit $r8b
    // aliasing cx to r8
    // cx is an alias for operand param_2


    // renamable $rdx = SAR64rCL killed renamable $rdx(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (cond3) {
        AsmReg inst9_op1 = scratch_dx.alloc_from_bank(0);
        AsmReg inst9_op1_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, inst9_op1, inst9_op1_tmp);
        ASMD(SAR64ri, scratch_dx.cur_reg, (*cond3));
        break;
    }
    }
    {
    if (1) {
        AsmReg inst9_op1 = scratch_dx.alloc_from_bank(0);
        AsmReg inst9_op1_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, inst9_op1, inst9_op1_tmp);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SAR64rr, scratch_dx.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead
    // argument cx is killed and marked as dead
    // result dx is marked as alive


    // renamable $rsi = SAR64ri killed renamable $rsi(tied-def 0), 63, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(SAR64ri, scratch_si.cur_reg, 0x3f);
    }
    }
    // argument si is killed and marked as dead
    // result si is marked as alive


    // TEST8ri killed renamable $r8b, 64, implicit-def $eflags, implicit killed $r8
    do {
    {
    auto cond4 = param_2.encodeable_as_mem();
    if (cond4) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8mi, (*cond4), 0x40);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_2.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8ri, op0, 0x40);
        break;
    }
    }
    } while (false);
    // argument r8 is killed and marked as dead
    // argument r8 is killed and marked as dead


    // renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), renamable $rdx, 5, implicit $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(CMOVNZ64rr, scratch_ax.cur_reg, scratch_dx.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $rdx = CMOV64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, 5, implicit killed $eflags
    {
    if (1) {
        // operand 1(dx) is the same as its tied destination
        assert(scratch_dx.cur_reg.valid());
        ASMD(CMOVNZ64rr, scratch_dx.cur_reg, scratch_si.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // argument si is killed and marked as dead
    // result dx is marked as alive


    // RET64 killed $rax, killed $rdx
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shli128_lt64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function shli128_lt64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdi, $rdx, $rsi
    //   $rcx = MOV64rr killed $rdx
    //   $rax = MOV64rr $rdi
    //   renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit $cl
    //   renamable $rsi = SHL64rCL killed renamable $rsi(tied-def 0), implicit-def dead $eflags, implicit $cl
    //   renamable $rdi = SHR64ri killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
    //   renamable $cl = NOT8r killed renamable $cl(tied-def 0), implicit killed $rcx, implicit-def $rcx
    //   $cl = KILL killed renamable $cl, implicit killed $rcx
    //   renamable $rdi = SHR64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   renamable $rdi = OR64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    //   $rdx = MOV64rr killed $rdi
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function shli128_lt64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    auto cond0 = param_2.encodeable_as_imm32_sext();;
    auto cond1 = param_2.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond0)&&1) || (!(0||cond1)&&1) || (!(0)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1, &param_2}, reg_backup_cx);
    }


    // $rcx = MOV64rr killed $rdx
    // aliasing cx to dx
    // cx is an alias for operand param_2
    // source dx is killed, all aliases redirected and marked as dead


    // $rax = MOV64rr $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0


    // renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit $cl
    do {
    {
    if (cond0) {
        AsmReg inst2_op1 = scratch_ax.alloc_from_bank(0);
        AsmReg inst2_op1_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, inst2_op1, inst2_op1_tmp);
        ASMD(SHL64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg inst2_op1 = scratch_ax.alloc_from_bank(0);
        AsmReg inst2_op1_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, inst2_op1, inst2_op1_tmp);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHL64rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $rsi = SHL64rCL killed renamable $rsi(tied-def 0), implicit-def dead $eflags, implicit $cl
    do {
    {
    if (cond1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        ASMD(SHL64ri, scratch_si.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHL64rr, scratch_si.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // result si is marked as alive


    // renamable $rdi = SHR64ri killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        ASMD(SHR64ri, scratch_di.cur_reg, 0x1);
    }
    }
    // argument di is killed and marked as dead
    // result di is marked as alive


    // renamable $cl = NOT8r killed renamable $cl(tied-def 0), implicit killed $rcx, implicit-def $rcx
    {
    if (1) {
        // operand 1(param_2) is tied so try to salvage or materialize
        param_2.try_salvage_or_materialize(this, scratch_cx, 0, 1);
        // operand exceeds NumImplicitUses, ignore
        ASMD(NOT8r, scratch_cx.cur_reg);
    }
    }
    // argument cx is killed and marked as dead
    // argument cx is killed and marked as dead
    // result cx is marked as alive
    // result cx is marked as alive


    // $cl = KILL killed renamable $cl, implicit killed $rcx
    // KILL is a no-op


    // renamable $rdi = SHR64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (1) {
        // operand 1(di) is the same as its tied destination
        assert(scratch_di.cur_reg.valid());
        // fixing reg 1 for cond ()
        ASMD(SHR64rr, scratch_di.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument cx is killed and marked as dead
    // result di is marked as alive


    // renamable $rdi = OR64rr killed renamable $rdi(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(di) is the same as its tied destination
        assert(scratch_di.cur_reg.valid());
        ASMD(OR64rr, scratch_di.cur_reg, scratch_si.cur_reg);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // result di is marked as alive


    // $rdx = MOV64rr killed $rdi
    // aliasing dx to di
    // source di is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $rdx
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    // dx is an alias for di
    result_1 = std::move(scratch_di);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shli128_ge64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function shli128_ge64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdi, $rdx
    //   $rcx = MOV64rr killed $rdx
    //   $rax = MOV64rr killed $rdi
    //   $cl = KILL killed renamable $cl, implicit killed $rcx
    //   renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags, implicit-def $rdx
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function shli128_ge64.
    // 

    // Mapping di to param_0
    // Mapping dx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};
    auto cond0 = param_1.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond0)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $rcx = MOV64rr killed $rdx
    // aliasing cx to dx
    // cx is an alias for operand param_1
    // source dx is killed, all aliases redirected and marked as dead


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // $cl = KILL killed renamable $cl, implicit killed $rcx
    // KILL is a no-op


    // renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SHL64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHL64rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags, implicit-def $rdx
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst4_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst4_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive
    // result dx is marked as alive


    // RET64 killed $rax, killed $rdx
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shri128_lt64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function shri128_lt64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdi, $rdx, $rsi
    //   $rcx = MOV64rr killed $rdx
    //   renamable $rax = LEA64r renamable $rsi, 1, renamable $rsi, 0, $noreg
    //   $rdx = MOV64rr killed $rsi
    //   renamable $rdx = SHR64rCL killed renamable $rdx(tied-def 0), implicit-def dead $eflags, implicit $cl
    //   renamable $rdi = SHR64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit $cl
    //   renamable $cl = NOT8r killed renamable $cl(tied-def 0), implicit killed $rcx, implicit-def $rcx
    //   $cl = KILL killed renamable $cl, implicit killed $rcx
    //   renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function shri128_lt64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    auto cond2 = param_2.encodeable_as_imm32_sext();;
    auto cond3 = param_2.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond2)&&1) || (!(0||cond3)&&1) || (!(0)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1, &param_2}, reg_backup_cx);
    }


    // $rcx = MOV64rr killed $rdx
    // aliasing cx to dx
    // cx is an alias for operand param_2
    // source dx is killed, all aliases redirected and marked as dead


    // renamable $rax = LEA64r renamable $rsi, 1, renamable $rsi, 0, $noreg
    do {
    {
    auto cond0 = param_1.encodeable_with(FE_MEM(FE_NOREG, 1, FE_AX, 0));
    if (cond0) {
        AsmReg op3 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA64rm, scratch_ax.cur_reg, FE_MEM((*cond0).base, (*cond0).scale, op3, (*cond0).off));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_with(FE_MEM(FE_AX, 0, FE_NOREG, 0));
    if (cond1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA64rm, scratch_ax.cur_reg, FE_MEM(op1, (*cond1).scale, (*cond1).idx, (*cond1).off));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        AsmReg op3 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA64rm, scratch_ax.cur_reg, FE_MEM(op1, 1, op3, 0));
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // $rdx = MOV64rr killed $rsi
    // aliasing dx to si
    // dx is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // renamable $rdx = SHR64rCL killed renamable $rdx(tied-def 0), implicit-def dead $eflags, implicit $cl
    do {
    {
    if (cond2) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_dx, 0, 8);
        ASMD(SHR64ri, scratch_dx.cur_reg, (*cond2));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_dx, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHR64rr, scratch_dx.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead
    // result dx is marked as alive


    // renamable $rdi = SHR64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit $cl
    do {
    {
    if (cond3) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        ASMD(SHR64ri, scratch_di.cur_reg, (*cond3));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHR64rr, scratch_di.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result di is marked as alive


    // renamable $cl = NOT8r killed renamable $cl(tied-def 0), implicit killed $rcx, implicit-def $rcx
    {
    if (1) {
        // operand 1(param_2) is tied so try to salvage or materialize
        param_2.try_salvage_or_materialize(this, scratch_cx, 0, 1);
        // operand exceeds NumImplicitUses, ignore
        ASMD(NOT8r, scratch_cx.cur_reg);
    }
    }
    // argument cx is killed and marked as dead
    // argument cx is killed and marked as dead
    // result cx is marked as alive
    // result cx is marked as alive


    // $cl = KILL killed renamable $cl, implicit killed $rcx
    // KILL is a no-op


    // renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // fixing reg 1 for cond ()
        ASMD(SHL64rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(OR64rr, scratch_ax.cur_reg, scratch_di.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax, killed $rdx
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_shri128_ge64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function shri128_ge64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdx, $rsi
    //   $rcx = MOV64rr killed $rdx
    //   $rax = MOV64rr killed $rsi
    //   $cl = KILL killed renamable $cl, implicit killed $rcx
    //   renamable $rax = SHR64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags, implicit-def $rdx
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function shri128_ge64.
    // 

    // Mapping si to param_0
    // Mapping dx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    auto cond0 = param_1.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond0)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $rcx = MOV64rr killed $rdx
    // aliasing cx to dx
    // cx is an alias for operand param_1
    // source dx is killed, all aliases redirected and marked as dead


    // $rax = MOV64rr killed $rsi
    // aliasing ax to si
    // ax is an alias for operand param_0
    // source si is killed, all aliases redirected and marked as dead


    // $cl = KILL killed renamable $cl, implicit killed $rcx
    // KILL is a no-op


    // renamable $rax = SHR64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SHR64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHR64rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags, implicit-def $rdx
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst4_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst4_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive
    // result dx is marked as alive


    // RET64 killed $rax, killed $rdx
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ashri128_lt64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function ashri128_lt64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdi, $rdx, $rsi
    //   $rcx = MOV64rr killed $rdx
    //   renamable $rax = LEA64r renamable $rsi, 1, renamable $rsi, 0, $noreg
    //   $rdx = MOV64rr killed $rsi
    //   renamable $rdx = SAR64rCL killed renamable $rdx(tied-def 0), implicit-def dead $eflags, implicit $cl
    //   renamable $rdi = SHR64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit $cl
    //   renamable $cl = NOT8r killed renamable $cl(tied-def 0), implicit killed $rcx, implicit-def $rcx
    //   $cl = KILL killed renamable $cl, implicit killed $rcx
    //   renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function ashri128_lt64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    auto cond2 = param_2.encodeable_as_imm32_sext();;
    auto cond3 = param_2.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond2)&&1) || (!(0||cond3)&&1) || (!(0)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1, &param_2}, reg_backup_cx);
    }


    // $rcx = MOV64rr killed $rdx
    // aliasing cx to dx
    // cx is an alias for operand param_2
    // source dx is killed, all aliases redirected and marked as dead


    // renamable $rax = LEA64r renamable $rsi, 1, renamable $rsi, 0, $noreg
    do {
    {
    auto cond0 = param_1.encodeable_with(FE_MEM(FE_NOREG, 1, FE_AX, 0));
    if (cond0) {
        AsmReg op3 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA64rm, scratch_ax.cur_reg, FE_MEM((*cond0).base, (*cond0).scale, op3, (*cond0).off));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_with(FE_MEM(FE_AX, 0, FE_NOREG, 0));
    if (cond1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA64rm, scratch_ax.cur_reg, FE_MEM(op1, (*cond1).scale, (*cond1).idx, (*cond1).off));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        AsmReg op3 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(LEA64rm, scratch_ax.cur_reg, FE_MEM(op1, 1, op3, 0));
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // $rdx = MOV64rr killed $rsi
    // aliasing dx to si
    // dx is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // renamable $rdx = SAR64rCL killed renamable $rdx(tied-def 0), implicit-def dead $eflags, implicit $cl
    do {
    {
    if (cond2) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_dx, 0, 8);
        ASMD(SAR64ri, scratch_dx.cur_reg, (*cond2));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_dx, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SAR64rr, scratch_dx.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead
    // result dx is marked as alive


    // renamable $rdi = SHR64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit $cl
    do {
    {
    if (cond3) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        ASMD(SHR64ri, scratch_di.cur_reg, (*cond3));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHR64rr, scratch_di.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result di is marked as alive


    // renamable $cl = NOT8r killed renamable $cl(tied-def 0), implicit killed $rcx, implicit-def $rcx
    {
    if (1) {
        // operand 1(param_2) is tied so try to salvage or materialize
        param_2.try_salvage_or_materialize(this, scratch_cx, 0, 1);
        // operand exceeds NumImplicitUses, ignore
        ASMD(NOT8r, scratch_cx.cur_reg);
    }
    }
    // argument cx is killed and marked as dead
    // argument cx is killed and marked as dead
    // result cx is marked as alive
    // result cx is marked as alive


    // $cl = KILL killed renamable $cl, implicit killed $rcx
    // KILL is a no-op


    // renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // fixing reg 1 for cond ()
        ASMD(SHL64rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(OR64rr, scratch_ax.cur_reg, scratch_di.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax, killed $rdx
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ashri128_ge64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function ashri128_ge64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdx, $rsi
    //   $rcx = MOV64rr killed $rdx
    //   $rax = MOV64rr $rsi
    //   $rdx = MOV64rr killed $rsi
    //   renamable $rdx = SAR64ri killed renamable $rdx(tied-def 0), 63, implicit-def dead $eflags
    //   $cl = KILL killed renamable $cl, implicit killed $rcx
    //   renamable $rax = SAR64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function ashri128_ge64.
    // 

    // Mapping si to param_0
    // Mapping dx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    auto cond0 = param_1.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond0)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $rcx = MOV64rr killed $rdx
    // aliasing cx to dx
    // cx is an alias for operand param_1
    // source dx is killed, all aliases redirected and marked as dead


    // $rax = MOV64rr $rsi
    // aliasing ax to si
    // ax is an alias for operand param_0


    // $rdx = MOV64rr killed $rsi
    // aliasing dx to si
    // dx is an alias for operand param_0
    // source si is killed, all aliases redirected and marked as dead


    // renamable $rdx = SAR64ri killed renamable $rdx(tied-def 0), 63, implicit-def dead $eflags
    {
    if (1) {
        AsmReg inst3_op1 = scratch_dx.alloc_from_bank(0);
        AsmReg inst3_op1_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, inst3_op1, inst3_op1_tmp);
        ASMD(SAR64ri, scratch_dx.cur_reg, 0x3f);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive


    // $cl = KILL killed renamable $cl, implicit killed $rcx
    // KILL is a no-op


    // renamable $rax = SAR64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SAR64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SAR64rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax, killed $rdx
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cttzi32_zero_poison(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function cttzi32_zero_poison: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = BSF32rr killed renamable $edi, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function cttzi32_zero_poison.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = BSF32rr killed renamable $edi, implicit-def dead $eflags
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(BSF32rr, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cttzi64_zero_poison(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function cttzi64_zero_poison: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $rax = BSF64rr killed renamable $rdi, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function cttzi64_zero_poison.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $rax = BSF64rr killed renamable $rdi, implicit-def dead $eflags
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(BSF64rr, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cttzi8(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function cttzi8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $edi = OR32ri killed renamable $edi(tied-def 0), 256, implicit-def dead $eflags
    //   renamable $eax = BSF32rr killed renamable $edi, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function cttzi8.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $edi = OR32ri killed renamable $edi(tied-def 0), 256, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 4);
        ASMD(OR32ri, scratch_di.cur_reg, 0x100);
    }
    }
    // argument di is killed and marked as dead
    // result di is marked as alive


    // renamable $eax = BSF32rr killed renamable $edi, implicit-def dead $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(BSF32rr, scratch_ax.cur_reg, scratch_di.cur_reg);
    }
    }
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cttzi16(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function cttzi16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $edi = OR32ri killed renamable $edi(tied-def 0), 65536, implicit-def dead $eflags
    //   renamable $eax = BSF32rr killed renamable $edi, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function cttzi16.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $edi = OR32ri killed renamable $edi(tied-def 0), 65536, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 4);
        ASMD(OR32ri, scratch_di.cur_reg, 0x10000);
    }
    }
    // argument di is killed and marked as dead
    // result di is marked as alive


    // renamable $eax = BSF32rr killed renamable $edi, implicit-def dead $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(BSF32rr, scratch_ax.cur_reg, scratch_di.cur_reg);
    }
    }
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cttzi32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function cttzi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   successors: %bb.2(0x30000000), %bb.1(0x50000000); %bb.2(37.50%), %bb.1(62.50%)
    //   liveins: $edi
    //   TEST32rr renamable $edi, renamable $edi, implicit-def $eflags
    //   JCC_1 %bb.2, 4, implicit killed $eflags
    // 
    // bb.1.cond.false:
    // ; predecessors: %bb.0
    //   liveins: $edi
    //   renamable $eax = BSF32rr killed renamable $edi, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // bb.2.cond.end:
    // ; predecessors: %bb.0
    // 
    //   $eax = MOV32ri 32
    //   RET64 killed $eax
    // 
    // # End machine code for function cttzi32.
    // 

    // Mapping di to param_0

    // Creating label for convergence point at the end of the function
    Label ret_converge_label = derived()->assembler.label_create();
    // Creating labels for blocks that are jump targets
    Label block1_label = derived()->assembler.label_create();
    Label block2_label = derived()->assembler.label_create();

    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // TEST32rr renamable $edi, renamable $edi, implicit-def $eflags
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(TEST32ri, op0, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(TEST32mr, (*cond1), op1);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(TEST32rr, op0, op1);
        break;
    }
    }
    } while (false);


    // JCC_1 %bb.2, 4, implicit killed $eflags
    // Preparing jump to other block
    // di is live-out
    // ax is used in the function later on
    // Handling register ax
    // ax is not live-out and needs to be allocated
    scratch_ax.alloc_from_bank(0);
    // Handling register di
    // di is mapped to operand param_0, materializing it
    param_0.try_salvage_or_materialize(this, scratch_di, 0, 4);
    derived()->generate_raw_jump(CompilerX64::Jump::je, block2_label);


    // Starting encoding of block 1
    derived()->assembler.label_place(block1_label);
    // Marking di as live


    // renamable $eax = BSF32rr killed renamable $edi, implicit-def dead $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(BSF32rr, scratch_ax.cur_reg, scratch_di.cur_reg);
    }
    }
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // handling return for ax
    // value already in register, nothing to do
    // Jumping to convergence point at the end of the encoding function
    derived()->generate_raw_jump(CompilerX64::Jump::jmp, ret_converge_label);

    // Starting encoding of block 2
    derived()->assembler.label_place(block2_label);


    // $eax = MOV32ri 32
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32ri, scratch_ax.cur_reg, 0x20);
    }
    }
    // result ax is marked as alive


    // RET64 killed $eax
    // handling return for ax
    // value already in register, nothing to do
    // Omitting jump to convergence as this is the last block

    // Placing the convergence point for registers here
    derived()->assembler.label_place(ret_converge_label);
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cttzi64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function cttzi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   successors: %bb.2(0x30000000), %bb.1(0x50000000); %bb.2(37.50%), %bb.1(62.50%)
    //   liveins: $rdi
    //   TEST64rr renamable $rdi, renamable $rdi, implicit-def $eflags
    //   JCC_1 %bb.2, 4, implicit killed $eflags
    // 
    // bb.1.cond.false:
    // ; predecessors: %bb.0
    //   liveins: $rdi
    //   renamable $rax = BSF64rr killed renamable $rdi, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // bb.2.cond.end:
    // ; predecessors: %bb.0
    // 
    //   $eax = MOV32ri 64, implicit-def $rax
    //   RET64 killed $rax
    // 
    // # End machine code for function cttzi64.
    // 

    // Mapping di to param_0

    // Creating label for convergence point at the end of the function
    Label ret_converge_label = derived()->assembler.label_create();
    // Creating labels for blocks that are jump targets
    Label block1_label = derived()->assembler.label_create();
    Label block2_label = derived()->assembler.label_create();

    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // TEST64rr renamable $rdi, renamable $rdi, implicit-def $eflags
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(TEST64ri, op0, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(TEST64mr, (*cond1), op1);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(TEST64rr, op0, op1);
        break;
    }
    }
    } while (false);


    // JCC_1 %bb.2, 4, implicit killed $eflags
    // Preparing jump to other block
    // di is live-out
    // ax is used in the function later on
    // Handling register ax
    // ax is not live-out and needs to be allocated
    scratch_ax.alloc_from_bank(0);
    // Handling register di
    // di is mapped to operand param_0, materializing it
    param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
    derived()->generate_raw_jump(CompilerX64::Jump::je, block2_label);


    // Starting encoding of block 1
    derived()->assembler.label_place(block1_label);
    // Marking di as live


    // renamable $rax = BSF64rr killed renamable $rdi, implicit-def dead $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(BSF64rr, scratch_ax.cur_reg, scratch_di.cur_reg);
    }
    }
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // handling return for ax
    // value already in register, nothing to do
    // Jumping to convergence point at the end of the encoding function
    derived()->generate_raw_jump(CompilerX64::Jump::jmp, ret_converge_label);

    // Starting encoding of block 2
    derived()->assembler.label_place(block2_label);


    // $eax = MOV32ri 64, implicit-def $rax
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32ri, scratch_ax.cur_reg, 0x40);
    }
    }
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $rax
    // handling return for ax
    // value already in register, nothing to do
    // Omitting jump to convergence as this is the last block

    // Placing the convergence point for registers here
    derived()->assembler.label_place(ret_converge_label);
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ctlzi8_zero_poison(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function ctlzi8_zero_poison: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVZX32rr8 killed renamable $dil, implicit killed $edi
    //   renamable $eax = BSR32rr killed renamable $eax, implicit-def dead $eflags
    //   renamable $eax = XOR32ri killed renamable $eax(tied-def 0), 31, implicit-def dead $eflags
    //   renamable $eax = nsw ADD32ri killed renamable $eax(tied-def 0), -24, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function ctlzi8_zero_poison.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOVZX32rr8 killed renamable $dil, implicit killed $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r8, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = BSR32rr killed renamable $eax, implicit-def dead $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(BSR32rr, scratch_ax.cur_reg, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = XOR32ri killed renamable $eax(tied-def 0), 31, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(XOR32ri, scratch_ax.cur_reg, 0x1f);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = nsw ADD32ri killed renamable $eax(tied-def 0), -24, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(ADD32ri, scratch_ax.cur_reg, -0x18);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ctlzi16_zero_poison(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function ctlzi16_zero_poison: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVZX32rr16 killed renamable $di, implicit killed $edi
    //   renamable $eax = BSR32rr killed renamable $eax, implicit-def dead $eflags
    //   renamable $eax = XOR32ri killed renamable $eax(tied-def 0), 31, implicit-def dead $eflags
    //   renamable $eax = nsw ADD32ri killed renamable $eax(tied-def 0), -16, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function ctlzi16_zero_poison.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOVZX32rr16 killed renamable $di, implicit killed $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r16, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = BSR32rr killed renamable $eax, implicit-def dead $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(BSR32rr, scratch_ax.cur_reg, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = XOR32ri killed renamable $eax(tied-def 0), 31, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(XOR32ri, scratch_ax.cur_reg, 0x1f);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = nsw ADD32ri killed renamable $eax(tied-def 0), -16, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(ADD32ri, scratch_ax.cur_reg, -0x10);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ctlzi32_zero_poison(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function ctlzi32_zero_poison: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = BSR32rr killed renamable $edi, implicit-def dead $eflags
    //   renamable $eax = XOR32ri killed renamable $eax(tied-def 0), 31, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function ctlzi32_zero_poison.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = BSR32rr killed renamable $edi, implicit-def dead $eflags
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(BSR32rr, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = XOR32ri killed renamable $eax(tied-def 0), 31, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(XOR32ri, scratch_ax.cur_reg, 0x1f);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ctlzi64_zero_poison(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function ctlzi64_zero_poison: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $rax = BSR64rr killed renamable $rdi, implicit-def dead $eflags
    //   renamable $rax = XOR64ri32 killed renamable $rax(tied-def 0), 63, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function ctlzi64_zero_poison.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $rax = BSR64rr killed renamable $rdi, implicit-def dead $eflags
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(BSR64rr, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = XOR64ri32 killed renamable $rax(tied-def 0), 63, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(XOR64ri, scratch_ax.cur_reg, 0x3f);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ctlzi8(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function ctlzi8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVZX32rr8 killed renamable $dil, implicit killed $edi
    //   renamable $ecx = BSR32rr renamable $eax, implicit-def dead $eflags
    //   renamable $ecx = XOR32ri killed renamable $ecx(tied-def 0), 31, implicit-def dead $eflags
    //   renamable $ecx = nsw ADD32ri killed renamable $ecx(tied-def 0), -24, implicit-def dead $eflags
    //   TEST8rr killed renamable $al, killed renamable $al, implicit-def $eflags, implicit killed $eax
    //   renamable $eax = MOV32ri 8
    //   renamable $eax = CMOV32rr killed renamable $eax(tied-def 0), killed renamable $ecx, 5, implicit killed $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function ctlzi8.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $eax = MOVZX32rr8 killed renamable $dil, implicit killed $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r8, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $ecx = BSR32rr renamable $eax, implicit-def dead $eflags
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(BSR32rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
    }
    }
    // result cx is marked as alive


    // renamable $ecx = XOR32ri killed renamable $ecx(tied-def 0), 31, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(XOR32ri, scratch_cx.cur_reg, 0x1f);
    }
    }
    // argument cx is killed and marked as dead
    // result cx is marked as alive


    // renamable $ecx = nsw ADD32ri killed renamable $ecx(tied-def 0), -24, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(ADD32ri, scratch_cx.cur_reg, -0x18);
    }
    }
    // argument cx is killed and marked as dead
    // result cx is marked as alive


    // TEST8rr killed renamable $al, killed renamable $al, implicit-def $eflags, implicit killed $eax
    do {
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8rr, scratch_ax.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument ax is killed and marked as dead


    // renamable $eax = MOV32ri 8
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32ri, scratch_ax.cur_reg, 0x8);
    }
    }
    // result ax is marked as alive


    // renamable $eax = CMOV32rr killed renamable $eax(tied-def 0), killed renamable $ecx, 5, implicit killed $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(CMOVNZ32rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ctlzi16(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function ctlzi16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVZX32rr16 killed renamable $di, implicit killed $edi
    //   renamable $ecx = BSR32rr renamable $eax, implicit-def dead $eflags
    //   renamable $ecx = XOR32ri killed renamable $ecx(tied-def 0), 31, implicit-def dead $eflags
    //   renamable $ecx = nsw ADD32ri killed renamable $ecx(tied-def 0), -16, implicit-def dead $eflags
    //   TEST16rr killed renamable $ax, killed renamable $ax, implicit-def $eflags, implicit killed $eax
    //   renamable $eax = MOV32ri 16
    //   renamable $eax = CMOV32rr killed renamable $eax(tied-def 0), killed renamable $ecx, 5, implicit killed $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function ctlzi16.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $eax = MOVZX32rr16 killed renamable $di, implicit killed $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r16, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $ecx = BSR32rr renamable $eax, implicit-def dead $eflags
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(BSR32rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
    }
    }
    // result cx is marked as alive


    // renamable $ecx = XOR32ri killed renamable $ecx(tied-def 0), 31, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(XOR32ri, scratch_cx.cur_reg, 0x1f);
    }
    }
    // argument cx is killed and marked as dead
    // result cx is marked as alive


    // renamable $ecx = nsw ADD32ri killed renamable $ecx(tied-def 0), -16, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(ADD32ri, scratch_cx.cur_reg, -0x10);
    }
    }
    // argument cx is killed and marked as dead
    // result cx is marked as alive


    // TEST16rr killed renamable $ax, killed renamable $ax, implicit-def $eflags, implicit killed $eax
    do {
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST16rr, scratch_ax.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument ax is killed and marked as dead


    // renamable $eax = MOV32ri 16
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32ri, scratch_ax.cur_reg, 0x10);
    }
    }
    // result ax is marked as alive


    // renamable $eax = CMOV32rr killed renamable $eax(tied-def 0), killed renamable $ecx, 5, implicit killed $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(CMOVNZ32rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ctlzi32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function ctlzi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   successors: %bb.2(0x30000000), %bb.1(0x50000000); %bb.2(37.50%), %bb.1(62.50%)
    //   liveins: $edi
    //   TEST32rr renamable $edi, renamable $edi, implicit-def $eflags
    //   JCC_1 %bb.2, 4, implicit killed $eflags
    // 
    // bb.1.cond.false:
    // ; predecessors: %bb.0
    //   liveins: $edi
    //   renamable $eax = BSR32rr killed renamable $edi, implicit-def dead $eflags
    //   renamable $eax = XOR32ri killed renamable $eax(tied-def 0), 31, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // bb.2.cond.end:
    // ; predecessors: %bb.0
    // 
    //   $eax = MOV32ri 32
    //   RET64 killed $eax
    // 
    // # End machine code for function ctlzi32.
    // 

    // Mapping di to param_0

    // Creating label for convergence point at the end of the function
    Label ret_converge_label = derived()->assembler.label_create();
    // Creating labels for blocks that are jump targets
    Label block1_label = derived()->assembler.label_create();
    Label block2_label = derived()->assembler.label_create();

    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // TEST32rr renamable $edi, renamable $edi, implicit-def $eflags
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(TEST32ri, op0, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(TEST32mr, (*cond1), op1);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(TEST32rr, op0, op1);
        break;
    }
    }
    } while (false);


    // JCC_1 %bb.2, 4, implicit killed $eflags
    // Preparing jump to other block
    // di is live-out
    // ax is used in the function later on
    // Handling register ax
    // ax is not live-out and needs to be allocated
    scratch_ax.alloc_from_bank(0);
    // Handling register di
    // di is mapped to operand param_0, materializing it
    param_0.try_salvage_or_materialize(this, scratch_di, 0, 4);
    derived()->generate_raw_jump(CompilerX64::Jump::je, block2_label);


    // Starting encoding of block 1
    derived()->assembler.label_place(block1_label);
    // Marking di as live


    // renamable $eax = BSR32rr killed renamable $edi, implicit-def dead $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(BSR32rr, scratch_ax.cur_reg, scratch_di.cur_reg);
    }
    }
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = XOR32ri killed renamable $eax(tied-def 0), 31, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(XOR32ri, scratch_ax.cur_reg, 0x1f);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // handling return for ax
    // value already in register, nothing to do
    // Jumping to convergence point at the end of the encoding function
    derived()->generate_raw_jump(CompilerX64::Jump::jmp, ret_converge_label);

    // Starting encoding of block 2
    derived()->assembler.label_place(block2_label);


    // $eax = MOV32ri 32
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32ri, scratch_ax.cur_reg, 0x20);
    }
    }
    // result ax is marked as alive


    // RET64 killed $eax
    // handling return for ax
    // value already in register, nothing to do
    // Omitting jump to convergence as this is the last block

    // Placing the convergence point for registers here
    derived()->assembler.label_place(ret_converge_label);
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_ctlzi64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function ctlzi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   successors: %bb.2(0x30000000), %bb.1(0x50000000); %bb.2(37.50%), %bb.1(62.50%)
    //   liveins: $rdi
    //   TEST64rr renamable $rdi, renamable $rdi, implicit-def $eflags
    //   JCC_1 %bb.2, 4, implicit killed $eflags
    // 
    // bb.1.cond.false:
    // ; predecessors: %bb.0
    //   liveins: $rdi
    //   renamable $rax = BSR64rr killed renamable $rdi, implicit-def dead $eflags
    //   renamable $rax = XOR64ri32 killed renamable $rax(tied-def 0), 63, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // bb.2.cond.end:
    // ; predecessors: %bb.0
    // 
    //   $eax = MOV32ri 64, implicit-def $rax
    //   RET64 killed $rax
    // 
    // # End machine code for function ctlzi64.
    // 

    // Mapping di to param_0

    // Creating label for convergence point at the end of the function
    Label ret_converge_label = derived()->assembler.label_create();
    // Creating labels for blocks that are jump targets
    Label block1_label = derived()->assembler.label_create();
    Label block2_label = derived()->assembler.label_create();

    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // TEST64rr renamable $rdi, renamable $rdi, implicit-def $eflags
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(TEST64ri, op0, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(TEST64mr, (*cond1), op1);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(TEST64rr, op0, op1);
        break;
    }
    }
    } while (false);


    // JCC_1 %bb.2, 4, implicit killed $eflags
    // Preparing jump to other block
    // di is live-out
    // ax is used in the function later on
    // Handling register ax
    // ax is not live-out and needs to be allocated
    scratch_ax.alloc_from_bank(0);
    // Handling register di
    // di is mapped to operand param_0, materializing it
    param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
    derived()->generate_raw_jump(CompilerX64::Jump::je, block2_label);


    // Starting encoding of block 1
    derived()->assembler.label_place(block1_label);
    // Marking di as live


    // renamable $rax = BSR64rr killed renamable $rdi, implicit-def dead $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(BSR64rr, scratch_ax.cur_reg, scratch_di.cur_reg);
    }
    }
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = XOR64ri32 killed renamable $rax(tied-def 0), 63, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(XOR64ri, scratch_ax.cur_reg, 0x3f);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // handling return for ax
    // value already in register, nothing to do
    // Jumping to convergence point at the end of the encoding function
    derived()->generate_raw_jump(CompilerX64::Jump::jmp, ret_converge_label);

    // Starting encoding of block 2
    derived()->assembler.label_place(block2_label);


    // $eax = MOV32ri 64, implicit-def $rax
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32ri, scratch_ax.cur_reg, 0x40);
    }
    }
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $rax
    // handling return for ax
    // value already in register, nothing to do
    // Omitting jump to convergence as this is the last block

    // Placing the convergence point for registers here
    derived()->assembler.label_place(ret_converge_label);
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_i8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_add_i8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $al = ADD8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    //   renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $al = KILL killed renamable $al, implicit killed $eax
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $al, killed $ecx
    // 
    // # End machine code for function of_add_i8.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $al = ADD8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 1);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(ADD8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 1);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(ADD8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 1);
        AsmReg op2 = param_1.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(ADD8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETO8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $al = KILL killed renamable $al, implicit killed $eax
    // KILL is a no-op


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $al, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_i8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_sub_i8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $al = SUB8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    //   renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $al = KILL killed renamable $al, implicit killed $eax
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $al, killed $ecx
    // 
    // # End machine code for function of_sub_i8.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $al = SUB8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 1);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(SUB8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 1);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(SUB8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 1);
        AsmReg op2 = param_1.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(SUB8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETO8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $al = KILL killed renamable $al, implicit killed $eax
    // KILL is a no-op


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $al, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_i8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_mul_i8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   $al = KILL killed renamable $al, implicit killed $eax
    //   IMUL8r killed renamable $cl, implicit-def $al, implicit-def $eflags, implicit-def $ax, implicit killed $al, implicit killed $ecx
    //   renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $al, killed $ecx
    // 
    // # End machine code for function of_mul_i8.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // $al = KILL killed renamable $al, implicit killed $eax
    // KILL is a no-op


    // IMUL8r killed renamable $cl, implicit-def $al, implicit-def $eflags, implicit-def $ax, implicit killed $al, implicit killed $ecx
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // fixing reg 0 for cond (cond0)
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, op4_tmp);
        // operand exceeds NumImplicitUses, ignore
        ASMD(IMUL8m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, op4_tmp);
        // operand exceeds NumImplicitUses, ignore
        ASMD(IMUL8r, op0);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETO8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $al, killed $ecx
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_u8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_add_u8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $al = ADD8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    //   renamable $dl = SETCCr 2, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $al = KILL killed renamable $al, implicit killed $eax
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $al, killed $ecx
    // 
    // # End machine code for function of_add_u8.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $al = ADD8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 1);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(ADD8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 1);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(ADD8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 1);
        AsmReg op2 = param_1.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(ADD8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $dl = SETCCr 2, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETC8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $al = KILL killed renamable $al, implicit killed $eax
    // KILL is a no-op


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $al, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_u8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_sub_u8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $al = SUB8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    //   renamable $dl = SETCCr 2, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $al = KILL killed renamable $al, implicit killed $eax
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $al, killed $ecx
    // 
    // # End machine code for function of_sub_u8.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $al = SUB8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 1);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(SUB8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 1);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(SUB8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 1);
        AsmReg op2 = param_1.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(SUB8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $dl = SETCCr 2, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETC8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $al = KILL killed renamable $al, implicit killed $eax
    // KILL is a no-op


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $al, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_u8(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_mul_u8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   $al = KILL killed renamable $al, implicit killed $eax
    //   MUL8r killed renamable $cl, implicit-def $al, implicit-def $eflags, implicit-def $ax, implicit killed $al, implicit killed $ecx
    //   renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $al, killed $ecx
    // 
    // # End machine code for function of_mul_u8.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // $al = KILL killed renamable $al, implicit killed $eax
    // KILL is a no-op


    // MUL8r killed renamable $cl, implicit-def $al, implicit-def $eflags, implicit-def $ax, implicit killed $al, implicit killed $ecx
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // fixing reg 0 for cond (cond0)
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, op4_tmp);
        // operand exceeds NumImplicitUses, ignore
        ASMD(MUL8m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, op4_tmp);
        // operand exceeds NumImplicitUses, ignore
        ASMD(MUL8r, op0);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETO8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $al, killed $ecx
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_i16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_add_i16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $ax = ADD16rr killed renamable $ax(tied-def 0), killed renamable $cx, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    //   renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ax = KILL killed renamable $ax, implicit killed $eax
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $ax, killed $ecx
    // 
    // # End machine code for function of_add_i16.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $ax = ADD16rr killed renamable $ax(tied-def 0), killed renamable $cx, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 2);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(ADD16ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 2);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(ADD16rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 2);
        AsmReg op2 = param_1.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(ADD16rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETO8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ax = KILL killed renamable $ax, implicit killed $eax
    // KILL is a no-op


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $ax, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_i16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_sub_i16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $ax = SUB16rr killed renamable $ax(tied-def 0), killed renamable $cx, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    //   renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ax = KILL killed renamable $ax, implicit killed $eax
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $ax, killed $ecx
    // 
    // # End machine code for function of_sub_i16.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $ax = SUB16rr killed renamable $ax(tied-def 0), killed renamable $cx, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 2);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(SUB16ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 2);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(SUB16rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 2);
        AsmReg op2 = param_1.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(SUB16rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETO8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ax = KILL killed renamable $ax, implicit killed $eax
    // KILL is a no-op


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $ax, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_i16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_mul_i16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $ax = IMUL16rr killed renamable $ax(tied-def 0), killed renamable $cx, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    //   renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ax = KILL killed renamable $ax, implicit killed $eax
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $ax, killed $ecx
    // 
    // # End machine code for function of_mul_i16.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $ax = IMUL16rr killed renamable $ax(tied-def 0), killed renamable $cx, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 2);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(IMUL16rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 2);
        AsmReg op2 = param_1.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(IMUL16rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETO8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ax = KILL killed renamable $ax, implicit killed $eax
    // KILL is a no-op


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $ax, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_u16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_add_u16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $ax = ADD16rr killed renamable $ax(tied-def 0), killed renamable $cx, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    //   renamable $dl = SETCCr 2, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ax = KILL killed renamable $ax, implicit killed $eax
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $ax, killed $ecx
    // 
    // # End machine code for function of_add_u16.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $ax = ADD16rr killed renamable $ax(tied-def 0), killed renamable $cx, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 2);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(ADD16ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 2);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(ADD16rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 2);
        AsmReg op2 = param_1.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(ADD16rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $dl = SETCCr 2, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETC8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ax = KILL killed renamable $ax, implicit killed $eax
    // KILL is a no-op


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $ax, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_u16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_sub_u16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $ax = SUB16rr killed renamable $ax(tied-def 0), killed renamable $cx, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    //   renamable $dl = SETCCr 2, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ax = KILL killed renamable $ax, implicit killed $eax
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $ax, killed $ecx
    // 
    // # End machine code for function of_sub_u16.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $ax = SUB16rr killed renamable $ax(tied-def 0), killed renamable $cx, implicit-def $eflags, implicit killed $ecx, implicit killed $eax, implicit-def $eax
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 2);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(SUB16ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 2);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(SUB16rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 2);
        AsmReg op2 = param_1.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        // operand exceeds NumImplicitUses, ignore
        ASMD(SUB16rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $dl = SETCCr 2, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETC8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ax = KILL killed renamable $ax, implicit killed $eax
    // KILL is a no-op


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $ax, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_u16(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_mul_u16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags
    //   $ax = KILL killed renamable $ax, implicit killed $eax
    //   MUL16r killed renamable $cx, implicit-def $ax, implicit-def dead $dx, implicit-def $eflags, implicit killed $ax, implicit killed $ecx
    //   renamable $sil = SETCCr 0, implicit killed $eflags, implicit killed $esi, implicit-def $esi
    //   $ecx = MOV32rr killed $esi
    //   RET64 killed $ax, killed $ecx
    // 
    // # End machine code for function of_mul_u16.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // renamable $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_si.alloc_from_bank(0);

        // def si has not been allocated yet
        scratch_si.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_si.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result si is marked as alive


    // $ax = KILL killed renamable $ax, implicit killed $eax
    // KILL is a no-op


    // MUL16r killed renamable $cx, implicit-def $ax, implicit-def dead $dx, implicit-def $eflags, implicit killed $ax, implicit killed $ecx
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // fixing reg 0 for cond (cond0)
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, op4_tmp);
        // operand exceeds NumImplicitUses, ignore
        ASMD(MUL16m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, op4_tmp);
        // operand exceeds NumImplicitUses, ignore
        ASMD(MUL16r, op0);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as dead


    // renamable $sil = SETCCr 0, implicit killed $eflags, implicit killed $esi, implicit-def $esi
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def si has not been allocated yet
        scratch_si.alloc_from_bank(0);
        ASMD(SETO8r, scratch_si.cur_reg);
    }
    }
    // argument si is killed and marked as dead
    // result si is marked as alive
    // result si is marked as alive


    // $ecx = MOV32rr killed $esi
    // aliasing cx to si
    // source si is killed, all aliases redirected and marked as dead


    // RET64 killed $ax, killed $ecx
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for si
    result_1 = std::move(scratch_si);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_i32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_add_i32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $eax = ADD32rr killed renamable $eax(tied-def 0), killed renamable $ecx, implicit-def $eflags
    //   renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $eax, killed $ecx
    // 
    // # End machine code for function of_add_i32.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $eax = ADD32rr killed renamable $eax(tied-def 0), killed renamable $ecx, implicit-def $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(ADD32ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(ADD32rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(ADD32rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETO8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $eax, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_i32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_sub_i32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $eax = SUB32rr killed renamable $eax(tied-def 0), killed renamable $ecx, implicit-def $eflags
    //   renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $eax, killed $ecx
    // 
    // # End machine code for function of_sub_i32.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $eax = SUB32rr killed renamable $eax(tied-def 0), killed renamable $ecx, implicit-def $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(SUB32ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(SUB32rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SUB32rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETO8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $eax, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_i32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_mul_i32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $eax = IMUL32rr killed renamable $eax(tied-def 0), killed renamable $ecx, implicit-def $eflags
    //   renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $eax, killed $ecx
    // 
    // # End machine code for function of_mul_i32.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $eax = IMUL32rr killed renamable $eax(tied-def 0), killed renamable $ecx, implicit-def $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(IMUL32rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(IMUL32rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETO8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $eax, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_u32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_add_u32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $eax = ADD32rr killed renamable $eax(tied-def 0), killed renamable $ecx, implicit-def $eflags
    //   renamable $dl = SETCCr 2, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $eax, killed $ecx
    // 
    // # End machine code for function of_add_u32.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $eax = ADD32rr killed renamable $eax(tied-def 0), killed renamable $ecx, implicit-def $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(ADD32ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(ADD32rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(ADD32rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 2, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETC8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $eax, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_u32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_sub_u32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $eax = SUB32rr killed renamable $eax(tied-def 0), killed renamable $ecx, implicit-def $eflags
    //   renamable $dl = SETCCr 2, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $eax, killed $ecx
    // 
    // # End machine code for function of_sub_u32.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $eax = SUB32rr killed renamable $eax(tied-def 0), killed renamable $ecx, implicit-def $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(SUB32ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(SUB32rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SUB32rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 2, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETC8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $eax, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_u32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_mul_u32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $eax, $ecx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $eax, $ecx
    //   renamable $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags
    //   MUL32r killed renamable $ecx, implicit-def $eax, implicit-def dead $edx, implicit-def $eflags, implicit killed $eax
    //   renamable $sil = SETCCr 0, implicit killed $eflags, implicit killed $esi, implicit-def $esi
    //   $ecx = MOV32rr killed $esi
    //   RET64 killed $eax, killed $ecx
    // 
    // # End machine code for function of_mul_u32.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // renamable $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_si.alloc_from_bank(0);

        // def si has not been allocated yet
        scratch_si.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_si.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result si is marked as alive


    // MUL32r killed renamable $ecx, implicit-def $eax, implicit-def dead $edx, implicit-def $eflags, implicit killed $eax
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // fixing reg 0 for cond (cond0)
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL32m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL32r, op0);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as dead


    // renamable $sil = SETCCr 0, implicit killed $eflags, implicit killed $esi, implicit-def $esi
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def si has not been allocated yet
        scratch_si.alloc_from_bank(0);
        ASMD(SETO8r, scratch_si.cur_reg);
    }
    }
    // argument si is killed and marked as dead
    // result si is marked as alive
    // result si is marked as alive


    // $ecx = MOV32rr killed $esi
    // aliasing cx to si
    // source si is killed, all aliases redirected and marked as dead


    // RET64 killed $eax, killed $ecx
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for si
    result_1 = std::move(scratch_si);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_i64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_add_i64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rax, $rcx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rax, $rcx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def $eflags
    //   renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $rax, killed $ecx
    // 
    // # End machine code for function of_add_i64.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(ADD64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(ADD64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(ADD64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETO8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_i64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_sub_i64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rax, $rcx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rax, $rcx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $rax = SUB64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def $eflags
    //   renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $rax, killed $ecx
    // 
    // # End machine code for function of_sub_i64.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $rax = SUB64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SUB64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SUB64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SUB64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETO8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_i64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_mul_i64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rax, $rcx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rax, $rcx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $rax = IMUL64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def $eflags
    //   renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $rax, killed $ecx
    // 
    // # End machine code for function of_mul_i64.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $rax = IMUL64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(IMUL64rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(IMUL64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 0, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETO8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_u64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_add_u64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rax, $rcx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rax, $rcx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def $eflags
    //   renamable $dl = SETCCr 2, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $rax, killed $ecx
    // 
    // # End machine code for function of_add_u64.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(ADD64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(ADD64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(ADD64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 2, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETC8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_u64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_sub_u64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rax, $rcx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rax, $rcx
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   renamable $rax = SUB64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def $eflags
    //   renamable $dl = SETCCr 2, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    //   $ecx = MOV32rr killed $edx
    //   RET64 killed $rax, killed $ecx
    // 
    // # End machine code for function of_sub_u64.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_dx.alloc_from_bank(0);

        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_dx.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result dx is marked as alive


    // renamable $rax = SUB64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SUB64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_1.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SUB64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SUB64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 2, implicit killed $eflags, implicit killed $edx, implicit-def $edx
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETC8r, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive
    // result dx is marked as alive


    // $ecx = MOV32rr killed $edx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $ecx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for dx
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_u64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function of_mul_u64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rax, $rcx
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rax, $rcx
    //   renamable $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags
    //   MUL64r killed renamable $rcx, implicit-def $rax, implicit-def dead $rdx, implicit-def $eflags, implicit killed $rax
    //   renamable $sil = SETCCr 0, implicit killed $eflags, implicit killed $esi, implicit-def $esi
    //   $ecx = MOV32rr killed $esi
    //   RET64 killed $rax, killed $ecx
    // 
    // # End machine code for function of_mul_u64.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // renamable $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_si.alloc_from_bank(0);

        // def si has not been allocated yet
        scratch_si.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_si.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result si is marked as alive


    // MUL64r killed renamable $rcx, implicit-def $rax, implicit-def dead $rdx, implicit-def $eflags, implicit killed $rax
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // fixing reg 0 for cond (cond0)
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64r, op0);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as dead


    // renamable $sil = SETCCr 0, implicit killed $eflags, implicit killed $esi, implicit-def $esi
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def si has not been allocated yet
        scratch_si.alloc_from_bank(0);
        ASMD(SETO8r, scratch_si.cur_reg);
    }
    }
    // argument si is killed and marked as dead
    // result si is marked as alive
    // result si is marked as alive


    // $ecx = MOV32rr killed $esi
    // aliasing cx to si
    // source si is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $ecx
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    // cx is an alias for si
    result_1 = std::move(scratch_si);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_i128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1, ScratchReg &result_2) {
    // # Machine code for function of_add_i128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rax, $rcx, $rdx, $rdi
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rax, $rcx, $rdi, $rdx
    //   renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def $eflags
    //   renamable $rcx = ADC64rr killed renamable $rcx(tied-def 0), killed renamable $rdi, implicit-def $eflags, implicit killed $eflags
    //   renamable $dl = SETCCr 0, implicit killed $eflags
    //   renamable $edx = MOVZX32rr8 killed renamable $dl
    //   RET64 killed $rax, killed $rcx, killed $edx
    // 
    // # End machine code for function of_add_i128.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    // Mapping dx to param_2
    // Mapping di to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def $eflags
    do {
    {
    auto cond0 = param_2.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(ADD64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_2.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(ADD64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_2.as_reg(this);
        ASMD(ADD64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rcx = ADC64rr killed renamable $rcx(tied-def 0), killed renamable $rdi, implicit-def $eflags, implicit killed $eflags
    do {
    {
    auto cond2 = param_3.encodeable_as_imm32_sext();
    if (cond2) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_cx, 0, 8);
        ASMD(ADC64ri, scratch_cx.cur_reg, (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_3.encodeable_as_mem();
    if (cond3) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_cx, 0, 8);
        ASMD(ADC64rm, scratch_cx.cur_reg, (*cond3));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_cx, 0, 8);
        AsmReg op2 = param_3.as_reg(this);
        ASMD(ADC64rr, scratch_cx.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument di is killed and marked as dead
    // result cx is marked as alive


    // renamable $dl = SETCCr 0, implicit killed $eflags
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETO8r, scratch_dx.cur_reg);
    }
    }
    // result dx is marked as alive


    // renamable $edx = MOVZX32rr8 killed renamable $dl
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(MOVZXr32r8, scratch_dx.cur_reg, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive


    // RET64 killed $rax, killed $rcx, killed $edx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    result_1 = std::move(scratch_cx);
    // returning reg dx as result_2
    result_2 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_i128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1, ScratchReg &result_2) {
    // # Machine code for function of_sub_i128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rax, $rcx, $rdx, $rdi
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rax, $rcx, $rdi, $rdx
    //   renamable $rax = SUB64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def $eflags
    //   renamable $rcx = SBB64rr killed renamable $rcx(tied-def 0), killed renamable $rdi, implicit-def $eflags, implicit killed $eflags
    //   renamable $dl = SETCCr 0, implicit killed $eflags
    //   renamable $edx = MOVZX32rr8 killed renamable $dl
    //   RET64 killed $rax, killed $rcx, killed $edx
    // 
    // # End machine code for function of_sub_i128.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    // Mapping dx to param_2
    // Mapping di to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $rax = SUB64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def $eflags
    do {
    {
    auto cond0 = param_2.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SUB64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_2.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SUB64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_2.as_reg(this);
        ASMD(SUB64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rcx = SBB64rr killed renamable $rcx(tied-def 0), killed renamable $rdi, implicit-def $eflags, implicit killed $eflags
    do {
    {
    auto cond2 = param_3.encodeable_as_imm32_sext();
    if (cond2) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_cx, 0, 8);
        ASMD(SBB64ri, scratch_cx.cur_reg, (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_3.encodeable_as_mem();
    if (cond3) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_cx, 0, 8);
        ASMD(SBB64rm, scratch_cx.cur_reg, (*cond3));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_cx, 0, 8);
        AsmReg op2 = param_3.as_reg(this);
        ASMD(SBB64rr, scratch_cx.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument di is killed and marked as dead
    // result cx is marked as alive


    // renamable $dl = SETCCr 0, implicit killed $eflags
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETO8r, scratch_dx.cur_reg);
    }
    }
    // result dx is marked as alive


    // renamable $edx = MOVZX32rr8 killed renamable $dl
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(MOVZXr32r8, scratch_dx.cur_reg, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive


    // RET64 killed $rax, killed $rcx, killed $edx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    result_1 = std::move(scratch_cx);
    // returning reg dx as result_2
    result_2 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_i128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1, ScratchReg &result_2) {
    // # Machine code for function of_mul_i128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Frame Objects:
    //   fi#-2: size=8, align=8, fixed, at location [SP-16]
    //   fi#-1: size=8, align=16, fixed, at location [SP-8]
    // Function Live Ins: $rax, $rcx, $rdx, $rdi
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rax, $rcx, $rdi, $rdx, $r14, $rbx
    //   frame-setup PUSH64r killed $r14, implicit-def $rsp, implicit $rsp
    //   frame-setup CFI_INSTRUCTION def_cfa_offset 16
    //   frame-setup PUSH64r killed $rbx, implicit-def $rsp, implicit $rsp
    //   frame-setup CFI_INSTRUCTION def_cfa_offset 24
    //   CFI_INSTRUCTION offset $rbx, -24
    //   CFI_INSTRUCTION offset $r14, -16
    //   $rbx = MOV64rr $rdx
    //   $r9 = MOV64rr $rcx
    //   $r11 = MOV64rr killed $rax
    //   renamable $rcx = SAR64ri killed renamable $rcx(tied-def 0), 63, implicit-def dead $eflags
    //   $rsi = MOV64rr $rdi
    //   renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
    //   $rax = MOV64rr killed $rdx
    //   MUL64r killed renamable $rcx, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    //   $rcx = MOV64rr killed $rdx
    //   $r8 = MOV64rr $rax
    //   renamable $rcx = ADD64rr killed renamable $rcx(tied-def 0), killed $rax, implicit-def dead $eflags
    //   renamable $rcx = ADD64rr killed renamable $rcx(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    //   $rax = MOV64rr $rdi
    //   renamable $rax = SAR64ri killed renamable $rax(tied-def 0), 63, implicit-def dead $eflags
    //   $r14 = MOV64rr $rax
    //   renamable $r14 = IMUL64rr killed renamable $r14(tied-def 0), renamable $r9, implicit-def dead $eflags
    //   MUL64r renamable $r11, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    //   $r10 = MOV64rr $rax
    //   $rsi = MOV64rr killed $rdx
    //   renamable $rsi = ADD64rr killed renamable $rsi(tied-def 0), killed renamable $r14, implicit-def dead $eflags
    //   renamable $rsi = ADD64rr killed renamable $rsi(tied-def 0), killed $rax, implicit-def dead $eflags
    //   renamable $r10 = ADD64rr killed renamable $r10(tied-def 0), killed renamable $r8, implicit-def $eflags
    //   renamable $rsi = ADC64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags, implicit killed $eflags
    //   $rax = MOV64rr $r11
    //   MUL64r renamable $rbx, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    //   $rcx = MOV64rr killed $rdx
    //   $r8 = MOV64rr killed $rax
    //   $rax = MOV64rr $r9
    //   MUL64r killed renamable $rbx, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    //   $rbx = MOV64rr killed $rdx
    //   renamable $rcx = ADD64rr killed renamable $rcx(tied-def 0), killed renamable $rax, implicit-def $eflags
    //   renamable $rbx = ADC64ri32 killed renamable $rbx(tied-def 0), 0, implicit-def dead $eflags, implicit killed $eflags
    //   $rax = MOV64rr killed $r11
    //   MUL64r renamable $rdi, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    //   $r11 = MOV64rr killed $rdx
    //   renamable $rcx = ADD64rr killed renamable $rcx(tied-def 0), killed renamable $rax, implicit-def $eflags
    //   renamable $r11 = ADC64rr killed renamable $r11(tied-def 0), killed renamable $rbx, implicit-def $eflags, implicit killed $eflags
    //   renamable $al = SETCCr 2, implicit killed $eflags
    //   renamable $ebx = MOVZX32rr8 killed renamable $al, implicit-def $rbx
    //   $rax = MOV64rr killed $r9
    //   MUL64r killed renamable $rdi, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    //   renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $r11, implicit-def $eflags
    //   renamable $rdx = ADC64rr killed renamable $rdx(tied-def 0), killed renamable $rbx, implicit-def dead $eflags, implicit killed $eflags
    //   renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $r10, implicit-def $eflags
    //   renamable $rdx = ADC64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, implicit-def dead $eflags, implicit killed $eflags
    //   $rdi = MOV64rr $rcx
    //   renamable $rdi = SAR64ri killed renamable $rdi(tied-def 0), 63, implicit-def dead $eflags
    //   renamable $rdx = XOR64rr killed renamable $rdx(tied-def 0), renamable $rdi, implicit-def dead $eflags
    //   renamable $rdi = XOR64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
    //   renamable $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags
    //   dead renamable $rdi = OR64rr killed renamable $rdi(tied-def 0), killed renamable $rdx, implicit-def $eflags
    //   renamable $sil = SETCCr 5, implicit killed $eflags, implicit killed $esi, implicit-def $esi
    //   $rax = MOV64rr killed $r8
    //   $edx = MOV32rr killed $esi
    //   $rbx = frame-destroy POP64r implicit-def $rsp, implicit $rsp
    //   frame-destroy CFI_INSTRUCTION def_cfa_offset 16
    //   $r14 = frame-destroy POP64r implicit-def $rsp, implicit $rsp
    //   frame-destroy CFI_INSTRUCTION def_cfa_offset 8
    //   RET64 killed $rax, killed $rcx, killed $edx
    // 
    // # End machine code for function of_mul_i128.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    // Mapping dx to param_2
    // Mapping di to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_r14{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_r9{derived()};
    ScratchReg scratch_r11{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    ScratchReg scratch_r8{derived()};
    ScratchReg scratch_bx{derived()};
    ScratchReg scratch_r10{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1, &param_2, &param_3}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1, &param_2, &param_3}, reg_backup_dx);


    // $rbx = MOV64rr $rdx
    // aliasing bx to dx
    // bx is an alias for operand param_2


    // $r9 = MOV64rr $rcx
    // aliasing r9 to cx
    // r9 is an alias for operand param_1


    // $r11 = MOV64rr killed $rax
    // aliasing r11 to ax
    // r11 is an alias for operand param_0
    // source ax is killed, all aliases redirected and marked as dead


    // renamable $rcx = SAR64ri killed renamable $rcx(tied-def 0), 63, implicit-def dead $eflags
    {
    if (1) {
        AsmReg inst3_op1 = scratch_cx.alloc_from_bank(0);
        AsmReg inst3_op1_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, inst3_op1, inst3_op1_tmp);
        ASMD(SAR64ri, scratch_cx.cur_reg, 0x3f);
    }
    }
    // argument cx is killed and marked as dead
    // result cx is marked as alive


    // $rsi = MOV64rr $rdi
    // aliasing si to di
    // si is an alias for operand param_3


    // renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), renamable $rcx, implicit-def dead $eflags
    do {
    {
    if (1) {
        AsmReg inst5_op1 = scratch_si.alloc_from_bank(0);
        AsmReg inst5_op1_tmp = param_3.as_reg(this);
        ASMD(MOV64rr, inst5_op1, inst5_op1_tmp);
        ASMD(IMUL64rr, scratch_si.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // result si is marked as alive


    // $rax = MOV64rr killed $rdx
    // aliasing ax to dx
    // ax is an alias for operand param_2
    // source dx is killed, all aliases redirected and marked as dead


    // MUL64r killed renamable $rcx, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    do {
    {
    if (1) {
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_2.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64r, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // $rcx = MOV64rr killed $rdx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // $r8 = MOV64rr $rax
    // aliasing r8 to ax


    // renamable $rcx = ADD64rr killed renamable $rcx(tied-def 0), killed $rax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand dx has some references
        AsmReg reg_cx = scratch_cx.alloc_from_bank(0);
        ASMD(MOV64rr, reg_cx, scratch_dx.cur_reg);
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(ADD64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // removing alias from cx to dx
    // argument ax is killed and marked as dead
    // result cx is marked as alive


    // renamable $rcx = ADD64rr killed renamable $rcx(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(ADD64rr, scratch_cx.cur_reg, scratch_si.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument si is killed and marked as dead
    // result cx is marked as alive


    // $rax = MOV64rr $rdi
    // aliasing ax to di
    // r8 is still aliased to the value of ax so we emit an explicit copy
    scratch_r8.alloc_from_bank(0);
    ASMD(MOV64rr, scratch_r8.cur_reg, scratch_ax.cur_reg);
    // ax is an alias for operand param_3


    // renamable $rax = SAR64ri killed renamable $rax(tied-def 0), 63, implicit-def dead $eflags
    {
    if (1) {
        AsmReg inst13_op1 = scratch_ax.alloc_from_bank(0);
        AsmReg inst13_op1_tmp = param_3.as_reg(this);
        ASMD(MOV64rr, inst13_op1, inst13_op1_tmp);
        ASMD(SAR64ri, scratch_ax.cur_reg, 0x3f);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // $r14 = MOV64rr $rax
    // aliasing r14 to ax


    // renamable $r14 = IMUL64rr killed renamable $r14(tied-def 0), renamable $r9, implicit-def dead $eflags
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand ax has some references
        AsmReg reg_r14 = scratch_r14.alloc_from_bank(0);
        ASMD(MOV64rr, reg_r14, scratch_ax.cur_reg);
        // def r14 has not been allocated yet
        scratch_r14.alloc_from_bank(0);
        ASMD(IMUL64rm, scratch_r14.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand ax has some references
        AsmReg reg_r14 = scratch_r14.alloc_from_bank(0);
        ASMD(MOV64rr, reg_r14, scratch_ax.cur_reg);
        AsmReg op2 = param_1.as_reg(this);
        // def r14 has not been allocated yet
        scratch_r14.alloc_from_bank(0);
        ASMD(IMUL64rr, scratch_r14.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument r14 is killed and marked as dead
    // removing alias from r14 to ax
    // result r14 is marked as alive


    // MUL64r renamable $r11, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    do {
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // fixing reg 0 for cond (cond1)
        ASMD(MUL64m, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        // fixing reg 0 for cond ()
        ASMD(MUL64r, op0);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // $r10 = MOV64rr $rax
    // aliasing r10 to ax


    // $rsi = MOV64rr killed $rdx
    // aliasing si to dx
    // source dx is killed, all aliases redirected and marked as dead


    // renamable $rsi = ADD64rr killed renamable $rsi(tied-def 0), killed renamable $r14, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand dx has some references
        AsmReg reg_si = scratch_si.alloc_from_bank(0);
        ASMD(MOV64rr, reg_si, scratch_dx.cur_reg);
        // def si has not been allocated yet
        scratch_si.alloc_from_bank(0);
        ASMD(ADD64rr, scratch_si.cur_reg, scratch_r14.cur_reg);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // removing alias from si to dx
    // argument r14 is killed and marked as dead
    // result si is marked as alive


    // renamable $rsi = ADD64rr killed renamable $rsi(tied-def 0), killed $rax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(si) is the same as its tied destination
        assert(scratch_si.cur_reg.valid());
        ASMD(ADD64rr, scratch_si.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // result si is marked as alive


    // renamable $r10 = ADD64rr killed renamable $r10(tied-def 0), killed renamable $r8, implicit-def $eflags
    do {
    {
    if (1) {
        // operand ax has some references
        AsmReg reg_r10 = scratch_r10.alloc_from_bank(0);
        ASMD(MOV64rr, reg_r10, scratch_ax.cur_reg);
        // def r10 has not been allocated yet
        scratch_r10.alloc_from_bank(0);
        ASMD(ADD64rr, scratch_r10.cur_reg, scratch_r8.cur_reg);
        break;
    }
    }
    } while (false);
    // argument r10 is killed and marked as dead
    // removing alias from r10 to ax
    // argument r8 is killed and marked as dead
    // result r10 is marked as alive


    // renamable $rsi = ADC64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags, implicit killed $eflags
    do {
    {
    if (1) {
        // operand 1(si) is the same as its tied destination
        assert(scratch_si.cur_reg.valid());
        ASMD(ADC64rr, scratch_si.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument cx is killed and marked as dead
    // result si is marked as alive


    // $rax = MOV64rr $r11
    // aliasing ax to r11
    // ax is an alias for operand param_0


    // MUL64r renamable $rbx, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    do {
    {
    auto cond2 = param_2.encodeable_as_mem();
    if (cond2) {
        // fixing reg 0 for cond (cond2)
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64m, (*cond2));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_2.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64r, op0);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // $rcx = MOV64rr killed $rdx
    // aliasing cx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // $r8 = MOV64rr killed $rax
    // aliasing r8 to ax
    // source ax is killed, all aliases redirected and marked as dead


    // $rax = MOV64rr $r9
    // aliasing ax to r9
    // r8 is still aliased to the value of ax so we emit an explicit copy
    scratch_r8.alloc_from_bank(0);
    ASMD(MOV64rr, scratch_r8.cur_reg, scratch_ax.cur_reg);
    // ax is an alias for operand param_1


    // MUL64r killed renamable $rbx, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    // dx is a def but still has active aliases left which need to be preserved
    // cx is still aliased to the value of dx so we emit an explicit copy
    scratch_cx.alloc_from_bank(0);
    ASMD(MOV64rr, scratch_cx.cur_reg, scratch_dx.cur_reg);
    do {
    {
    auto cond3 = param_2.encodeable_as_mem();
    if (cond3) {
        // fixing reg 0 for cond (cond3)
        AsmReg op4_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64m, (*cond3));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_2.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64r, op0);
        break;
    }
    }
    } while (false);
    // argument bx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // $rbx = MOV64rr killed $rdx
    // aliasing bx to dx
    // source dx is killed, all aliases redirected and marked as dead


    // renamable $rcx = ADD64rr killed renamable $rcx(tied-def 0), killed renamable $rax, implicit-def $eflags
    do {
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(ADD64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result cx is marked as alive


    // renamable $rbx = ADC64ri32 killed renamable $rbx(tied-def 0), 0, implicit-def dead $eflags, implicit killed $eflags
    {
    if (1) {
        // operand dx has some references
        AsmReg reg_bx = scratch_bx.alloc_from_bank(0);
        ASMD(MOV64rr, reg_bx, scratch_dx.cur_reg);
        // def bx has not been allocated yet
        scratch_bx.alloc_from_bank(0);
        ASMD(ADC64ri, scratch_bx.cur_reg, 0x0);
    }
    }
    // argument bx is killed and marked as dead
    // removing alias from bx to dx
    // result bx is marked as alive


    // $rax = MOV64rr killed $r11
    // aliasing ax to r11
    // ax is an alias for operand param_0
    // source r11 is killed, all aliases redirected and marked as dead


    // MUL64r renamable $rdi, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    do {
    {
    auto cond4 = param_3.encodeable_as_mem();
    if (cond4) {
        // fixing reg 0 for cond (cond4)
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64m, (*cond4));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_3.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64r, op0);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // $r11 = MOV64rr killed $rdx
    // aliasing r11 to dx
    // source dx is killed, all aliases redirected and marked as dead


    // renamable $rcx = ADD64rr killed renamable $rcx(tied-def 0), killed renamable $rax, implicit-def $eflags
    do {
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(ADD64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result cx is marked as alive


    // renamable $r11 = ADC64rr killed renamable $r11(tied-def 0), killed renamable $rbx, implicit-def $eflags, implicit killed $eflags
    do {
    {
    if (1) {
        // operand dx has some references
        AsmReg reg_r11 = scratch_r11.alloc_from_bank(0);
        ASMD(MOV64rr, reg_r11, scratch_dx.cur_reg);
        // def r11 has not been allocated yet
        scratch_r11.alloc_from_bank(0);
        ASMD(ADC64rr, scratch_r11.cur_reg, scratch_bx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument r11 is killed and marked as dead
    // removing alias from r11 to dx
    // argument bx is killed and marked as dead
    // result r11 is marked as alive


    // renamable $al = SETCCr 2, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETC8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $ebx = MOVZX32rr8 killed renamable $al, implicit-def $rbx
    {
    if (1) {
        // def bx has not been allocated yet
        scratch_bx.alloc_from_bank(0);
        ASMD(MOVZXr32r8, scratch_bx.cur_reg, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result bx is marked as alive
    // result bx is marked as alive


    // $rax = MOV64rr killed $r9
    // aliasing ax to r9
    // ax is an alias for operand param_1
    // source r9 is killed, all aliases redirected and marked as dead


    // MUL64r killed renamable $rdi, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    do {
    {
    auto cond5 = param_3.encodeable_as_mem();
    if (cond5) {
        // fixing reg 0 for cond (cond5)
        AsmReg op4_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64m, (*cond5));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_3.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64r, op0);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $r11, implicit-def $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(ADD64rr, scratch_ax.cur_reg, scratch_r11.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument r11 is killed and marked as dead
    // result ax is marked as alive


    // renamable $rdx = ADC64rr killed renamable $rdx(tied-def 0), killed renamable $rbx, implicit-def dead $eflags, implicit killed $eflags
    do {
    {
    if (1) {
        // operand 1(dx) is the same as its tied destination
        assert(scratch_dx.cur_reg.valid());
        ASMD(ADC64rr, scratch_dx.cur_reg, scratch_bx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead
    // argument bx is killed and marked as dead
    // result dx is marked as alive


    // renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $r10, implicit-def $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(ADD64rr, scratch_ax.cur_reg, scratch_r10.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument r10 is killed and marked as dead
    // result ax is marked as alive


    // renamable $rdx = ADC64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, implicit-def dead $eflags, implicit killed $eflags
    do {
    {
    if (1) {
        // operand 1(dx) is the same as its tied destination
        assert(scratch_dx.cur_reg.valid());
        ASMD(ADC64rr, scratch_dx.cur_reg, scratch_si.cur_reg);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead
    // argument si is killed and marked as dead
    // result dx is marked as alive


    // $rdi = MOV64rr $rcx
    // aliasing di to cx


    // renamable $rdi = SAR64ri killed renamable $rdi(tied-def 0), 63, implicit-def dead $eflags
    {
    if (1) {
        // operand cx has some references
        AsmReg reg_di = scratch_di.alloc_from_bank(0);
        ASMD(MOV64rr, reg_di, scratch_cx.cur_reg);
        // def di has not been allocated yet
        scratch_di.alloc_from_bank(0);
        ASMD(SAR64ri, scratch_di.cur_reg, 0x3f);
    }
    }
    // argument di is killed and marked as dead
    // removing alias from di to cx
    // result di is marked as alive


    // renamable $rdx = XOR64rr killed renamable $rdx(tied-def 0), renamable $rdi, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(dx) is the same as its tied destination
        assert(scratch_dx.cur_reg.valid());
        ASMD(XOR64rr, scratch_dx.cur_reg, scratch_di.cur_reg);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead
    // result dx is marked as alive


    // renamable $rdi = XOR64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(di) is the same as its tied destination
        assert(scratch_di.cur_reg.valid());
        ASMD(XOR64rr, scratch_di.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument ax is killed and marked as dead
    // result di is marked as alive


    // renamable $esi = XOR32rr undef $esi(tied-def 0), undef $esi, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst49_op2 = scratch_si.alloc_from_bank(0);

        // def si has not been allocated yet
        scratch_si.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_si.cur_reg, inst49_op2);
        break;
    }
    }
    } while (false);
    // result si is marked as alive


    // dead renamable $rdi = OR64rr killed renamable $rdi(tied-def 0), killed renamable $rdx, implicit-def $eflags
    do {
    {
    if (1) {
        // operand 1(di) is the same as its tied destination
        assert(scratch_di.cur_reg.valid());
        ASMD(OR64rr, scratch_di.cur_reg, scratch_dx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument dx is killed and marked as dead
    // result di is marked as dead


    // renamable $sil = SETCCr 5, implicit killed $eflags, implicit killed $esi, implicit-def $esi
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def si has not been allocated yet
        scratch_si.alloc_from_bank(0);
        ASMD(SETNZ8r, scratch_si.cur_reg);
    }
    }
    // argument si is killed and marked as dead
    // result si is marked as alive
    // result si is marked as alive


    // $rax = MOV64rr killed $r8
    // aliasing ax to r8
    // source r8 is killed, all aliases redirected and marked as dead


    // $edx = MOV32rr killed $esi
    // aliasing dx to si
    // source si is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $rcx, killed $edx
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, true);
    // returning reg ax as result_0
    // ax is an alias for r8
    result_0 = std::move(scratch_r8);
    // returning reg cx as result_1
    result_1 = std::move(scratch_cx);
    // returning reg dx as result_2
    // dx is an alias for si
    result_2 = std::move(scratch_si);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_add_u128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1, ScratchReg &result_2) {
    // # Machine code for function of_add_u128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rax, $rcx, $rdx, $rdi
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rax, $rcx, $rdi, $rdx
    //   renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def $eflags
    //   renamable $rcx = ADC64rr killed renamable $rcx(tied-def 0), killed renamable $rdi, implicit-def $eflags, implicit killed $eflags
    //   renamable $dl = SETCCr 2, implicit killed $eflags
    //   renamable $edx = MOVZX32rr8 killed renamable $dl
    //   RET64 killed $rax, killed $rcx, killed $edx
    // 
    // # End machine code for function of_add_u128.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    // Mapping dx to param_2
    // Mapping di to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def $eflags
    do {
    {
    auto cond0 = param_2.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(ADD64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_2.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(ADD64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_2.as_reg(this);
        ASMD(ADD64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rcx = ADC64rr killed renamable $rcx(tied-def 0), killed renamable $rdi, implicit-def $eflags, implicit killed $eflags
    do {
    {
    auto cond2 = param_3.encodeable_as_imm32_sext();
    if (cond2) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_cx, 0, 8);
        ASMD(ADC64ri, scratch_cx.cur_reg, (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_3.encodeable_as_mem();
    if (cond3) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_cx, 0, 8);
        ASMD(ADC64rm, scratch_cx.cur_reg, (*cond3));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_cx, 0, 8);
        AsmReg op2 = param_3.as_reg(this);
        ASMD(ADC64rr, scratch_cx.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument di is killed and marked as dead
    // result cx is marked as alive


    // renamable $dl = SETCCr 2, implicit killed $eflags
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETC8r, scratch_dx.cur_reg);
    }
    }
    // result dx is marked as alive


    // renamable $edx = MOVZX32rr8 killed renamable $dl
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(MOVZXr32r8, scratch_dx.cur_reg, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive


    // RET64 killed $rax, killed $rcx, killed $edx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    result_1 = std::move(scratch_cx);
    // returning reg dx as result_2
    result_2 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_sub_u128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1, ScratchReg &result_2) {
    // # Machine code for function of_sub_u128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rax, $rcx, $rdx, $rdi
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rax, $rcx, $rdi, $rdx
    //   renamable $rax = SUB64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def $eflags
    //   renamable $rcx = SBB64rr killed renamable $rcx(tied-def 0), killed renamable $rdi, implicit-def $eflags, implicit killed $eflags
    //   renamable $dl = SETCCr 2, implicit killed $eflags
    //   renamable $edx = MOVZX32rr8 killed renamable $dl
    //   RET64 killed $rax, killed $rcx, killed $edx
    // 
    // # End machine code for function of_sub_u128.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    // Mapping dx to param_2
    // Mapping di to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $rax = SUB64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def $eflags
    do {
    {
    auto cond0 = param_2.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SUB64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_2.encodeable_as_mem();
    if (cond1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SUB64rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_2.as_reg(this);
        ASMD(SUB64rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rcx = SBB64rr killed renamable $rcx(tied-def 0), killed renamable $rdi, implicit-def $eflags, implicit killed $eflags
    do {
    {
    auto cond2 = param_3.encodeable_as_imm32_sext();
    if (cond2) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_cx, 0, 8);
        ASMD(SBB64ri, scratch_cx.cur_reg, (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_3.encodeable_as_mem();
    if (cond3) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_cx, 0, 8);
        ASMD(SBB64rm, scratch_cx.cur_reg, (*cond3));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_cx, 0, 8);
        AsmReg op2 = param_3.as_reg(this);
        ASMD(SBB64rr, scratch_cx.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument di is killed and marked as dead
    // result cx is marked as alive


    // renamable $dl = SETCCr 2, implicit killed $eflags
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETC8r, scratch_dx.cur_reg);
    }
    }
    // result dx is marked as alive


    // renamable $edx = MOVZX32rr8 killed renamable $dl
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(MOVZXr32r8, scratch_dx.cur_reg, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive


    // RET64 killed $rax, killed $rcx, killed $edx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    result_1 = std::move(scratch_cx);
    // returning reg dx as result_2
    result_2 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_of_mul_u128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1, ScratchReg &result_2) {
    // # Machine code for function of_mul_u128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rax, $rcx, $rdx, $rdi
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rax, $rcx, $rdi, $rdx
    //   $rsi = MOV64rr $rdx
    //   $r8 = MOV64rr killed $rax
    //   TEST64rr renamable $rdi, renamable $rdi, implicit-def $eflags
    //   renamable $al = SETCCr 5, implicit killed $eflags
    //   TEST64rr renamable $rcx, renamable $rcx, implicit-def $eflags
    //   renamable $r9b = SETCCr 5, implicit killed $eflags
    //   renamable $r9b = AND8rr killed renamable $r9b(tied-def 0), killed renamable $al, implicit-def dead $eflags
    //   $rax = MOV64rr killed $rcx
    //   MUL64r killed $rdx, implicit-def $rax, implicit-def dead $rdx, implicit-def $eflags, implicit killed $rax
    //   $rcx = MOV64rr killed $rax
    //   renamable $r10b = SETCCr 0, implicit killed $eflags
    //   $rax = MOV64rr killed $rdi
    //   MUL64r renamable $r8, implicit-def $rax, implicit-def dead $rdx, implicit-def $eflags, implicit killed $rax
    //   renamable $dil = SETCCr 0, implicit killed $eflags
    //   renamable $dil = OR8rr killed renamable $dil(tied-def 0), killed renamable $r10b, implicit-def dead $eflags
    //   renamable $dil = OR8rr killed renamable $dil(tied-def 0), killed renamable $r9b, implicit-def dead $eflags
    //   $rcx = ADD64rr killed $rcx(tied-def 0), killed $rax, implicit-def dead $eflags
    //   $rax = MOV64rr killed $r8
    //   MUL64r killed renamable $rsi, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    //   renamable $rcx = ADD64rr killed renamable $rcx(tied-def 0), killed renamable $rdx, implicit-def $eflags
    //   renamable $dl = SETCCr 2, implicit killed $eflags
    //   renamable $dl = OR8rr killed renamable $dl(tied-def 0), killed renamable $dil, implicit-def dead $eflags
    //   renamable $edx = MOVZX32rr8 killed renamable $dl
    //   RET64 killed $rax, killed $rcx, killed $edx
    // 
    // # End machine code for function of_mul_u128.
    // 

    // Mapping ax to param_0
    // Mapping cx to param_1
    // Mapping dx to param_2
    // Mapping di to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_r9{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    ScratchReg scratch_r8{derived()};
    ScratchReg scratch_r10{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1, &param_2, &param_3}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1, &param_2, &param_3}, reg_backup_dx);


    // $rsi = MOV64rr $rdx
    // aliasing si to dx
    // si is an alias for operand param_2


    // $r8 = MOV64rr killed $rax
    // aliasing r8 to ax
    // r8 is an alias for operand param_0
    // source ax is killed, all aliases redirected and marked as dead


    // TEST64rr renamable $rdi, renamable $rdi, implicit-def $eflags
    do {
    {
    auto cond0 = param_3.encodeable_as_imm32_sext();
    if (cond0) {
        AsmReg op0 = param_3.as_reg(this);
        ASMD(TEST64ri, op0, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_3.encodeable_as_mem();
    if (cond1) {
        AsmReg op1 = param_3.as_reg(this);
        ASMD(TEST64mr, (*cond1), op1);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_3.as_reg(this);
        AsmReg op1 = param_3.as_reg(this);
        ASMD(TEST64rr, op0, op1);
        break;
    }
    }
    } while (false);


    // renamable $al = SETCCr 5, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETNZ8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // TEST64rr renamable $rcx, renamable $rcx, implicit-def $eflags
    do {
    {
    auto cond2 = param_1.encodeable_as_imm32_sext();
    if (cond2) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(TEST64ri, op0, (*cond2));
        break;
    }
    }
    {
    auto cond3 = param_1.encodeable_as_mem();
    if (cond3) {
        AsmReg op1 = param_1.as_reg(this);
        ASMD(TEST64mr, (*cond3), op1);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(TEST64rr, op0, op1);
        break;
    }
    }
    } while (false);


    // renamable $r9b = SETCCr 5, implicit killed $eflags
    {
    if (1) {
        // def r9 has not been allocated yet
        scratch_r9.alloc_from_bank(0);
        ASMD(SETNZ8r, scratch_r9.cur_reg);
    }
    }
    // result r9 is marked as alive


    // renamable $r9b = AND8rr killed renamable $r9b(tied-def 0), killed renamable $al, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(r9) is the same as its tied destination
        assert(scratch_r9.cur_reg.valid());
        ASMD(AND8rr, scratch_r9.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument r9 is killed and marked as dead
    // argument ax is killed and marked as dead
    // result r9 is marked as alive


    // $rax = MOV64rr killed $rcx
    // aliasing ax to cx
    // ax is an alias for operand param_1
    // source cx is killed, all aliases redirected and marked as dead


    // MUL64r killed $rdx, implicit-def $rax, implicit-def dead $rdx, implicit-def $eflags, implicit killed $rax
    do {
    {
    auto cond4 = param_2.encodeable_as_mem();
    if (cond4) {
        // fixing reg 0 for cond (cond4)
        AsmReg op4_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64m, (*cond4));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_2.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64r, op0);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as dead


    // $rcx = MOV64rr killed $rax
    // aliasing cx to ax
    // source ax is killed, all aliases redirected and marked as dead


    // renamable $r10b = SETCCr 0, implicit killed $eflags
    {
    if (1) {
        // def r10 has not been allocated yet
        scratch_r10.alloc_from_bank(0);
        ASMD(SETO8r, scratch_r10.cur_reg);
    }
    }
    // result r10 is marked as alive


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // cx is still aliased to the value of ax so we emit an explicit copy
    scratch_cx.alloc_from_bank(0);
    ASMD(MOV64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
    // ax is an alias for operand param_3
    // source di is killed, all aliases redirected and marked as dead


    // MUL64r renamable $r8, implicit-def $rax, implicit-def dead $rdx, implicit-def $eflags, implicit killed $rax
    do {
    {
    auto cond5 = param_0.encodeable_as_mem();
    if (cond5) {
        // fixing reg 0 for cond (cond5)
        AsmReg op4_tmp = param_3.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64m, (*cond5));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_3.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64r, op0);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as dead


    // renamable $dil = SETCCr 0, implicit killed $eflags
    {
    if (1) {
        // def di has not been allocated yet
        scratch_di.alloc_from_bank(0);
        ASMD(SETO8r, scratch_di.cur_reg);
    }
    }
    // result di is marked as alive


    // renamable $dil = OR8rr killed renamable $dil(tied-def 0), killed renamable $r10b, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(di) is the same as its tied destination
        assert(scratch_di.cur_reg.valid());
        ASMD(OR8rr, scratch_di.cur_reg, scratch_r10.cur_reg);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument r10 is killed and marked as dead
    // result di is marked as alive


    // renamable $dil = OR8rr killed renamable $dil(tied-def 0), killed renamable $r9b, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(di) is the same as its tied destination
        assert(scratch_di.cur_reg.valid());
        ASMD(OR8rr, scratch_di.cur_reg, scratch_r9.cur_reg);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument r9 is killed and marked as dead
    // result di is marked as alive


    // $rcx = ADD64rr killed $rcx(tied-def 0), killed $rax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(ADD64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result cx is marked as alive


    // $rax = MOV64rr killed $r8
    // aliasing ax to r8
    // ax is an alias for operand param_0
    // source r8 is killed, all aliases redirected and marked as dead


    // MUL64r killed renamable $rsi, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    do {
    {
    auto cond6 = param_2.encodeable_as_mem();
    if (cond6) {
        // fixing reg 0 for cond (cond6)
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64m, (*cond6));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_2.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op4_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op4_tmp);
        ASMD(MUL64r, op0);
        break;
    }
    }
    } while (false);
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // renamable $rcx = ADD64rr killed renamable $rcx(tied-def 0), killed renamable $rdx, implicit-def $eflags
    do {
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(ADD64rr, scratch_cx.cur_reg, scratch_dx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument dx is killed and marked as dead
    // result cx is marked as alive


    // renamable $dl = SETCCr 2, implicit killed $eflags
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETC8r, scratch_dx.cur_reg);
    }
    }
    // result dx is marked as alive


    // renamable $dl = OR8rr killed renamable $dl(tied-def 0), killed renamable $dil, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(dx) is the same as its tied destination
        assert(scratch_dx.cur_reg.valid());
        ASMD(OR8rr, scratch_dx.cur_reg, scratch_di.cur_reg);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead
    // argument di is killed and marked as dead
    // result dx is marked as alive


    // renamable $edx = MOVZX32rr8 killed renamable $dl
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(MOVZXr32r8, scratch_dx.cur_reg, scratch_dx.cur_reg);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive


    // RET64 killed $rax, killed $rcx, killed $edx
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, true);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg cx as result_1
    result_1 = std::move(scratch_cx);
    // returning reg dx as result_2
    result_2 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_addf32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function addf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $xmm0 = nofpexcept ADDSSrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function addf32.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept ADDSSrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        ASMD(SSE_ADDSSrm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SSE_ADDSSrr, scratch_xmm0.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_subf32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function subf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $xmm0 = nofpexcept SUBSSrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function subf32.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept SUBSSrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        ASMD(SSE_SUBSSrm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SSE_SUBSSrr, scratch_xmm0.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_mulf32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function mulf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $xmm0 = nofpexcept MULSSrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function mulf32.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept MULSSrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        ASMD(SSE_MULSSrm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SSE_MULSSrr, scratch_xmm0.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_divf32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function divf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $xmm0 = nofpexcept DIVSSrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function divf32.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept DIVSSrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        ASMD(SSE_DIVSSrm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SSE_DIVSSrr, scratch_xmm0.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_addf64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function addf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $xmm0 = nofpexcept ADDSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function addf64.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept ADDSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        ASMD(SSE_ADDSDrm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SSE_ADDSDrr, scratch_xmm0.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_subf64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function subf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $xmm0 = nofpexcept SUBSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function subf64.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept SUBSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        ASMD(SSE_SUBSDrm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SSE_SUBSDrr, scratch_xmm0.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_mulf64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function mulf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $xmm0 = nofpexcept MULSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function mulf64.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept MULSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        ASMD(SSE_MULSDrm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SSE_MULSDrr, scratch_xmm0.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_divf64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function divf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $xmm0 = nofpexcept DIVSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function divf64.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept DIVSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        ASMD(SSE_DIVSDrm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SSE_DIVSDrr, scratch_xmm0.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fnegf32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function fnegf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Constant Pool:
    //   cp#0: <float -0.000000e+00, float -0.000000e+00, float -0.000000e+00, float -0.000000e+00>, align=16
    // Function Live Ins: $xmm0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $xmm0
    //   renamable $xmm0 = XORPSrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load (s128) from constant-pool)
    //   RET64 killed $xmm0
    // 
    // # End machine code for function fnegf32.
    // 

    // Mapping xmm0 to param_0
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = XORPSrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load (s128) from constant-pool)
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        SymRef &op5_sym = this->sym_fnegf32_cp0;
        if (op5_sym == Assembler::INVALID_SYM_REF) [[unlikely]] {
            const std::array<u8, 16> data = {0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x80};
            op5_sym = derived()->assembler.sym_def_data("", data, 16, true, false, true, false);
        }
        ASMD(SSE_XORPSrm, scratch_xmm0.cur_reg, FE_MEM(FE_IP, 0, FE_NOREG, 0));
        derived()->assembler.reloc_text_pc32(op5_sym, derived()->assembler.text_cur_off() - 4, -4);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fnegf64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function fnegf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Constant Pool:
    //   cp#0: <double -0.000000e+00, double -0.000000e+00>, align=16
    // Function Live Ins: $xmm0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $xmm0
    //   renamable $xmm0 = XORPSrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load (s128) from constant-pool)
    //   RET64 killed $xmm0
    // 
    // # End machine code for function fnegf64.
    // 

    // Mapping xmm0 to param_0
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = XORPSrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load (s128) from constant-pool)
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        SymRef &op5_sym = this->sym_fnegf64_cp0;
        if (op5_sym == Assembler::INVALID_SYM_REF) [[unlikely]] {
            const std::array<u8, 16> data = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80};
            op5_sym = derived()->assembler.sym_def_data("", data, 16, true, false, true, false);
        }
        ASMD(SSE_XORPSrm, scratch_xmm0.cur_reg, FE_MEM(FE_IP, 0, FE_NOREG, 0));
        derived()->assembler.reloc_text_pc32(op5_sym, derived()->assembler.text_cur_off() - 4, -4);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fabsf32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function fabsf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Constant Pool:
    //   cp#0: <float 0x7FFFFFFFE0000000, float 0x7FFFFFFFE0000000, float 0x7FFFFFFFE0000000, float 0x7FFFFFFFE0000000>, align=16
    // Function Live Ins: $xmm0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $xmm0
    //   renamable $xmm0 = ANDPSrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load (s128) from constant-pool)
    //   RET64 killed $xmm0
    // 
    // # End machine code for function fabsf32.
    // 

    // Mapping xmm0 to param_0
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = ANDPSrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load (s128) from constant-pool)
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        SymRef &op5_sym = this->sym_fabsf32_cp0;
        if (op5_sym == Assembler::INVALID_SYM_REF) [[unlikely]] {
            const std::array<u8, 16> data = {0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F};
            op5_sym = derived()->assembler.sym_def_data("", data, 16, true, false, true, false);
        }
        ASMD(SSE_ANDPSrm, scratch_xmm0.cur_reg, FE_MEM(FE_IP, 0, FE_NOREG, 0));
        derived()->assembler.reloc_text_pc32(op5_sym, derived()->assembler.text_cur_off() - 4, -4);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fabsf64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function fabsf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Constant Pool:
    //   cp#0: <double 0x7FFFFFFFFFFFFFFF, double 0x7FFFFFFFFFFFFFFF>, align=16
    // Function Live Ins: $xmm0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $xmm0
    //   renamable $xmm0 = ANDPSrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load (s128) from constant-pool)
    //   RET64 killed $xmm0
    // 
    // # End machine code for function fabsf64.
    // 

    // Mapping xmm0 to param_0
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = ANDPSrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load (s128) from constant-pool)
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        SymRef &op5_sym = this->sym_fabsf64_cp0;
        if (op5_sym == Assembler::INVALID_SYM_REF) [[unlikely]] {
            const std::array<u8, 16> data = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F};
            op5_sym = derived()->assembler.sym_def_data("", data, 16, true, false, true, false);
        }
        ASMD(SSE_ANDPSrm, scratch_xmm0.cur_reg, FE_MEM(FE_IP, 0, FE_NOREG, 0));
        derived()->assembler.reloc_text_pc32(op5_sym, derived()->assembler.text_cur_off() - 4, -4);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fmaf32(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0) {
    // # Machine code for function fmaf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1, $xmm2
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $xmm0, $xmm1, $xmm2
    //   renamable $xmm0 = nofpexcept MULSSrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    //   renamable $xmm0 = nofpexcept ADDSSrr killed renamable $xmm0(tied-def 0), killed renamable $xmm2, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function fmaf32.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    // Mapping xmm2 to param_2
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_xmm2{derived()};


    // renamable $xmm0 = nofpexcept MULSSrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        ASMD(SSE_MULSSrm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SSE_MULSSrr, scratch_xmm0.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead
    // result xmm0 is marked as alive


    // renamable $xmm0 = nofpexcept ADDSSrr killed renamable $xmm0(tied-def 0), killed renamable $xmm2, implicit $mxcsr
    do {
    {
    auto cond1 = param_2.encodeable_as_mem();
    if (cond1) {
        // operand 1(xmm0) is the same as its tied destination
        assert(scratch_xmm0.cur_reg.valid());
        ASMD(SSE_ADDSSrm, scratch_xmm0.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(xmm0) is the same as its tied destination
        assert(scratch_xmm0.cur_reg.valid());
        AsmReg op2 = param_2.as_reg(this);
        ASMD(SSE_ADDSSrr, scratch_xmm0.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm2 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fmaf64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0) {
    // # Machine code for function fmaf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1, $xmm2
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $xmm0, $xmm1, $xmm2
    //   renamable $xmm0 = nofpexcept MULSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    //   renamable $xmm0 = nofpexcept ADDSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm2, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function fmaf64.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    // Mapping xmm2 to param_2
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_xmm2{derived()};


    // renamable $xmm0 = nofpexcept MULSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        ASMD(SSE_MULSDrm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SSE_MULSDrr, scratch_xmm0.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead
    // result xmm0 is marked as alive


    // renamable $xmm0 = nofpexcept ADDSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm2, implicit $mxcsr
    do {
    {
    auto cond1 = param_2.encodeable_as_mem();
    if (cond1) {
        // operand 1(xmm0) is the same as its tied destination
        assert(scratch_xmm0.cur_reg.valid());
        ASMD(SSE_ADDSDrm, scratch_xmm0.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(xmm0) is the same as its tied destination
        assert(scratch_xmm0.cur_reg.valid());
        AsmReg op2 = param_2.as_reg(this);
        ASMD(SSE_ADDSDrr, scratch_xmm0.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm2 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f64tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f64tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $xmm0
    //   renamable $xmm0 = nofpexcept CVTSD2SSrr killed renamable $xmm0, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function f64tof32.
    // 

    // Mapping xmm0 to param_0
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept CVTSD2SSrr killed renamable $xmm0, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSD2SSrm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_xmm0, 1)) {
            op1 = scratch_xmm0.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSD2SSrr, scratch_xmm0.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f32tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f32tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $xmm0
    //   renamable $xmm0 = nofpexcept CVTSS2SDrr killed renamable $xmm0, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function f32tof64.
    // 

    // Mapping xmm0 to param_0
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept CVTSS2SDrr killed renamable $xmm0, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSS2SDrm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_xmm0, 1)) {
            op1 = scratch_xmm0.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSS2SDrr, scratch_xmm0.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f32toi32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f32toi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $xmm0
    //   renamable $eax = nofpexcept CVTTSS2SIrr killed renamable $xmm0, implicit $mxcsr
    //   RET64 killed $eax
    // 
    // # End machine code for function f32toi32.
    // 

    // Mapping xmm0 to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = nofpexcept CVTTSS2SIrr killed renamable $xmm0, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_CVTTSS2SI32rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_CVTTSS2SI32rr, scratch_ax.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f32tou32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f32tou32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $xmm0
    //   renamable $rax = nofpexcept CVTTSS2SI64rr killed renamable $xmm0, implicit $mxcsr
    //   $eax = KILL killed renamable $eax, implicit killed $rax
    //   RET64 killed $eax
    // 
    // # End machine code for function f32tou32.
    // 

    // Mapping xmm0 to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $rax = nofpexcept CVTTSS2SI64rr killed renamable $xmm0, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_CVTTSS2SI64rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_CVTTSS2SI64rr, scratch_ax.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // $eax = KILL killed renamable $eax, implicit killed $rax
    // KILL is a no-op


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f32toi64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f32toi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $xmm0
    //   renamable $rax = nofpexcept CVTTSS2SI64rr killed renamable $xmm0, implicit $mxcsr
    //   RET64 killed $rax
    // 
    // # End machine code for function f32toi64.
    // 

    // Mapping xmm0 to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $rax = nofpexcept CVTTSS2SI64rr killed renamable $xmm0, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_CVTTSS2SI64rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_CVTTSS2SI64rr, scratch_ax.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f32tou64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f32tou64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Constant Pool:
    //   cp#0: 0x43E0000000000000, align=4
    // Function Live Ins: $xmm0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $xmm0
    //   renamable $rcx = nofpexcept CVTTSS2SI64rr_Int renamable $xmm0, implicit $mxcsr
    //   $rdx = MOV64rr $rcx
    //   renamable $rdx = SAR64ri killed renamable $rdx(tied-def 0), 63, implicit-def dead $eflags
    //   renamable $xmm0 = nofpexcept SUBSSrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load (s32) from constant-pool)
    //   renamable $rax = nofpexcept CVTTSS2SI64rr_Int killed renamable $xmm0, implicit $mxcsr
    //   renamable $rax = AND64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def dead $eflags
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function f32tou64.
    // 

    // Mapping xmm0 to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $rcx = nofpexcept CVTTSS2SI64rr_Int renamable $xmm0, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(SSE_CVTTSS2SI64rm, scratch_cx.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(SSE_CVTTSS2SI64rr, scratch_cx.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // result cx is marked as alive


    // $rdx = MOV64rr $rcx
    // aliasing dx to cx


    // renamable $rdx = SAR64ri killed renamable $rdx(tied-def 0), 63, implicit-def dead $eflags
    {
    if (1) {
        // operand cx has some references
        AsmReg reg_dx = scratch_dx.alloc_from_bank(0);
        ASMD(MOV64rr, reg_dx, scratch_cx.cur_reg);
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SAR64ri, scratch_dx.cur_reg, 0x3f);
    }
    }
    // argument dx is killed and marked as dead
    // removing alias from dx to cx
    // result dx is marked as alive


    // renamable $xmm0 = nofpexcept SUBSSrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load (s32) from constant-pool)
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        SymRef &op5_sym = this->sym_f32tou64_cp0;
        if (op5_sym == Assembler::INVALID_SYM_REF) [[unlikely]] {
            const std::array<u8, 4> data = {0x0, 0x0, 0x0, 0x5F};
            op5_sym = derived()->assembler.sym_def_data("", data, 4, true, false, true, false);
        }
        ASMD(SSE_SUBSSrm, scratch_xmm0.cur_reg, FE_MEM(FE_IP, 0, FE_NOREG, 0));
        derived()->assembler.reloc_text_pc32(op5_sym, derived()->assembler.text_cur_off() - 4, -4);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result xmm0 is marked as alive


    // renamable $rax = nofpexcept CVTTSS2SI64rr_Int killed renamable $xmm0, implicit $mxcsr
    do {
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_CVTTSS2SI64rr, scratch_ax.cur_reg, scratch_xmm0.cur_reg);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = AND64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND64rr, scratch_ax.cur_reg, scratch_dx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(OR64rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f64toi32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f64toi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $xmm0
    //   renamable $eax = nofpexcept CVTTSD2SIrr killed renamable $xmm0, implicit $mxcsr
    //   RET64 killed $eax
    // 
    // # End machine code for function f64toi32.
    // 

    // Mapping xmm0 to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = nofpexcept CVTTSD2SIrr killed renamable $xmm0, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_CVTTSD2SI32rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_CVTTSD2SI32rr, scratch_ax.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f64tou32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f64tou32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $xmm0
    //   renamable $rax = nofpexcept CVTTSD2SI64rr killed renamable $xmm0, implicit $mxcsr
    //   $eax = KILL killed renamable $eax, implicit killed $rax
    //   RET64 killed $eax
    // 
    // # End machine code for function f64tou32.
    // 

    // Mapping xmm0 to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $rax = nofpexcept CVTTSD2SI64rr killed renamable $xmm0, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_CVTTSD2SI64rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_CVTTSD2SI64rr, scratch_ax.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // $eax = KILL killed renamable $eax, implicit killed $rax
    // KILL is a no-op


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f64toi64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f64toi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $xmm0
    //   renamable $rax = nofpexcept CVTTSD2SI64rr killed renamable $xmm0, implicit $mxcsr
    //   RET64 killed $rax
    // 
    // # End machine code for function f64toi64.
    // 

    // Mapping xmm0 to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $rax = nofpexcept CVTTSD2SI64rr killed renamable $xmm0, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_CVTTSD2SI64rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_CVTTSD2SI64rr, scratch_ax.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_f64tou64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function f64tou64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Constant Pool:
    //   cp#0: 0x43E0000000000000, align=8
    // Function Live Ins: $xmm0
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $xmm0
    //   renamable $rcx = nofpexcept CVTTSD2SI64rr_Int renamable $xmm0, implicit $mxcsr
    //   $rdx = MOV64rr $rcx
    //   renamable $rdx = SAR64ri killed renamable $rdx(tied-def 0), 63, implicit-def dead $eflags
    //   renamable $xmm0 = nofpexcept SUBSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load (s64) from constant-pool)
    //   renamable $rax = nofpexcept CVTTSD2SI64rr_Int killed renamable $xmm0, implicit $mxcsr
    //   renamable $rax = AND64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def dead $eflags
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function f64tou64.
    // 

    // Mapping xmm0 to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $rcx = nofpexcept CVTTSD2SI64rr_Int renamable $xmm0, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(SSE_CVTTSD2SI64rm, scratch_cx.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(SSE_CVTTSD2SI64rr, scratch_cx.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // result cx is marked as alive


    // $rdx = MOV64rr $rcx
    // aliasing dx to cx


    // renamable $rdx = SAR64ri killed renamable $rdx(tied-def 0), 63, implicit-def dead $eflags
    {
    if (1) {
        // operand cx has some references
        AsmReg reg_dx = scratch_dx.alloc_from_bank(0);
        ASMD(MOV64rr, reg_dx, scratch_cx.cur_reg);
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SAR64ri, scratch_dx.cur_reg, 0x3f);
    }
    }
    // argument dx is killed and marked as dead
    // removing alias from dx to cx
    // result dx is marked as alive


    // renamable $xmm0 = nofpexcept SUBSDrm killed renamable $xmm0(tied-def 0), $rip, 1, $noreg, %const.0, $noreg, implicit $mxcsr :: (load (s64) from constant-pool)
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        SymRef &op5_sym = this->sym_f64tou64_cp0;
        if (op5_sym == Assembler::INVALID_SYM_REF) [[unlikely]] {
            const std::array<u8, 8> data = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xE0, 0x43};
            op5_sym = derived()->assembler.sym_def_data("", data, 8, true, false, true, false);
        }
        ASMD(SSE_SUBSDrm, scratch_xmm0.cur_reg, FE_MEM(FE_IP, 0, FE_NOREG, 0));
        derived()->assembler.reloc_text_pc32(op5_sym, derived()->assembler.text_cur_off() - 4, -4);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result xmm0 is marked as alive


    // renamable $rax = nofpexcept CVTTSD2SI64rr_Int killed renamable $xmm0, implicit $mxcsr
    do {
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_CVTTSD2SI64rr, scratch_ax.cur_reg, scratch_xmm0.cur_reg);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = AND64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND64rr, scratch_ax.cur_reg, scratch_dx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(OR64rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_i8tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function i8tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVSX32rr8 killed renamable $dil, implicit killed $edi
    //   renamable $xmm0 = nofpexcept CVTSI2SSrr killed renamable $eax, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function i8tof32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOVSX32rr8 killed renamable $dil, implicit killed $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVSXr32r8, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $xmm0 = nofpexcept CVTSI2SSrr killed renamable $eax, implicit $mxcsr
    do {
    {
    if (1) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SS32rr, scratch_xmm0.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_i16tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function i16tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVSX32rr16 killed renamable $di, implicit killed $edi
    //   renamable $xmm0 = nofpexcept CVTSI2SSrr killed renamable $eax, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function i16tof32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOVSX32rr16 killed renamable $di, implicit killed $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVSXr32r16, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $xmm0 = nofpexcept CVTSI2SSrr killed renamable $eax, implicit $mxcsr
    do {
    {
    if (1) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SS32rr, scratch_xmm0.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_i32tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function i32tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $xmm0 = nofpexcept CVTSI2SSrr killed renamable $edi, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function i32tof32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept CVTSI2SSrr killed renamable $edi, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SS32rm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SS32rr, scratch_xmm0.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_i64tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function i64tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $xmm0 = nofpexcept CVTSI642SSrr killed renamable $rdi, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function i64tof32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept CVTSI642SSrr killed renamable $rdi, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SS64rm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SS64rr, scratch_xmm0.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_u8tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function u8tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVZX32rr8 killed renamable $dil, implicit killed $edi
    //   renamable $xmm0 = nofpexcept CVTSI2SSrr killed renamable $eax, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function u8tof32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOVZX32rr8 killed renamable $dil, implicit killed $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r8, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $xmm0 = nofpexcept CVTSI2SSrr killed renamable $eax, implicit $mxcsr
    do {
    {
    if (1) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SS32rr, scratch_xmm0.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_u16tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function u16tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVZX32rr16 killed renamable $di, implicit killed $edi
    //   renamable $xmm0 = nofpexcept CVTSI2SSrr killed renamable $eax, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function u16tof32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOVZX32rr16 killed renamable $di, implicit killed $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r16, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $xmm0 = nofpexcept CVTSI2SSrr killed renamable $eax, implicit $mxcsr
    do {
    {
    if (1) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SS32rr, scratch_xmm0.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_u32tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function u32tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOV32rr killed renamable $edi, implicit-def $rax
    //   renamable $xmm0 = nofpexcept CVTSI642SSrr killed renamable $rax, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function u32tof32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOV32rr killed renamable $edi, implicit-def $rax
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32rr, scratch_ax.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $xmm0 = nofpexcept CVTSI642SSrr killed renamable $rax, implicit $mxcsr
    do {
    {
    if (1) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SS64rr, scratch_xmm0.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_u64tof32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function u64tof32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   successors: %bb.2(0x40000000), %bb.1(0x40000000); %bb.2(50.00%), %bb.1(50.00%)
    //   liveins: $rdi
    //   TEST64rr renamable $rdi, renamable $rdi, implicit-def $eflags
    //   JCC_1 %bb.1, 8, implicit killed $eflags
    // 
    // bb.2 (%ir-block.1):
    // ; predecessors: %bb.0
    //   liveins: $rdi
    //   renamable $xmm0 = nofpexcept CVTSI642SSrr killed renamable $rdi, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // bb.1:
    // ; predecessors: %bb.0
    //   liveins: $rdi
    //   $rax = MOV64rr $rdi
    //   renamable $rax = SHR64ri killed renamable $rax(tied-def 0), 1, implicit-def dead $eflags
    //   renamable $edi = AND32ri killed renamable $edi(tied-def 0), 1, implicit-def dead $eflags, implicit killed $rdi, implicit-def $rdi
    //   renamable $rdi = OR64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
    //   renamable $xmm0 = nofpexcept CVTSI642SSrr killed renamable $rdi, implicit $mxcsr
    //   renamable $xmm0 = nofpexcept ADDSSrr killed renamable $xmm0(tied-def 0), killed renamable $xmm0, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function u64tof32.
    // 

    // Mapping di to param_0

    // Creating label for convergence point at the end of the function
    Label ret_converge_label = derived()->assembler.label_create();
    // Creating labels for blocks that are jump targets
    Label block2_label = derived()->assembler.label_create();
    Label block1_label = derived()->assembler.label_create();

    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // TEST64rr renamable $rdi, renamable $rdi, implicit-def $eflags
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(TEST64ri, op0, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        AsmReg op1 = param_0.as_reg(this);
        ASMD(TEST64mr, (*cond1), op1);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(TEST64rr, op0, op1);
        break;
    }
    }
    } while (false);


    // JCC_1 %bb.1, 8, implicit killed $eflags
    // Preparing jump to other block
    // di is live-out
    // xmm0 is used in the function later on
    // ax is used in the function later on
    // Handling register ax
    // ax is not live-out and needs to be allocated
    scratch_ax.alloc_from_bank(0);
    // Handling register xmm0
    // xmm0 is not live-out and needs to be allocated
    scratch_xmm0.alloc_from_bank(1);
    // Handling register di
    // di is mapped to operand param_0, materializing it
    param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
    derived()->generate_raw_jump(CompilerX64::Jump::js, block1_label);


    // Starting encoding of block 2
    derived()->assembler.label_place(block2_label);
    // Marking di as live


    // renamable $xmm0 = nofpexcept CVTSI642SSrr killed renamable $rdi, implicit $mxcsr
    do {
    {
    if (1) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SS64rr, scratch_xmm0.cur_reg, scratch_di.cur_reg);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // handling return for xmm0
    // value already in register, nothing to do
    // Jumping to convergence point at the end of the encoding function
    derived()->generate_raw_jump(CompilerX64::Jump::jmp, ret_converge_label);

    // Starting encoding of block 1
    derived()->assembler.label_place(block1_label);
    // Marking di as live


    // $rax = MOV64rr $rdi
    // aliasing ax to di


    // renamable $rax = SHR64ri killed renamable $rax(tied-def 0), 1, implicit-def dead $eflags
    {
    if (1) {
        // operand di has some references
        AsmReg reg_ax = scratch_ax.alloc_from_bank(0);
        ASMD(MOV64rr, reg_ax, scratch_di.cur_reg);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SHR64ri, scratch_ax.cur_reg, 0x1);
    }
    }
    // argument ax is killed and marked as dead
    // removing alias from ax to di
    // result ax is marked as alive


    // renamable $edi = AND32ri killed renamable $edi(tied-def 0), 1, implicit-def dead $eflags, implicit killed $rdi, implicit-def $rdi
    {
    if (1) {
        // operand 1(di) is the same as its tied destination
        assert(scratch_di.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(AND32ri, scratch_di.cur_reg, 0x1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result di is marked as alive
    // result di is marked as alive


    // renamable $rdi = OR64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(di) is the same as its tied destination
        assert(scratch_di.cur_reg.valid());
        ASMD(OR64rr, scratch_di.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument ax is killed and marked as dead
    // result di is marked as alive


    // renamable $xmm0 = nofpexcept CVTSI642SSrr killed renamable $rdi, implicit $mxcsr
    do {
    {
    if (1) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SS64rr, scratch_xmm0.cur_reg, scratch_di.cur_reg);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result xmm0 is marked as alive


    // renamable $xmm0 = nofpexcept ADDSSrr killed renamable $xmm0(tied-def 0), killed renamable $xmm0, implicit $mxcsr
    do {
    {
    if (1) {
        // operand 1(xmm0) is the same as its tied destination
        assert(scratch_xmm0.cur_reg.valid());
        ASMD(SSE_ADDSSrr, scratch_xmm0.cur_reg, scratch_xmm0.cur_reg);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm0 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // handling return for xmm0
    // value already in register, nothing to do
    // Omitting jump to convergence as this is the last block

    // Placing the convergence point for registers here
    derived()->assembler.label_place(ret_converge_label);
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_i8tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function i8tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVSX32rr8 killed renamable $dil, implicit killed $edi
    //   renamable $xmm0 = CVTSI2SDrr killed renamable $eax
    //   RET64 killed $xmm0
    // 
    // # End machine code for function i8tof64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOVSX32rr8 killed renamable $dil, implicit killed $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVSXr32r8, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $xmm0 = CVTSI2SDrr killed renamable $eax
    do {
    {
    if (1) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SD32rr, scratch_xmm0.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_i16tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function i16tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVSX32rr16 killed renamable $di, implicit killed $edi
    //   renamable $xmm0 = CVTSI2SDrr killed renamable $eax
    //   RET64 killed $xmm0
    // 
    // # End machine code for function i16tof64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOVSX32rr16 killed renamable $di, implicit killed $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVSXr32r16, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $xmm0 = CVTSI2SDrr killed renamable $eax
    do {
    {
    if (1) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SD32rr, scratch_xmm0.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_i32tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function i32tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $xmm0 = CVTSI2SDrr killed renamable $edi
    //   RET64 killed $xmm0
    // 
    // # End machine code for function i32tof64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = CVTSI2SDrr killed renamable $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SD32rm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SD32rr, scratch_xmm0.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_i64tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function i64tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $xmm0 = nofpexcept CVTSI642SDrr killed renamable $rdi, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function i64tof64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept CVTSI642SDrr killed renamable $rdi, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SD64rm, scratch_xmm0.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SD64rr, scratch_xmm0.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_u8tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function u8tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVZX32rr8 killed renamable $dil, implicit killed $edi
    //   renamable $xmm0 = CVTSI2SDrr killed renamable $eax
    //   RET64 killed $xmm0
    // 
    // # End machine code for function u8tof64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOVZX32rr8 killed renamable $dil, implicit killed $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r8, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $xmm0 = CVTSI2SDrr killed renamable $eax
    do {
    {
    if (1) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SD32rr, scratch_xmm0.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_u16tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function u16tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVZX32rr16 killed renamable $di, implicit killed $edi
    //   renamable $xmm0 = CVTSI2SDrr killed renamable $eax
    //   RET64 killed $xmm0
    // 
    // # End machine code for function u16tof64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOVZX32rr16 killed renamable $di, implicit killed $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r16, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $xmm0 = CVTSI2SDrr killed renamable $eax
    do {
    {
    if (1) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SD32rr, scratch_xmm0.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_u32tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function u32tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOV32rr killed renamable $edi, implicit-def $rax
    //   renamable $xmm0 = nofpexcept CVTSI642SDrr killed renamable $rax, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function u32tof64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOV32rr killed renamable $edi, implicit-def $rax
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32rr, scratch_ax.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $xmm0 = nofpexcept CVTSI642SDrr killed renamable $rax, implicit $mxcsr
    do {
    {
    if (1) {
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_CVTSI2SD64rr, scratch_xmm0.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_u64tof64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function u64tof64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Constant Pool:
    //   cp#0: <i32 1127219200, i32 1160773632, i32 0, i32 0>, align=16
    //   cp#1: <double 0x4330000000000000, double 0x4530000000000000>, align=16
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $xmm1 = MOV64toPQIrr killed renamable $rdi
    //   renamable $xmm1 = PUNPCKLDQrm killed renamable $xmm1(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load (s128) from constant-pool)
    //   renamable $xmm1 = nofpexcept SUBPDrm killed renamable $xmm1(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load (s128) from constant-pool)
    //   $xmm0 = MOVAPDrr $xmm1
    //   renamable $xmm0 = UNPCKHPDrr killed renamable $xmm0(tied-def 0), $xmm1
    //   renamable $xmm0 = nofpexcept ADDSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    //   RET64 killed $xmm0
    // 
    // # End machine code for function u64tof64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm1 = MOV64toPQIrr killed renamable $rdi
    {
    if (1) {
        AsmReg op1 = param_0.as_reg(this);
        // def xmm1 has not been allocated yet
        scratch_xmm1.alloc_from_bank(1);
        ASMD(SSE_MOVQ_G2Xrr, scratch_xmm1.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // result xmm1 is marked as alive


    // renamable $xmm1 = PUNPCKLDQrm killed renamable $xmm1(tied-def 0), $rip, 1, $noreg, %const.0, $noreg :: (load (s128) from constant-pool)
    {
    if (1) {
        // operand 1(xmm1) is the same as its tied destination
        assert(scratch_xmm1.cur_reg.valid());
        SymRef &op5_sym = this->sym_u64tof64_cp0;
        if (op5_sym == Assembler::INVALID_SYM_REF) [[unlikely]] {
            const std::array<u8, 16> data = {0x0, 0x0, 0x30, 0x43, 0x0, 0x0, 0x30, 0x45, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
            op5_sym = derived()->assembler.sym_def_data("", data, 16, true, false, true, false);
        }
        ASMD(SSE_PUNPCKLDQrm, scratch_xmm1.cur_reg, FE_MEM(FE_IP, 0, FE_NOREG, 0));
        derived()->assembler.reloc_text_pc32(op5_sym, derived()->assembler.text_cur_off() - 4, -4);
    }
    }
    // argument xmm1 is killed and marked as dead
    // result xmm1 is marked as alive


    // renamable $xmm1 = nofpexcept SUBPDrm killed renamable $xmm1(tied-def 0), $rip, 1, $noreg, %const.1, $noreg, implicit $mxcsr :: (load (s128) from constant-pool)
    {
    if (1) {
        // operand 1(xmm1) is the same as its tied destination
        assert(scratch_xmm1.cur_reg.valid());
        SymRef &op5_sym = this->sym_u64tof64_cp1;
        if (op5_sym == Assembler::INVALID_SYM_REF) [[unlikely]] {
            const std::array<u8, 16> data = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x30, 0x43, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x30, 0x45};
            op5_sym = derived()->assembler.sym_def_data("", data, 16, true, false, true, false);
        }
        ASMD(SSE_SUBPDrm, scratch_xmm1.cur_reg, FE_MEM(FE_IP, 0, FE_NOREG, 0));
        derived()->assembler.reloc_text_pc32(op5_sym, derived()->assembler.text_cur_off() - 4, -4);
    }
    }
    // argument xmm1 is killed and marked as dead
    // result xmm1 is marked as alive


    // $xmm0 = MOVAPDrr $xmm1
    // aliasing xmm0 to xmm1


    // renamable $xmm0 = UNPCKHPDrr killed renamable $xmm0(tied-def 0), $xmm1
    {
    if (1) {
        // operand xmm1 has some references
        AsmReg reg_xmm0 = scratch_xmm0.alloc_from_bank(1);
        if (has_avx()) {
            ASMD(VMOVUPD128rr, reg_xmm0, scratch_xmm1.cur_reg);
        } else {
            ASMD(SSE_MOVUPDrr, reg_xmm0, scratch_xmm1.cur_reg);
        }
        // def xmm0 has not been allocated yet
        scratch_xmm0.alloc_from_bank(1);
        ASMD(SSE_UNPCKHPDrr, scratch_xmm0.cur_reg, scratch_xmm1.cur_reg);
    }
    }
    // argument xmm0 is killed and marked as dead
    // removing alias from xmm0 to xmm1
    // result xmm0 is marked as alive


    // renamable $xmm0 = nofpexcept ADDSDrr killed renamable $xmm0(tied-def 0), killed renamable $xmm1, implicit $mxcsr
    do {
    {
    if (1) {
        // operand 1(xmm0) is the same as its tied destination
        assert(scratch_xmm0.cur_reg.valid());
        ASMD(SSE_ADDSDrr, scratch_xmm0.cur_reg, scratch_xmm1.cur_reg);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sext_8_to_32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function sext_8_to_32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVSX32rr8 killed renamable $dil, implicit killed $edi
    //   RET64 killed $eax
    // 
    // # End machine code for function sext_8_to_32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOVSX32rr8 killed renamable $dil, implicit killed $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVSXr32r8, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sext_8_to_64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function sext_8_to_64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $edi = KILL killed $edi, implicit-def $rdi
    //   renamable $rax = MOVSX64rr8 killed renamable $dil, implicit killed $rdi
    //   RET64 killed $rax
    // 
    // # End machine code for function sext_8_to_64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $edi = KILL killed $edi, implicit-def $rdi
    // KILL is a no-op


    // renamable $rax = MOVSX64rr8 killed renamable $dil, implicit killed $rdi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVSXr64r8, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sext_16_to_32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function sext_16_to_32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVSX32rr16 killed renamable $di, implicit killed $edi
    //   RET64 killed $eax
    // 
    // # End machine code for function sext_16_to_32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOVSX32rr16 killed renamable $di, implicit killed $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVSXr32r16, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sext_16_to_64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function sext_16_to_64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $edi = KILL killed $edi, implicit-def $rdi
    //   renamable $rax = MOVSX64rr16 killed renamable $di, implicit killed $rdi
    //   RET64 killed $rax
    // 
    // # End machine code for function sext_16_to_64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $edi = KILL killed $edi, implicit-def $rdi
    // KILL is a no-op


    // renamable $rax = MOVSX64rr16 killed renamable $di, implicit killed $rdi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVSXr64r16, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sext_32_to_64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function sext_32_to_64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $rax = MOVSX64rr32 killed renamable $edi
    //   RET64 killed $rax
    // 
    // # End machine code for function sext_32_to_64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $rax = MOVSX64rr32 killed renamable $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVSXr64r32, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sext_arbitrary_to_32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sext_arbitrary_to_32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $ecx = MOV32rr killed $esi
    //   $eax = MOV32rr killed $edi
    //   renamable $eax = SHL32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit $cl
    //   $cl = KILL killed renamable $cl, implicit killed $ecx
    //   renamable $eax = exact SAR32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $eax
    // 
    // # End machine code for function sext_arbitrary_to_32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    auto cond0 = param_1.encodeable_as_imm32_sext();;
    auto cond1 = param_1.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond0)&&1) || (!(0||cond1)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $ecx = MOV32rr killed $esi
    // aliasing cx to si
    // cx is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $eax = SHL32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit $cl
    do {
    {
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        ASMD(SHL32ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHL32rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // $cl = KILL killed renamable $cl, implicit killed $ecx
    // KILL is a no-op


    // renamable $eax = exact SAR32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(SAR32ri, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SAR32rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_sext_arbitrary_to_64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sext_arbitrary_to_64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $esi, $rdi
    //   $ecx = MOV32rr killed $esi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit $cl
    //   $cl = KILL killed renamable $cl, implicit killed $ecx
    //   renamable $rax = exact SAR64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $rax
    // 
    // # End machine code for function sext_arbitrary_to_64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    auto cond0 = param_1.encodeable_as_imm32_sext();;
    auto cond1 = param_1.encodeable_as_imm32_sext();;
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if ((!(0||cond0)&&1) || (!(0||cond1)&&1)) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $ecx = MOV32rr killed $esi
    // aliasing cx to si
    // cx is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit $cl
    do {
    {
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SHL64ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SHL64rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // $cl = KILL killed renamable $cl, implicit killed $ecx
    // KILL is a no-op


    // renamable $rax = exact SAR64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    do {
    {
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(SAR64ri, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // fixing reg 1 for cond ()
        AsmReg op3_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, op3_tmp);
        ASMD(SAR64rr, scratch_ax.cur_reg, FE_CX);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fill_with_sign64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function fill_with_sign64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = SAR64ri killed renamable $rax(tied-def 0), 63, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function fill_with_sign64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // ax is an alias for operand param_0
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = SAR64ri killed renamable $rax(tied-def 0), 63, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        ASMD(SAR64ri, scratch_ax.cur_reg, 0x3f);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_zext_8_to_32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function zext_8_to_32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVZX32rr8 killed renamable $dil, implicit killed $edi
    //   RET64 killed $eax
    // 
    // # End machine code for function zext_8_to_32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOVZX32rr8 killed renamable $dil, implicit killed $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r8, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_zext_16_to_32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function zext_16_to_32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVZX32rr16 killed renamable $di, implicit killed $edi
    //   RET64 killed $eax
    // 
    // # End machine code for function zext_16_to_32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOVZX32rr16 killed renamable $di, implicit killed $edi
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r16, scratch_ax.cur_reg, op1);
    }
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_zext_32_to_64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function zext_32_to_64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOV32rr killed renamable $edi, implicit-def $rax
    //   RET64 killed $rax
    // 
    // # End machine code for function zext_32_to_64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOV32rr killed renamable $edi, implicit-def $rax
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32rr, scratch_ax.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_monotonic_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_monotonic_monotonic: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rsi
    //   LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store monotonic monotonic (s64) on %ir.0)
    //   renamable $dl = SETCCr 4, implicit killed $eflags
    //   RET64 killed $rax, killed $dl
    // 
    // # End machine code for function cmpxchg_u64_monotonic_monotonic.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1, &param_2}, reg_backup_ax);


    // $rax = MOV64rr killed $rsi
    // aliasing ax to si
    // ax is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store monotonic monotonic (s64) on %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond (cond0)
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, (*cond0), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument dx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 4, implicit killed $eflags
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETZ8r, scratch_dx.cur_reg);
    }
    }
    // result dx is marked as alive


    // RET64 killed $rax, killed $dl
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_acquire_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_acquire_monotonic: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rsi
    //   LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store acquire monotonic (s64) on %ir.0)
    //   renamable $dl = SETCCr 4, implicit killed $eflags
    //   RET64 killed $rax, killed $dl
    // 
    // # End machine code for function cmpxchg_u64_acquire_monotonic.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1, &param_2}, reg_backup_ax);


    // $rax = MOV64rr killed $rsi
    // aliasing ax to si
    // ax is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store acquire monotonic (s64) on %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond (cond0)
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, (*cond0), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument dx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 4, implicit killed $eflags
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETZ8r, scratch_dx.cur_reg);
    }
    }
    // result dx is marked as alive


    // RET64 killed $rax, killed $dl
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_acquire_acquire(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_acquire_acquire: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rsi
    //   LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store acquire acquire (s64) on %ir.0)
    //   renamable $dl = SETCCr 4, implicit killed $eflags
    //   RET64 killed $rax, killed $dl
    // 
    // # End machine code for function cmpxchg_u64_acquire_acquire.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1, &param_2}, reg_backup_ax);


    // $rax = MOV64rr killed $rsi
    // aliasing ax to si
    // ax is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store acquire acquire (s64) on %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond (cond0)
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, (*cond0), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument dx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 4, implicit killed $eflags
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETZ8r, scratch_dx.cur_reg);
    }
    }
    // result dx is marked as alive


    // RET64 killed $rax, killed $dl
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_release_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_release_monotonic: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rsi
    //   LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store release monotonic (s64) on %ir.0)
    //   renamable $dl = SETCCr 4, implicit killed $eflags
    //   RET64 killed $rax, killed $dl
    // 
    // # End machine code for function cmpxchg_u64_release_monotonic.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1, &param_2}, reg_backup_ax);


    // $rax = MOV64rr killed $rsi
    // aliasing ax to si
    // ax is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store release monotonic (s64) on %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond (cond0)
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, (*cond0), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument dx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 4, implicit killed $eflags
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETZ8r, scratch_dx.cur_reg);
    }
    }
    // result dx is marked as alive


    // RET64 killed $rax, killed $dl
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_release_acquire(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_release_acquire: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rsi
    //   LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store release acquire (s64) on %ir.0)
    //   renamable $dl = SETCCr 4, implicit killed $eflags
    //   RET64 killed $rax, killed $dl
    // 
    // # End machine code for function cmpxchg_u64_release_acquire.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1, &param_2}, reg_backup_ax);


    // $rax = MOV64rr killed $rsi
    // aliasing ax to si
    // ax is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store release acquire (s64) on %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond (cond0)
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, (*cond0), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument dx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 4, implicit killed $eflags
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETZ8r, scratch_dx.cur_reg);
    }
    }
    // result dx is marked as alive


    // RET64 killed $rax, killed $dl
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_acqrel_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_acqrel_monotonic: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rsi
    //   LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store acq_rel monotonic (s64) on %ir.0)
    //   renamable $dl = SETCCr 4, implicit killed $eflags
    //   RET64 killed $rax, killed $dl
    // 
    // # End machine code for function cmpxchg_u64_acqrel_monotonic.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1, &param_2}, reg_backup_ax);


    // $rax = MOV64rr killed $rsi
    // aliasing ax to si
    // ax is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store acq_rel monotonic (s64) on %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond (cond0)
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, (*cond0), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument dx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 4, implicit killed $eflags
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETZ8r, scratch_dx.cur_reg);
    }
    }
    // result dx is marked as alive


    // RET64 killed $rax, killed $dl
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_acqrel_acquire(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_acqrel_acquire: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rsi
    //   LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store acq_rel acquire (s64) on %ir.0)
    //   renamable $dl = SETCCr 4, implicit killed $eflags
    //   RET64 killed $rax, killed $dl
    // 
    // # End machine code for function cmpxchg_u64_acqrel_acquire.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1, &param_2}, reg_backup_ax);


    // $rax = MOV64rr killed $rsi
    // aliasing ax to si
    // ax is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store acq_rel acquire (s64) on %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond (cond0)
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, (*cond0), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument dx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 4, implicit killed $eflags
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETZ8r, scratch_dx.cur_reg);
    }
    }
    // result dx is marked as alive


    // RET64 killed $rax, killed $dl
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_seqcst_monotonic(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_seqcst_monotonic: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rsi
    //   LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store seq_cst monotonic (s64) on %ir.0)
    //   renamable $dl = SETCCr 4, implicit killed $eflags
    //   RET64 killed $rax, killed $dl
    // 
    // # End machine code for function cmpxchg_u64_seqcst_monotonic.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1, &param_2}, reg_backup_ax);


    // $rax = MOV64rr killed $rsi
    // aliasing ax to si
    // ax is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store seq_cst monotonic (s64) on %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond (cond0)
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, (*cond0), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument dx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 4, implicit killed $eflags
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETZ8r, scratch_dx.cur_reg);
    }
    }
    // result dx is marked as alive


    // RET64 killed $rax, killed $dl
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_seqcst_acquire(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_seqcst_acquire: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rsi
    //   LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store seq_cst acquire (s64) on %ir.0)
    //   renamable $dl = SETCCr 4, implicit killed $eflags
    //   RET64 killed $rax, killed $dl
    // 
    // # End machine code for function cmpxchg_u64_seqcst_acquire.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1, &param_2}, reg_backup_ax);


    // $rax = MOV64rr killed $rsi
    // aliasing ax to si
    // ax is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store seq_cst acquire (s64) on %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond (cond0)
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, (*cond0), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument dx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 4, implicit killed $eflags
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETZ8r, scratch_dx.cur_reg);
    }
    }
    // result dx is marked as alive


    // RET64 killed $rax, killed $dl
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_cmpxchg_u64_seqcst_seqcst(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function cmpxchg_u64_seqcst_seqcst: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rsi
    //   LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store seq_cst seq_cst (s64) on %ir.0)
    //   renamable $dl = SETCCr 4, implicit killed $eflags
    //   RET64 killed $rax, killed $dl
    // 
    // # End machine code for function cmpxchg_u64_seqcst_seqcst.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1, &param_2}, reg_backup_ax);


    // $rax = MOV64rr killed $rsi
    // aliasing ax to si
    // ax is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // LCMPXCHG64 killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rdx, implicit-def $rax, implicit-def $eflags, implicit killed $rax :: (load store seq_cst seq_cst (s64) on %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond (cond0)
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, (*cond0), op5);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op5 = param_2.as_reg(this);
        // fixing reg 0 for cond ()
        AsmReg op8_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, op8_tmp);
        ASMD(LOCK_CMPXCHG64mr, FE_MEM(op0, 0, FE_NOREG, 0), op5);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument dx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $dl = SETCCr 4, implicit killed $eflags
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETZ8r, scratch_dx.cur_reg);
    }
    }
    // result dx is marked as alive


    // RET64 killed $rax, killed $dl
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u8_mono(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u8_mono: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load monotonic (s8) from %ir.0)
    //   renamable $eax = MOVZX32rr8 killed renamable $al
    //   RET64 killed $eax
    // 
    // # End machine code for function atomic_load_u8_mono.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load monotonic (s8) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m8, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m8, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = MOVZX32rr8 killed renamable $al
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r8, scratch_ax.cur_reg, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u16_mono(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u16_mono: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   $eax = MOVZX32rm16 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load monotonic (s16) from %ir.0)
    //   renamable $eax = MOVZX32rr16 killed renamable $ax
    //   RET64 killed $eax
    // 
    // # End machine code for function atomic_load_u16_mono.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // $eax = MOVZX32rm16 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load monotonic (s16) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m16, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m16, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = MOVZX32rr16 killed renamable $ax
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r16, scratch_ax.cur_reg, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u32_mono(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u32_mono: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $eax = MOV32rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load monotonic (s32) from %ir.0)
    //   RET64 killed $eax
    // 
    // # End machine code for function atomic_load_u32_mono.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOV32rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load monotonic (s32) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u64_mono(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u64_mono: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $rax = MOV64rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load monotonic (s64) from %ir.0)
    //   RET64 killed $rax
    // 
    // # End machine code for function atomic_load_u64_mono.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $rax = MOV64rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load monotonic (s64) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV64rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV64rm, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u8_acq(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u8_acq: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load acquire (s8) from %ir.0)
    //   renamable $eax = MOVZX32rr8 killed renamable $al
    //   RET64 killed $eax
    // 
    // # End machine code for function atomic_load_u8_acq.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load acquire (s8) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m8, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m8, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = MOVZX32rr8 killed renamable $al
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r8, scratch_ax.cur_reg, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u16_acq(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u16_acq: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   $eax = MOVZX32rm16 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load acquire (s16) from %ir.0)
    //   renamable $eax = MOVZX32rr16 killed renamable $ax
    //   RET64 killed $eax
    // 
    // # End machine code for function atomic_load_u16_acq.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // $eax = MOVZX32rm16 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load acquire (s16) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m16, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m16, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = MOVZX32rr16 killed renamable $ax
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r16, scratch_ax.cur_reg, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u32_acq(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u32_acq: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $eax = MOV32rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load acquire (s32) from %ir.0)
    //   RET64 killed $eax
    // 
    // # End machine code for function atomic_load_u32_acq.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOV32rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load acquire (s32) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u64_acq(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u64_acq: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $rax = MOV64rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load acquire (s64) from %ir.0)
    //   RET64 killed $rax
    // 
    // # End machine code for function atomic_load_u64_acq.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $rax = MOV64rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load acquire (s64) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV64rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV64rm, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u8_seqcst(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u8_seqcst: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load seq_cst (s8) from %ir.0)
    //   renamable $eax = MOVZX32rr8 killed renamable $al
    //   RET64 killed $eax
    // 
    // # End machine code for function atomic_load_u8_seqcst.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load seq_cst (s8) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m8, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m8, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = MOVZX32rr8 killed renamable $al
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r8, scratch_ax.cur_reg, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u16_seqcst(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u16_seqcst: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   $eax = MOVZX32rm16 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load seq_cst (s16) from %ir.0)
    //   renamable $eax = MOVZX32rr16 killed renamable $ax
    //   RET64 killed $eax
    // 
    // # End machine code for function atomic_load_u16_seqcst.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // $eax = MOVZX32rm16 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load seq_cst (s16) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m16, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m16, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = MOVZX32rr16 killed renamable $ax
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r16, scratch_ax.cur_reg, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u32_seqcst(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u32_seqcst: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $eax = MOV32rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load seq_cst (s32) from %ir.0)
    //   RET64 killed $eax
    // 
    // # End machine code for function atomic_load_u32_seqcst.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOV32rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load seq_cst (s32) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV32rm, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_atomic_load_u64_seqcst(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function atomic_load_u64_seqcst: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $rax = MOV64rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load seq_cst (s64) from %ir.0)
    //   RET64 killed $rax
    // 
    // # End machine code for function atomic_load_u64_seqcst.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $rax = MOV64rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load seq_cst (s64) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV64rm, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            op1 = scratch_ax.cur_reg;
        } else {
            op1 = param_0.as_reg(this);
        }
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV64rm, scratch_ax.cur_reg, FE_MEM(op1, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_select_i32(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0) {
    // # Machine code for function select_i32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi, $edx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $edi, $edx, $esi
    //   $eax = MOV32rr killed $esi
    //   TEST8ri killed renamable $dil, 1, implicit-def $eflags, implicit killed $edi
    //   renamable $eax = CMOV32rr killed renamable $eax(tied-def 0), killed renamable $edx, 4, implicit killed $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function select_i32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};


    // $eax = MOV32rr killed $esi
    // aliasing ax to si
    // ax is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // TEST8ri killed renamable $dil, 1, implicit-def $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8mi, (*cond0), 0x1);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8ri, op0, 0x1);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead


    // renamable $eax = CMOV32rr killed renamable $eax(tied-def 0), killed renamable $edx, 4, implicit killed $eflags
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        AsmReg op2 = param_2.as_reg(this);
        ASMD(CMOVZ32rr, scratch_ax.cur_reg, op2);
    }
    }
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_select_i64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0) {
    // # Machine code for function select_i64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $edi, $rdx, $rsi
    //   $rax = MOV64rr killed $rsi
    //   TEST8ri killed renamable $dil, 1, implicit-def $eflags, implicit killed $edi
    //   renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), killed renamable $rdx, 4, implicit killed $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function select_i64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};


    // $rax = MOV64rr killed $rsi
    // aliasing ax to si
    // ax is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // TEST8ri killed renamable $dil, 1, implicit-def $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8mi, (*cond0), 0x1);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8ri, op0, 0x1);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead


    // renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), killed renamable $rdx, 4, implicit killed $eflags
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_2.as_reg(this);
        ASMD(CMOVZ64rr, scratch_ax.cur_reg, op2);
    }
    }
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_select_i128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, AsmOperand param_4, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function select_i128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $rsi, $rdx, $rcx, $r8
    // 
    // bb.0 (%ir-block.5):
    //   liveins: $edi, $rcx, $rdx, $rsi, $r8
    //   $rax = MOV64rr killed $rsi
    //   TEST8ri killed renamable $dil, 1, implicit-def $eflags, implicit killed $edi
    //   renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), killed renamable $rcx, 4, implicit $eflags
    //   renamable $rdx = CMOV64rr killed renamable $rdx(tied-def 0), killed renamable $r8, 4, implicit killed $eflags
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function select_i128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    // Mapping cx to param_3
    // Mapping r8 to param_4
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    ScratchReg scratch_r8{derived()};


    // $rax = MOV64rr killed $rsi
    // aliasing ax to si
    // ax is an alias for operand param_1
    // source si is killed, all aliases redirected and marked as dead


    // TEST8ri killed renamable $dil, 1, implicit-def $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8mi, (*cond0), 0x1);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8ri, op0, 0x1);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead


    // renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), killed renamable $rcx, 4, implicit $eflags
    {
    if (1) {
        // operand 1(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        AsmReg op2 = param_3.as_reg(this);
        ASMD(CMOVZ64rr, scratch_ax.cur_reg, op2);
    }
    }
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rdx = CMOV64rr killed renamable $rdx(tied-def 0), killed renamable $r8, 4, implicit killed $eflags
    {
    if (1) {
        // operand 1(param_2) is tied so try to salvage or materialize
        param_2.try_salvage_or_materialize(this, scratch_dx, 0, 8);
        AsmReg op2 = param_4.as_reg(this);
        ASMD(CMOVZ64rr, scratch_dx.cur_reg, op2);
    }
    }
    // argument dx is killed and marked as dead
    // argument r8 is killed and marked as dead
    // result dx is marked as alive


    // RET64 killed $rax, killed $rdx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_select_f32(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0) {
    // # Machine code for function select_f32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.3):
    //   successors: %bb.1(0x40000000), %bb.2(0x40000000); %bb.1(50.00%), %bb.2(50.00%)
    //   liveins: $edi, $xmm0, $xmm1
    //   TEST8ri killed renamable $dil, 1, implicit-def $eflags, implicit killed $edi
    //   JCC_1 %bb.2, 4, implicit killed $eflags
    // 
    // bb.1 (%ir-block.3):
    // ; predecessors: %bb.0
    //   successors: %bb.2(0x80000000); %bb.2(100.00%)
    //   liveins: $xmm0
    //   $xmm1 = MOVAPSrr killed $xmm0
    // 
    // bb.2 (%ir-block.3):
    // ; predecessors: %bb.0, %bb.1
    //   liveins: $xmm1
    //   $xmm0 = MOVAPSrr killed $xmm1
    //   RET64 killed $xmm0
    // 
    // # End machine code for function select_f32.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    // Mapping xmm1 to param_2

    // Creating label for convergence point at the end of the function
    Label ret_converge_label = derived()->assembler.label_create();
    // Creating labels for blocks that are jump targets
    Label block1_label = derived()->assembler.label_create();
    Label block2_label = derived()->assembler.label_create();

    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // TEST8ri killed renamable $dil, 1, implicit-def $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8mi, (*cond0), 0x1);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8ri, op0, 0x1);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead


    // JCC_1 %bb.2, 4, implicit killed $eflags
    // Preparing jump to other block
    // xmm0 is live-out
    // xmm1 is live-out
    // Handling register xmm1
    // xmm1 is mapped to operand param_2, materializing it
    param_2.try_salvage_or_materialize(this, scratch_xmm1, 1, 16);
    // Handling register xmm0
    // xmm0 is mapped to operand param_1, materializing it
    param_1.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
    // Resetting the state of di as it is unused for the rest of the function
    derived()->generate_raw_jump(CompilerX64::Jump::je, block2_label);


    // Starting encoding of block 1
    derived()->assembler.label_place(block1_label);
    // Marking xmm0 as live


    // $xmm1 = MOVAPSrr killed $xmm0
    // aliasing xmm1 to xmm0
    // source xmm0 is killed, all aliases redirected and marked as dead
    // xmm1 is live-out
    // xmm1 is live-out and an alias, need to resolve
    // xmm1 is an alias for xmm0
    // removing alias from xmm1 to xmm0
    if (has_avx()) {
        ASMD(VMOVUPD128rr, scratch_xmm1.cur_reg, scratch_xmm0.cur_reg);
    } else {
        ASMD(SSE_MOVUPDrr, scratch_xmm1.cur_reg, scratch_xmm0.cur_reg);
    }
    // Starting encoding of block 2
    derived()->assembler.label_place(block2_label);
    // Marking xmm1 as live


    // $xmm0 = MOVAPSrr killed $xmm1
    // aliasing xmm0 to xmm1
    // source xmm1 is killed, all aliases redirected and marked as dead


    // RET64 killed $xmm0
    // handling return for xmm0
    // xmm0 is an alias for xmm1
    if (has_avx()) {
        ASMD(VMOVUPD128rr, scratch_xmm0.cur_reg, scratch_xmm1.cur_reg);
    } else {
        ASMD(SSE_MOVUPDrr, scratch_xmm0.cur_reg, scratch_xmm1.cur_reg);
    }
    // Omitting jump to convergence as this is the last block
    // Resetting alias status for xmm0

    // Placing the convergence point for registers here
    derived()->assembler.label_place(ret_converge_label);
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_select_f64(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0) {
    // # Machine code for function select_f64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.3):
    //   successors: %bb.1(0x40000000), %bb.2(0x40000000); %bb.1(50.00%), %bb.2(50.00%)
    //   liveins: $edi, $xmm0, $xmm1
    //   TEST8ri killed renamable $dil, 1, implicit-def $eflags, implicit killed $edi
    //   JCC_1 %bb.2, 4, implicit killed $eflags
    // 
    // bb.1 (%ir-block.3):
    // ; predecessors: %bb.0
    //   successors: %bb.2(0x80000000); %bb.2(100.00%)
    //   liveins: $xmm0
    //   $xmm1 = MOVAPSrr killed $xmm0
    // 
    // bb.2 (%ir-block.3):
    // ; predecessors: %bb.0, %bb.1
    //   liveins: $xmm1
    //   $xmm0 = MOVAPSrr killed $xmm1
    //   RET64 killed $xmm0
    // 
    // # End machine code for function select_f64.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    // Mapping xmm1 to param_2

    // Creating label for convergence point at the end of the function
    Label ret_converge_label = derived()->assembler.label_create();
    // Creating labels for blocks that are jump targets
    Label block1_label = derived()->assembler.label_create();
    Label block2_label = derived()->assembler.label_create();

    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // TEST8ri killed renamable $dil, 1, implicit-def $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8mi, (*cond0), 0x1);
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(TEST8ri, op0, 0x1);
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead


    // JCC_1 %bb.2, 4, implicit killed $eflags
    // Preparing jump to other block
    // xmm0 is live-out
    // xmm1 is live-out
    // Handling register xmm1
    // xmm1 is mapped to operand param_2, materializing it
    param_2.try_salvage_or_materialize(this, scratch_xmm1, 1, 16);
    // Handling register xmm0
    // xmm0 is mapped to operand param_1, materializing it
    param_1.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
    // Resetting the state of di as it is unused for the rest of the function
    derived()->generate_raw_jump(CompilerX64::Jump::je, block2_label);


    // Starting encoding of block 1
    derived()->assembler.label_place(block1_label);
    // Marking xmm0 as live


    // $xmm1 = MOVAPSrr killed $xmm0
    // aliasing xmm1 to xmm0
    // source xmm0 is killed, all aliases redirected and marked as dead
    // xmm1 is live-out
    // xmm1 is live-out and an alias, need to resolve
    // xmm1 is an alias for xmm0
    // removing alias from xmm1 to xmm0
    if (has_avx()) {
        ASMD(VMOVUPD128rr, scratch_xmm1.cur_reg, scratch_xmm0.cur_reg);
    } else {
        ASMD(SSE_MOVUPDrr, scratch_xmm1.cur_reg, scratch_xmm0.cur_reg);
    }
    // Starting encoding of block 2
    derived()->assembler.label_place(block2_label);
    // Marking xmm1 as live


    // $xmm0 = MOVAPSrr killed $xmm1
    // aliasing xmm0 to xmm1
    // source xmm1 is killed, all aliases redirected and marked as dead


    // RET64 killed $xmm0
    // handling return for xmm0
    // xmm0 is an alias for xmm1
    if (has_avx()) {
        ASMD(VMOVUPD128rr, scratch_xmm0.cur_reg, scratch_xmm1.cur_reg);
    } else {
        ASMD(SSE_MOVUPDrr, scratch_xmm0.cur_reg, scratch_xmm1.cur_reg);
    }
    // Omitting jump to convergence as this is the last block
    // Resetting alias status for xmm0

    // Placing the convergence point for registers here
    derived()->assembler.label_place(ret_converge_label);
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_oeq_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_oeq_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $xmm0 = nofpexcept CMPSSrri killed renamable $xmm0(tied-def 0), killed renamable $xmm1, 0, implicit $mxcsr
    //   renamable $eax = MOVSS2DIrr killed renamable $xmm0
    //   renamable $eax = AND32ri killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_oeq_float.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept CMPSSrri killed renamable $xmm0(tied-def 0), killed renamable $xmm1, 0, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        ASMD(SSE_CMPSSrmi, scratch_xmm0.cur_reg, (*cond0), 0x0);
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SSE_CMPSSrri, scratch_xmm0.cur_reg, op2, 0x0);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead
    // result xmm0 is marked as alive


    // renamable $eax = MOVSS2DIrr killed renamable $xmm0
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVD_X2Grr, scratch_ax.cur_reg, scratch_xmm0.cur_reg);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = AND32ri killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND32ri, scratch_ax.cur_reg, 0x1);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ogt_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ogt_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 7, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_ogt_float.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(SSE_UCOMISSrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISSrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead


    // renamable $al = SETCCr 7, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETA8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_oge_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_oge_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 3, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_oge_float.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(SSE_UCOMISSrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISSrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead


    // renamable $al = SETCCr 3, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETNC8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_olt_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_olt_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISSrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 7, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_olt_float.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISSrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(SSE_UCOMISSrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(SSE_UCOMISSrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm1 is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // renamable $al = SETCCr 7, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETA8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ole_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ole_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISSrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 3, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_ole_float.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISSrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(SSE_UCOMISSrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(SSE_UCOMISSrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm1 is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // renamable $al = SETCCr 3, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETNC8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_one_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_one_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 5, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_one_float.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(SSE_UCOMISSrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISSrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead


    // renamable $al = SETCCr 5, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETNZ8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ord_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ord_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 11, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_ord_float.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(SSE_UCOMISSrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISSrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead


    // renamable $al = SETCCr 11, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETNP8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ueq_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ueq_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 4, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_ueq_float.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(SSE_UCOMISSrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISSrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead


    // renamable $al = SETCCr 4, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETZ8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ugt_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ugt_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISSrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 2, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_ugt_float.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISSrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(SSE_UCOMISSrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(SSE_UCOMISSrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm1 is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // renamable $al = SETCCr 2, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETC8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_uge_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_uge_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISSrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 6, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_uge_float.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISSrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(SSE_UCOMISSrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(SSE_UCOMISSrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm1 is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // renamable $al = SETCCr 6, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETBE8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ult_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ult_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 2, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_ult_float.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(SSE_UCOMISSrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISSrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead


    // renamable $al = SETCCr 2, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETC8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ule_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ule_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 6, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_ule_float.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(SSE_UCOMISSrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISSrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead


    // renamable $al = SETCCr 6, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETBE8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_une_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_une_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $xmm0 = nofpexcept CMPSSrri killed renamable $xmm0(tied-def 0), killed renamable $xmm1, 4, implicit $mxcsr
    //   renamable $eax = MOVSS2DIrr killed renamable $xmm0
    //   renamable $eax = AND32ri killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_une_float.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept CMPSSrri killed renamable $xmm0(tied-def 0), killed renamable $xmm1, 4, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        ASMD(SSE_CMPSSrmi, scratch_xmm0.cur_reg, (*cond0), 0x4);
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SSE_CMPSSrri, scratch_xmm0.cur_reg, op2, 0x4);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead
    // result xmm0 is marked as alive


    // renamable $eax = MOVSS2DIrr killed renamable $xmm0
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVD_X2Grr, scratch_ax.cur_reg, scratch_xmm0.cur_reg);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = AND32ri killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND32ri, scratch_ax.cur_reg, 0x1);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_uno_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_uno_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 10, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_uno_float.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(SSE_UCOMISSrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISSrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead


    // renamable $al = SETCCr 10, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETP8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_oeq_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_oeq_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $xmm0 = nofpexcept CMPSDrri killed renamable $xmm0(tied-def 0), killed renamable $xmm1, 0, implicit $mxcsr
    //   renamable $rax = MOVSDto64rr killed renamable $xmm0
    //   renamable $eax = AND32ri killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
    //   $eax = KILL killed renamable $eax, implicit killed $rax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_oeq_double.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept CMPSDrri killed renamable $xmm0(tied-def 0), killed renamable $xmm1, 0, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        ASMD(SSE_CMPSDrmi, scratch_xmm0.cur_reg, (*cond0), 0x0);
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SSE_CMPSDrri, scratch_xmm0.cur_reg, op2, 0x0);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead
    // result xmm0 is marked as alive


    // renamable $rax = MOVSDto64rr killed renamable $xmm0
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVQ_X2Grr, scratch_ax.cur_reg, scratch_xmm0.cur_reg);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = AND32ri killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(AND32ri, scratch_ax.cur_reg, 0x1);
    }
    }
    // argument ax is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // $eax = KILL killed renamable $eax, implicit killed $rax
    // KILL is a no-op


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ogt_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ogt_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 7, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_ogt_double.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(SSE_UCOMISDrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISDrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead


    // renamable $al = SETCCr 7, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETA8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_oge_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_oge_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 3, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_oge_double.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(SSE_UCOMISDrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISDrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead


    // renamable $al = SETCCr 3, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETNC8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_olt_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_olt_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISDrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 7, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_olt_double.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISDrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(SSE_UCOMISDrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(SSE_UCOMISDrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm1 is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // renamable $al = SETCCr 7, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETA8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ole_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ole_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISDrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 3, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_ole_double.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISDrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(SSE_UCOMISDrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(SSE_UCOMISDrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm1 is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // renamable $al = SETCCr 3, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETNC8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_one_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_one_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 5, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_one_double.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(SSE_UCOMISDrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISDrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead


    // renamable $al = SETCCr 5, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETNZ8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ord_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ord_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 11, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_ord_double.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(SSE_UCOMISDrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISDrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead


    // renamable $al = SETCCr 11, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETNP8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ueq_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ueq_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 4, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_ueq_double.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(SSE_UCOMISDrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISDrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead


    // renamable $al = SETCCr 4, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETZ8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ugt_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ugt_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISDrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 2, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_ugt_double.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISDrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(SSE_UCOMISDrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(SSE_UCOMISDrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm1 is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // renamable $al = SETCCr 2, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETC8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_uge_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_uge_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISDrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 6, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_uge_double.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISDrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_0.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(SSE_UCOMISDrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_0.as_reg(this);
        ASMD(SSE_UCOMISDrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm1 is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // renamable $al = SETCCr 6, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETBE8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ult_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ult_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 2, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_ult_double.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(SSE_UCOMISDrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISDrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead


    // renamable $al = SETCCr 2, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETC8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_ule_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_ule_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 6, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_ule_double.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(SSE_UCOMISDrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISDrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead


    // renamable $al = SETCCr 6, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETBE8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_une_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_une_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $xmm0 = nofpexcept CMPSDrri killed renamable $xmm0(tied-def 0), killed renamable $xmm1, 4, implicit $mxcsr
    //   renamable $rax = MOVSDto64rr killed renamable $xmm0
    //   renamable $eax = AND32ri killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
    //   $eax = KILL killed renamable $eax, implicit killed $rax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_une_double.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = nofpexcept CMPSDrri killed renamable $xmm0(tied-def 0), killed renamable $xmm1, 4, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        ASMD(SSE_CMPSDrmi, scratch_xmm0.cur_reg, (*cond0), 0x4);
        break;
    }
    }
    {
    if (1) {
        // operand 1(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_xmm0, 1, 16);
        AsmReg op2 = param_1.as_reg(this);
        ASMD(SSE_CMPSDrri, scratch_xmm0.cur_reg, op2, 0x4);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead
    // result xmm0 is marked as alive


    // renamable $rax = MOVSDto64rr killed renamable $xmm0
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVQ_X2Grr, scratch_ax.cur_reg, scratch_xmm0.cur_reg);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = AND32ri killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags, implicit killed $rax, implicit-def $rax
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(AND32ri, scratch_ax.cur_reg, 0x1);
    }
    }
    // argument ax is killed and marked as dead
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // $eax = KILL killed renamable $eax, implicit killed $rax
    // KILL is a no-op


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_fcmp_uno_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function fcmp_uno_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $xmm0, $xmm1
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $xmm0, $xmm1
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    //   nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 10, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    //   RET64 killed $eax
    // 
    // # End machine code for function fcmp_uno_double.
    // 

    // Mapping xmm0 to param_0
    // Mapping xmm1 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // undef tied
        // undef allocate scratch
        AsmReg inst0_op2 = scratch_ax.alloc_from_bank(0);

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(XOR32rr, scratch_ax.cur_reg, inst0_op2);
        break;
    }
    }
    } while (false);
    // result ax is marked as alive


    // nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm1, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(SSE_UCOMISDrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISDrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm1 is killed and marked as dead


    // renamable $al = SETCCr 10, implicit killed $eflags, implicit killed $eax, implicit-def $eax
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETP8r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_snan_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_snan_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $eax = MOVSS2DIrr killed renamable $xmm0
    //   renamable $eax = AND32ri killed renamable $eax(tied-def 0), 2147483647, implicit-def dead $eflags
    //   CMP32ri renamable $eax, 2143289344, implicit-def $eflags
    //   renamable $cl = SETCCr 12, implicit killed $eflags
    //   CMP32ri killed renamable $eax, 2139095041, implicit-def $eflags
    //   renamable $al = SETCCr 13, implicit killed $eflags
    //   renamable $al = AND8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def dead $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_snan_float.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $eax = MOVSS2DIrr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVD_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = AND32ri killed renamable $eax(tied-def 0), 2147483647, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND32ri, scratch_ax.cur_reg, 0x7fffffff);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // CMP32ri renamable $eax, 2143289344, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP32ri, scratch_ax.cur_reg, 0x7fc00000);
        break;
    }
    }
    } while (false);


    // renamable $cl = SETCCr 12, implicit killed $eflags
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(SETL8r, scratch_cx.cur_reg);
    }
    }
    // result cx is marked as alive


    // CMP32ri killed renamable $eax, 2139095041, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP32ri, scratch_ax.cur_reg, 0x7f800001);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 13, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETGE8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = AND8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND8rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_qnan_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_qnan_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $eax = MOVSS2DIrr killed renamable $xmm0
    //   renamable $eax = AND32ri killed renamable $eax(tied-def 0), 2147483647, implicit-def dead $eflags
    //   CMP32ri killed renamable $eax, 2143289344, implicit-def $eflags
    //   renamable $al = SETCCr 13, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_qnan_float.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOVSS2DIrr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVD_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = AND32ri killed renamable $eax(tied-def 0), 2147483647, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND32ri, scratch_ax.cur_reg, 0x7fffffff);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // CMP32ri killed renamable $eax, 2143289344, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP32ri, scratch_ax.cur_reg, 0x7fc00000);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 13, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETGE8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_ninf_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_ninf_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Constant Pool:
    //   cp#0: 0xFFF0000000000000, align=4
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $xmm1 = MOVSSrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load (s32) from constant-pool)
    //   nofpexcept UCOMISSrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 3, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_ninf_float.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm1 = MOVSSrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load (s32) from constant-pool)
    {
    if (1) {
        SymRef &op4_sym = this->sym_is_fpclass_ninf_float_cp0;
        if (op4_sym == Assembler::INVALID_SYM_REF) [[unlikely]] {
            const std::array<u8, 4> data = {0x0, 0x0, 0x80, 0xFF};
            op4_sym = derived()->assembler.sym_def_data("", data, 4, true, false, true, false);
        }
        // def xmm1 has not been allocated yet
        scratch_xmm1.alloc_from_bank(1);
        ASMD(SSE_MOVSSrm, scratch_xmm1.cur_reg, FE_MEM(FE_IP, 0, FE_NOREG, 0));
        derived()->assembler.reloc_text_pc32(op4_sym, derived()->assembler.text_cur_off() - 4, -4);
    }
    }
    // result xmm1 is marked as alive


    // nofpexcept UCOMISSrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        ASMD(SSE_UCOMISSrm, scratch_xmm1.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISSrr, scratch_xmm1.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument xmm1 is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // renamable $al = SETCCr 3, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETNC8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond1 = param_0.encodeable_as_imm32_sext();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    auto cond2 = param_0.encodeable_as_mem();
    if (cond2) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond2));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_nnorm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_nnorm_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $eax = MOVSS2DIrr killed renamable $xmm0
    //   TEST32rr renamable $eax, renamable $eax, implicit-def $eflags
    //   renamable $cl = SETCCr 8, implicit killed $eflags
    //   renamable $eax = AND32ri killed renamable $eax(tied-def 0), 2147483647, implicit-def dead $eflags
    //   renamable $eax = ADD32ri killed renamable $eax(tied-def 0), -8388608, implicit-def dead $eflags
    //   CMP32ri killed renamable $eax, 2130706432, implicit-def $eflags
    //   renamable $al = SETCCr 2, implicit killed $eflags
    //   renamable $al = AND8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def dead $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_nnorm_float.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $eax = MOVSS2DIrr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVD_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // TEST32rr renamable $eax, renamable $eax, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(TEST32rr, scratch_ax.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);


    // renamable $cl = SETCCr 8, implicit killed $eflags
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(SETS8r, scratch_cx.cur_reg);
    }
    }
    // result cx is marked as alive


    // renamable $eax = AND32ri killed renamable $eax(tied-def 0), 2147483647, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND32ri, scratch_ax.cur_reg, 0x7fffffff);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = ADD32ri killed renamable $eax(tied-def 0), -8388608, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(ADD32ri, scratch_ax.cur_reg, -0x800000);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // CMP32ri killed renamable $eax, 2130706432, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP32ri, scratch_ax.cur_reg, 0x7f000000);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 2, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETC8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = AND8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND8rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_nsnorm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_nsnorm_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $eax = MOVSS2DIrr killed renamable $xmm0
    //   TEST32rr renamable $eax, renamable $eax, implicit-def $eflags
    //   renamable $cl = SETCCr 8, implicit killed $eflags
    //   renamable $eax = AND32ri killed renamable $eax(tied-def 0), 2147483647, implicit-def dead $eflags
    //   renamable $eax = DEC32r killed renamable $eax(tied-def 0), implicit-def dead $eflags
    //   CMP32ri killed renamable $eax, 8388607, implicit-def $eflags
    //   renamable $al = SETCCr 2, implicit killed $eflags
    //   renamable $al = AND8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def dead $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_nsnorm_float.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $eax = MOVSS2DIrr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVD_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // TEST32rr renamable $eax, renamable $eax, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(TEST32rr, scratch_ax.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);


    // renamable $cl = SETCCr 8, implicit killed $eflags
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(SETS8r, scratch_cx.cur_reg);
    }
    }
    // result cx is marked as alive


    // renamable $eax = AND32ri killed renamable $eax(tied-def 0), 2147483647, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND32ri, scratch_ax.cur_reg, 0x7fffffff);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = DEC32r killed renamable $eax(tied-def 0), implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(DEC32r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // CMP32ri killed renamable $eax, 8388607, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP32ri, scratch_ax.cur_reg, 0x7fffff);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 2, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETC8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = AND8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND8rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_nzero_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_nzero_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $eax = MOVSS2DIrr killed renamable $xmm0
    //   dead renamable $eax = NEG32r killed renamable $eax(tied-def 0), implicit-def $eflags
    //   renamable $al = SETCCr 0, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_nzero_float.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOVSS2DIrr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVD_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // dead renamable $eax = NEG32r killed renamable $eax(tied-def 0), implicit-def $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(NEG32r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as dead


    // renamable $al = SETCCr 0, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETO8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_pzero_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_pzero_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $eax = MOVSS2DIrr killed renamable $xmm0
    //   TEST32rr killed renamable $eax, killed renamable $eax, implicit-def $eflags
    //   renamable $al = SETCCr 4, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_pzero_float.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOVSS2DIrr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVD_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // TEST32rr killed renamable $eax, killed renamable $eax, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(TEST32rr, scratch_ax.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 4, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETZ8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_psnorm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_psnorm_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $eax = MOVSS2DIrr killed renamable $xmm0
    //   renamable $eax = DEC32r killed renamable $eax(tied-def 0), implicit-def dead $eflags
    //   CMP32ri killed renamable $eax, 8388607, implicit-def $eflags
    //   renamable $al = SETCCr 2, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_psnorm_float.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOVSS2DIrr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVD_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = DEC32r killed renamable $eax(tied-def 0), implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(DEC32r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // CMP32ri killed renamable $eax, 8388607, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP32ri, scratch_ax.cur_reg, 0x7fffff);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 2, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETC8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_pnorm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_pnorm_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $eax = MOVSS2DIrr killed renamable $xmm0
    //   TEST32rr renamable $eax, renamable $eax, implicit-def $eflags
    //   renamable $cl = SETCCr 9, implicit killed $eflags
    //   renamable $eax = AND32ri killed renamable $eax(tied-def 0), 2147483647, implicit-def dead $eflags
    //   renamable $eax = ADD32ri killed renamable $eax(tied-def 0), -8388608, implicit-def dead $eflags
    //   CMP32ri killed renamable $eax, 2130706432, implicit-def $eflags
    //   renamable $al = SETCCr 2, implicit killed $eflags
    //   renamable $al = AND8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def dead $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_pnorm_float.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $eax = MOVSS2DIrr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVD_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // TEST32rr renamable $eax, renamable $eax, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(TEST32rr, scratch_ax.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);


    // renamable $cl = SETCCr 9, implicit killed $eflags
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(SETNS8r, scratch_cx.cur_reg);
    }
    }
    // result cx is marked as alive


    // renamable $eax = AND32ri killed renamable $eax(tied-def 0), 2147483647, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND32ri, scratch_ax.cur_reg, 0x7fffffff);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = ADD32ri killed renamable $eax(tied-def 0), -8388608, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(ADD32ri, scratch_ax.cur_reg, -0x800000);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // CMP32ri killed renamable $eax, 2130706432, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP32ri, scratch_ax.cur_reg, 0x7f000000);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 2, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETC8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = AND8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND8rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_pinf_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_pinf_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Constant Pool:
    //   cp#0: 0x7FF0000000000000, align=4
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   nofpexcept UCOMISSrm killed renamable $xmm0, $rip, 1, $noreg, %const.0, $noreg, implicit-def $eflags, implicit $mxcsr :: (load (s32) from constant-pool)
    //   renamable $al = SETCCr 3, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_pinf_float.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // nofpexcept UCOMISSrm killed renamable $xmm0, $rip, 1, $noreg, %const.0, $noreg, implicit-def $eflags, implicit $mxcsr :: (load (s32) from constant-pool)
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        SymRef &op4_sym = this->sym_is_fpclass_pinf_float_cp0;
        if (op4_sym == Assembler::INVALID_SYM_REF) [[unlikely]] {
            const std::array<u8, 4> data = {0x0, 0x0, 0x80, 0x7F};
            op4_sym = derived()->assembler.sym_def_data("", data, 4, true, false, true, false);
        }
        ASMD(SSE_UCOMISSrm, op0, FE_MEM(FE_IP, 0, FE_NOREG, 0));
        derived()->assembler.reloc_text_pc32(op4_sym, derived()->assembler.text_cur_off() - 4, -4);
    }
    }
    // argument xmm0 is killed and marked as dead


    // renamable $al = SETCCr 3, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETNC8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_nan_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_nan_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 10, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_nan_float.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // nofpexcept UCOMISSrr killed renamable $xmm0, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(SSE_UCOMISSrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISSrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // renamable $al = SETCCr 10, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETP8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond1 = param_0.encodeable_as_imm32_sext();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    auto cond2 = param_0.encodeable_as_mem();
    if (cond2) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond2));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_inf_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_inf_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $eax = MOVSS2DIrr killed renamable $xmm0
    //   renamable $eax = AND32ri killed renamable $eax(tied-def 0), 2147483647, implicit-def dead $eflags
    //   CMP32ri killed renamable $eax, 2139095040, implicit-def $eflags
    //   renamable $al = SETCCr 4, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_inf_float.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOVSS2DIrr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVD_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = AND32ri killed renamable $eax(tied-def 0), 2147483647, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND32ri, scratch_ax.cur_reg, 0x7fffffff);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // CMP32ri killed renamable $eax, 2139095040, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP32ri, scratch_ax.cur_reg, 0x7f800000);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 4, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETZ8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_norm_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_norm_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $eax = MOVSS2DIrr killed renamable $xmm0
    //   renamable $eax = AND32ri killed renamable $eax(tied-def 0), 2147483647, implicit-def dead $eflags
    //   renamable $eax = ADD32ri killed renamable $eax(tied-def 0), -8388608, implicit-def dead $eflags
    //   CMP32ri killed renamable $eax, 2130706432, implicit-def $eflags
    //   renamable $al = SETCCr 2, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_norm_float.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOVSS2DIrr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVD_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = AND32ri killed renamable $eax(tied-def 0), 2147483647, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND32ri, scratch_ax.cur_reg, 0x7fffffff);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = ADD32ri killed renamable $eax(tied-def 0), -8388608, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(ADD32ri, scratch_ax.cur_reg, -0x800000);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // CMP32ri killed renamable $eax, 2130706432, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP32ri, scratch_ax.cur_reg, 0x7f000000);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 2, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETC8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_finite_float(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_finite_float: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $eax = MOVSS2DIrr killed renamable $xmm0
    //   renamable $eax = AND32ri killed renamable $eax(tied-def 0), 2147483647, implicit-def dead $eflags
    //   CMP32ri killed renamable $eax, 2139095040, implicit-def $eflags
    //   renamable $al = SETCCr 12, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_finite_float.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $eax = MOVSS2DIrr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVD_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = AND32ri killed renamable $eax(tied-def 0), 2147483647, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND32ri, scratch_ax.cur_reg, 0x7fffffff);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // CMP32ri killed renamable $eax, 2139095040, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP32ri, scratch_ax.cur_reg, 0x7f800000);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 12, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETL8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_snan_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_snan_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $rax = MOVSDto64rr killed renamable $xmm0
    //   renamable $rcx = MOV64ri 9223372036854775807
    //   renamable $rcx = AND64rr killed renamable $rcx(tied-def 0), killed renamable $rax, implicit-def dead $eflags
    //   renamable $rax = MOV64ri 9221120237041090560
    //   CMP64rr renamable $rcx, killed renamable $rax, implicit-def $eflags
    //   renamable $dl = SETCCr 12, implicit killed $eflags
    //   renamable $rax = MOV64ri 9218868437227405312
    //   CMP64rr killed renamable $rcx, killed renamable $rax, implicit-def $eflags
    //   renamable $al = SETCCr 15, implicit killed $eflags
    //   renamable $al = AND8rr killed renamable $al(tied-def 0), killed renamable $dl, implicit-def dead $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_snan_double.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $rax = MOVSDto64rr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVQ_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $rcx = MOV64ri 9223372036854775807
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_cx.cur_reg, 0x7fffffffffffffff);
    }
    }
    // result cx is marked as alive


    // renamable $rcx = AND64rr killed renamable $rcx(tied-def 0), killed renamable $rax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(AND64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result cx is marked as alive


    // renamable $rax = MOV64ri 9221120237041090560
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_ax.cur_reg, 0x7ff8000000000000);
    }
    }
    // result ax is marked as alive


    // CMP64rr renamable $rcx, killed renamable $rax, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead


    // renamable $dl = SETCCr 12, implicit killed $eflags
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(SETL8r, scratch_dx.cur_reg);
    }
    }
    // result dx is marked as alive


    // renamable $rax = MOV64ri 9218868437227405312
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_ax.cur_reg, 0x7ff0000000000000);
    }
    }
    // result ax is marked as alive


    // CMP64rr killed renamable $rcx, killed renamable $rax, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 15, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETG8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = AND8rr killed renamable $al(tied-def 0), killed renamable $dl, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND8rr, scratch_ax.cur_reg, scratch_dx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_qnan_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_qnan_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $rax = MOVSDto64rr killed renamable $xmm0
    //   renamable $rcx = MOV64ri 9223372036854775807
    //   renamable $rcx = AND64rr killed renamable $rcx(tied-def 0), killed renamable $rax, implicit-def dead $eflags
    //   renamable $rax = MOV64ri 9221120237041090559
    //   CMP64rr killed renamable $rcx, killed renamable $rax, implicit-def $eflags
    //   renamable $al = SETCCr 15, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_qnan_double.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $rax = MOVSDto64rr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVQ_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $rcx = MOV64ri 9223372036854775807
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_cx.cur_reg, 0x7fffffffffffffff);
    }
    }
    // result cx is marked as alive


    // renamable $rcx = AND64rr killed renamable $rcx(tied-def 0), killed renamable $rax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(AND64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result cx is marked as alive


    // renamable $rax = MOV64ri 9221120237041090559
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_ax.cur_reg, 0x7ff7ffffffffffff);
    }
    }
    // result ax is marked as alive


    // CMP64rr killed renamable $rcx, killed renamable $rax, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 15, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETG8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_ninf_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_ninf_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Constant Pool:
    //   cp#0: 0xFFF0000000000000, align=8
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load (s64) from constant-pool)
    //   nofpexcept UCOMISDrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 3, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_ninf_double.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm1{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm1 = MOVSDrm_alt $rip, 1, $noreg, %const.0, $noreg :: (load (s64) from constant-pool)
    {
    if (1) {
        SymRef &op4_sym = this->sym_is_fpclass_ninf_double_cp0;
        if (op4_sym == Assembler::INVALID_SYM_REF) [[unlikely]] {
            const std::array<u8, 8> data = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xF0, 0xFF};
            op4_sym = derived()->assembler.sym_def_data("", data, 8, true, false, true, false);
        }
        // def xmm1 has not been allocated yet
        scratch_xmm1.alloc_from_bank(1);
        ASMD(SSE_MOVSDrm, scratch_xmm1.cur_reg, FE_MEM(FE_IP, 0, FE_NOREG, 0));
        derived()->assembler.reloc_text_pc32(op4_sym, derived()->assembler.text_cur_off() - 4, -4);
    }
    }
    // result xmm1 is marked as alive


    // nofpexcept UCOMISDrr killed renamable $xmm1, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        ASMD(SSE_UCOMISDrm, scratch_xmm1.cur_reg, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISDrr, scratch_xmm1.cur_reg, op1);
        break;
    }
    }
    } while (false);
    // argument xmm1 is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // renamable $al = SETCCr 3, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETNC8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond1 = param_0.encodeable_as_imm32_sext();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    auto cond2 = param_0.encodeable_as_mem();
    if (cond2) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond2));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_nnorm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_nnorm_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $rax = MOVSDto64rr killed renamable $xmm0
    //   renamable $rcx = MOV64ri 9223372036854775807
    //   renamable $rcx = AND64rr killed renamable $rcx(tied-def 0), renamable $rax, implicit-def dead $eflags
    //   renamable $rdx = MOV64ri -4503599627370496
    //   renamable $rdx = ADD64rr killed renamable $rdx(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   renamable $rdx = SHR64ri killed renamable $rdx(tied-def 0), 53, implicit-def dead $eflags
    //   CMP32ri killed renamable $edx, 1023, implicit-def $eflags, implicit killed $rdx
    //   renamable $cl = SETCCr 2, implicit killed $eflags
    //   TEST64rr killed renamable $rax, killed renamable $rax, implicit-def $eflags
    //   renamable $al = SETCCr 8, implicit killed $eflags
    //   renamable $al = AND8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def dead $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_nnorm_double.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $rax = MOVSDto64rr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVQ_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $rcx = MOV64ri 9223372036854775807
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_cx.cur_reg, 0x7fffffffffffffff);
    }
    }
    // result cx is marked as alive


    // renamable $rcx = AND64rr killed renamable $rcx(tied-def 0), renamable $rax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(AND64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // result cx is marked as alive


    // renamable $rdx = MOV64ri -4503599627370496
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_dx.cur_reg, -0x10000000000000);
    }
    }
    // result dx is marked as alive


    // renamable $rdx = ADD64rr killed renamable $rdx(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(dx) is the same as its tied destination
        assert(scratch_dx.cur_reg.valid());
        ASMD(ADD64rr, scratch_dx.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead
    // argument cx is killed and marked as dead
    // result dx is marked as alive


    // renamable $rdx = SHR64ri killed renamable $rdx(tied-def 0), 53, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(dx) is the same as its tied destination
        assert(scratch_dx.cur_reg.valid());
        ASMD(SHR64ri, scratch_dx.cur_reg, 0x35);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive


    // CMP32ri killed renamable $edx, 1023, implicit-def $eflags, implicit killed $rdx
    do {
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(CMP32ri, scratch_dx.cur_reg, 0x3ff);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead
    // argument dx is killed and marked as dead


    // renamable $cl = SETCCr 2, implicit killed $eflags
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(SETC8r, scratch_cx.cur_reg);
    }
    }
    // result cx is marked as alive


    // TEST64rr killed renamable $rax, killed renamable $rax, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(TEST64rr, scratch_ax.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 8, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETS8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = AND8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND8rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_nsnorm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_nsnorm_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $rax = MOVSDto64rr killed renamable $xmm0
    //   renamable $rcx = MOV64ri 9223372036854775807
    //   renamable $rcx = AND64rr killed renamable $rcx(tied-def 0), renamable $rax, implicit-def dead $eflags
    //   renamable $rcx = DEC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
    //   renamable $rdx = MOV64ri 4503599627370495
    //   CMP64rr killed renamable $rcx, killed renamable $rdx, implicit-def $eflags
    //   renamable $cl = SETCCr 2, implicit killed $eflags
    //   TEST64rr killed renamable $rax, killed renamable $rax, implicit-def $eflags
    //   renamable $al = SETCCr 8, implicit killed $eflags
    //   renamable $al = AND8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def dead $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_nsnorm_double.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $rax = MOVSDto64rr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVQ_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $rcx = MOV64ri 9223372036854775807
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_cx.cur_reg, 0x7fffffffffffffff);
    }
    }
    // result cx is marked as alive


    // renamable $rcx = AND64rr killed renamable $rcx(tied-def 0), renamable $rax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(AND64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // result cx is marked as alive


    // renamable $rcx = DEC64r killed renamable $rcx(tied-def 0), implicit-def dead $eflags
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(DEC64r, scratch_cx.cur_reg);
    }
    }
    // argument cx is killed and marked as dead
    // result cx is marked as alive


    // renamable $rdx = MOV64ri 4503599627370495
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_dx.cur_reg, 0xfffffffffffff);
    }
    }
    // result dx is marked as alive


    // CMP64rr killed renamable $rcx, killed renamable $rdx, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP64rr, scratch_cx.cur_reg, scratch_dx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument dx is killed and marked as dead


    // renamable $cl = SETCCr 2, implicit killed $eflags
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(SETC8r, scratch_cx.cur_reg);
    }
    }
    // result cx is marked as alive


    // TEST64rr killed renamable $rax, killed renamable $rax, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(TEST64rr, scratch_ax.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 8, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETS8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = AND8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND8rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_nzero_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_nzero_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $rax = MOVSDto64rr killed renamable $xmm0
    //   dead renamable $rax = NEG64r killed renamable $rax(tied-def 0), implicit-def $eflags
    //   renamable $al = SETCCr 0, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_nzero_double.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $rax = MOVSDto64rr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVQ_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // dead renamable $rax = NEG64r killed renamable $rax(tied-def 0), implicit-def $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(NEG64r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as dead


    // renamable $al = SETCCr 0, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETO8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_pzero_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_pzero_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $rax = MOVSDto64rr killed renamable $xmm0
    //   TEST64rr killed renamable $rax, killed renamable $rax, implicit-def $eflags
    //   renamable $al = SETCCr 4, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_pzero_double.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $rax = MOVSDto64rr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVQ_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // TEST64rr killed renamable $rax, killed renamable $rax, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(TEST64rr, scratch_ax.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 4, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETZ8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_psnorm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_psnorm_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $rax = MOVSDto64rr killed renamable $xmm0
    //   renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def dead $eflags
    //   renamable $rcx = MOV64ri 4503599627370495
    //   CMP64rr killed renamable $rax, killed renamable $rcx, implicit-def $eflags
    //   renamable $al = SETCCr 2, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_psnorm_double.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $rax = MOVSDto64rr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVQ_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = DEC64r killed renamable $rax(tied-def 0), implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(DEC64r, scratch_ax.cur_reg);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $rcx = MOV64ri 4503599627370495
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_cx.cur_reg, 0xfffffffffffff);
    }
    }
    // result cx is marked as alive


    // CMP64rr killed renamable $rax, killed renamable $rcx, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP64rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead


    // renamable $al = SETCCr 2, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETC8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_pnorm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_pnorm_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $rax = MOVSDto64rr killed renamable $xmm0
    //   renamable $rcx = MOV64ri 9223372036854775807
    //   renamable $rcx = AND64rr killed renamable $rcx(tied-def 0), renamable $rax, implicit-def dead $eflags
    //   renamable $rdx = MOV64ri -4503599627370496
    //   renamable $rdx = ADD64rr killed renamable $rdx(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   renamable $rdx = SHR64ri killed renamable $rdx(tied-def 0), 53, implicit-def dead $eflags
    //   CMP32ri killed renamable $edx, 1023, implicit-def $eflags, implicit killed $rdx
    //   renamable $cl = SETCCr 2, implicit killed $eflags
    //   TEST64rr killed renamable $rax, killed renamable $rax, implicit-def $eflags
    //   renamable $al = SETCCr 9, implicit killed $eflags
    //   renamable $al = AND8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def dead $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_pnorm_double.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $rax = MOVSDto64rr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVQ_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $rcx = MOV64ri 9223372036854775807
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_cx.cur_reg, 0x7fffffffffffffff);
    }
    }
    // result cx is marked as alive


    // renamable $rcx = AND64rr killed renamable $rcx(tied-def 0), renamable $rax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(AND64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // result cx is marked as alive


    // renamable $rdx = MOV64ri -4503599627370496
    {
    if (1) {
        // def dx has not been allocated yet
        scratch_dx.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_dx.cur_reg, -0x10000000000000);
    }
    }
    // result dx is marked as alive


    // renamable $rdx = ADD64rr killed renamable $rdx(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(dx) is the same as its tied destination
        assert(scratch_dx.cur_reg.valid());
        ASMD(ADD64rr, scratch_dx.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead
    // argument cx is killed and marked as dead
    // result dx is marked as alive


    // renamable $rdx = SHR64ri killed renamable $rdx(tied-def 0), 53, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(dx) is the same as its tied destination
        assert(scratch_dx.cur_reg.valid());
        ASMD(SHR64ri, scratch_dx.cur_reg, 0x35);
    }
    }
    // argument dx is killed and marked as dead
    // result dx is marked as alive


    // CMP32ri killed renamable $edx, 1023, implicit-def $eflags, implicit killed $rdx
    do {
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(CMP32ri, scratch_dx.cur_reg, 0x3ff);
        break;
    }
    }
    } while (false);
    // argument dx is killed and marked as dead
    // argument dx is killed and marked as dead


    // renamable $cl = SETCCr 2, implicit killed $eflags
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(SETC8r, scratch_cx.cur_reg);
    }
    }
    // result cx is marked as alive


    // TEST64rr killed renamable $rax, killed renamable $rax, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(TEST64rr, scratch_ax.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 9, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETNS8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = AND8rr killed renamable $al(tied-def 0), killed renamable $cl, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(AND8rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_pinf_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_pinf_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Constant Pool:
    //   cp#0: 0x7FF0000000000000, align=8
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   nofpexcept UCOMISDrm killed renamable $xmm0, $rip, 1, $noreg, %const.0, $noreg, implicit-def $eflags, implicit $mxcsr :: (load (s64) from constant-pool)
    //   renamable $al = SETCCr 3, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_pinf_double.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // nofpexcept UCOMISDrm killed renamable $xmm0, $rip, 1, $noreg, %const.0, $noreg, implicit-def $eflags, implicit $mxcsr :: (load (s64) from constant-pool)
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        SymRef &op4_sym = this->sym_is_fpclass_pinf_double_cp0;
        if (op4_sym == Assembler::INVALID_SYM_REF) [[unlikely]] {
            const std::array<u8, 8> data = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xF0, 0x7F};
            op4_sym = derived()->assembler.sym_def_data("", data, 8, true, false, true, false);
        }
        ASMD(SSE_UCOMISDrm, op0, FE_MEM(FE_IP, 0, FE_NOREG, 0));
        derived()->assembler.reloc_text_pc32(op4_sym, derived()->assembler.text_cur_off() - 4, -4);
    }
    }
    // argument xmm0 is killed and marked as dead


    // renamable $al = SETCCr 3, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETNC8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_nan_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_nan_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    //   renamable $al = SETCCr 10, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_nan_double.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // nofpexcept UCOMISDrr killed renamable $xmm0, killed renamable $xmm0, implicit-def $eflags, implicit $mxcsr
    do {
    {
    auto cond0 = param_1.encodeable_as_mem();
    if (cond0) {
        AsmReg op0 = param_1.as_reg(this);
        ASMD(SSE_UCOMISDrm, op0, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_1.as_reg(this);
        AsmReg op1 = param_1.as_reg(this);
        ASMD(SSE_UCOMISDrr, op0, op1);
        break;
    }
    }
    } while (false);
    // argument xmm0 is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // renamable $al = SETCCr 10, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETP8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond1 = param_0.encodeable_as_imm32_sext();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    auto cond2 = param_0.encodeable_as_mem();
    if (cond2) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond2));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_inf_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_inf_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $rax = MOVSDto64rr killed renamable $xmm0
    //   renamable $rcx = MOV64ri 9223372036854775807
    //   renamable $rcx = AND64rr killed renamable $rcx(tied-def 0), killed renamable $rax, implicit-def dead $eflags
    //   renamable $rax = MOV64ri 9218868437227405312
    //   CMP64rr killed renamable $rcx, killed renamable $rax, implicit-def $eflags
    //   renamable $al = SETCCr 4, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_inf_double.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $rax = MOVSDto64rr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVQ_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $rcx = MOV64ri 9223372036854775807
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_cx.cur_reg, 0x7fffffffffffffff);
    }
    }
    // result cx is marked as alive


    // renamable $rcx = AND64rr killed renamable $rcx(tied-def 0), killed renamable $rax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(AND64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result cx is marked as alive


    // renamable $rax = MOV64ri 9218868437227405312
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_ax.cur_reg, 0x7ff0000000000000);
    }
    }
    // result ax is marked as alive


    // CMP64rr killed renamable $rcx, killed renamable $rax, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 4, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETZ8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_norm_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_norm_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $rax = MOVSDto64rr killed renamable $xmm0
    //   renamable $rcx = MOV64ri 9223372036854775807
    //   renamable $rcx = AND64rr killed renamable $rcx(tied-def 0), killed renamable $rax, implicit-def dead $eflags
    //   renamable $rax = MOV64ri -4503599627370496
    //   renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   renamable $rax = SHR64ri killed renamable $rax(tied-def 0), 53, implicit-def dead $eflags
    //   CMP32ri killed renamable $eax, 1023, implicit-def $eflags, implicit killed $rax
    //   renamable $al = SETCCr 2, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_norm_double.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $rax = MOVSDto64rr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVQ_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $rcx = MOV64ri 9223372036854775807
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_cx.cur_reg, 0x7fffffffffffffff);
    }
    }
    // result cx is marked as alive


    // renamable $rcx = AND64rr killed renamable $rcx(tied-def 0), killed renamable $rax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(AND64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result cx is marked as alive


    // renamable $rax = MOV64ri -4503599627370496
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_ax.cur_reg, -0x10000000000000);
    }
    }
    // result ax is marked as alive


    // renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(ADD64rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = SHR64ri killed renamable $rax(tied-def 0), 53, implicit-def dead $eflags
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        ASMD(SHR64ri, scratch_ax.cur_reg, 0x35);
    }
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // CMP32ri killed renamable $eax, 1023, implicit-def $eflags, implicit killed $rax
    do {
    {
    if (1) {
        // operand exceeds NumImplicitUses, ignore
        ASMD(CMP32ri, scratch_ax.cur_reg, 0x3ff);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 2, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETC8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_is_fpclass_finite_double(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function is_fpclass_finite_double: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $xmm0
    //   renamable $rax = MOVSDto64rr killed renamable $xmm0
    //   renamable $rcx = MOV64ri 9223372036854775807
    //   renamable $rcx = AND64rr killed renamable $rcx(tied-def 0), killed renamable $rax, implicit-def dead $eflags
    //   renamable $rax = MOV64ri 9218868437227405312
    //   CMP64rr killed renamable $rcx, killed renamable $rax, implicit-def $eflags
    //   renamable $al = SETCCr 12, implicit killed $eflags
    //   renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    //   RET64 killed $al
    // 
    // # End machine code for function is_fpclass_finite_double.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $rax = MOVSDto64rr killed renamable $xmm0
    {
    if (1) {
        AsmReg op1 = param_1.as_reg(this);
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SSE_MOVQ_X2Grr, scratch_ax.cur_reg, op1);
    }
    }
    // argument xmm0 is killed and marked as dead
    // result ax is marked as alive


    // renamable $rcx = MOV64ri 9223372036854775807
    {
    if (1) {
        // def cx has not been allocated yet
        scratch_cx.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_cx.cur_reg, 0x7fffffffffffffff);
    }
    }
    // result cx is marked as alive


    // renamable $rcx = AND64rr killed renamable $rcx(tied-def 0), killed renamable $rax, implicit-def dead $eflags
    do {
    {
    if (1) {
        // operand 1(cx) is the same as its tied destination
        assert(scratch_cx.cur_reg.valid());
        ASMD(AND64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // result cx is marked as alive


    // renamable $rax = MOV64ri 9218868437227405312
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOV64ri, scratch_ax.cur_reg, 0x7ff0000000000000);
    }
    }
    // result ax is marked as alive


    // CMP64rr killed renamable $rcx, killed renamable $rax, implicit-def $eflags
    do {
    {
    if (1) {
        ASMD(CMP64rr, scratch_cx.cur_reg, scratch_ax.cur_reg);
        break;
    }
    }
    } while (false);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead


    // renamable $al = SETCCr 12, implicit killed $eflags
    {
    if (1) {
        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(SETL8r, scratch_ax.cur_reg);
    }
    }
    // result ax is marked as alive


    // renamable $al = OR8rr killed renamable $al(tied-def 0), killed renamable $dil, implicit-def dead $eflags, implicit killed $edi
    do {
    {
    auto cond0 = param_0.encodeable_as_imm32_sext();
    if (cond0) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8ri, scratch_ax.cur_reg, (*cond0));
        break;
    }
    }
    {
    auto cond1 = param_0.encodeable_as_mem();
    if (cond1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rm, scratch_ax.cur_reg, (*cond1));
        break;
    }
    }
    {
    if (1) {
        // operand 1(ax) is the same as its tied destination
        assert(scratch_ax.cur_reg.valid());
        AsmReg op2 = param_0.as_reg(this);
        // operand exceeds NumImplicitUses, ignore
        ASMD(OR8rr, scratch_ax.cur_reg, op2);
        break;
    }
    }
    } while (false);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $al
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_prefetch_rl0(AsmOperand param_0) {
    // # Machine code for function prefetch_rl0: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   PREFETCHNTA killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s8) from %ir.0)
    //   RET64
    // 
    // # End machine code for function prefetch_rl0.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};


    // PREFETCHNTA killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s8) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        ASMD(PREFETCHNTAm, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(PREFETCHNTAm, FE_MEM(op0, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_prefetch_rl1(AsmOperand param_0) {
    // # Machine code for function prefetch_rl1: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   PREFETCHT2 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s8) from %ir.0)
    //   RET64
    // 
    // # End machine code for function prefetch_rl1.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};


    // PREFETCHT2 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s8) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        ASMD(PREFETCHT2m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(PREFETCHT2m, FE_MEM(op0, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_prefetch_rl2(AsmOperand param_0) {
    // # Machine code for function prefetch_rl2: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   PREFETCHT1 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s8) from %ir.0)
    //   RET64
    // 
    // # End machine code for function prefetch_rl2.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};


    // PREFETCHT1 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s8) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        ASMD(PREFETCHT1m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(PREFETCHT1m, FE_MEM(op0, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_prefetch_rl3(AsmOperand param_0) {
    // # Machine code for function prefetch_rl3: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   PREFETCHT0 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s8) from %ir.0)
    //   RET64
    // 
    // # End machine code for function prefetch_rl3.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};


    // PREFETCHT0 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s8) from %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        ASMD(PREFETCHT0m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(PREFETCHT0m, FE_MEM(op0, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_prefetch_wl0(AsmOperand param_0) {
    // # Machine code for function prefetch_wl0: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   PREFETCHNTA killed renamable $rdi, 1, $noreg, 0, $noreg :: (store (s8) into %ir.0)
    //   RET64
    // 
    // # End machine code for function prefetch_wl0.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};


    // PREFETCHNTA killed renamable $rdi, 1, $noreg, 0, $noreg :: (store (s8) into %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        ASMD(PREFETCHNTAm, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(PREFETCHNTAm, FE_MEM(op0, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_prefetch_wl1(AsmOperand param_0) {
    // # Machine code for function prefetch_wl1: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   PREFETCHT2 killed renamable $rdi, 1, $noreg, 0, $noreg :: (store (s8) into %ir.0)
    //   RET64
    // 
    // # End machine code for function prefetch_wl1.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};


    // PREFETCHT2 killed renamable $rdi, 1, $noreg, 0, $noreg :: (store (s8) into %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        ASMD(PREFETCHT2m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(PREFETCHT2m, FE_MEM(op0, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_prefetch_wl2(AsmOperand param_0) {
    // # Machine code for function prefetch_wl2: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   PREFETCHT1 killed renamable $rdi, 1, $noreg, 0, $noreg :: (store (s8) into %ir.0)
    //   RET64
    // 
    // # End machine code for function prefetch_wl2.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};


    // PREFETCHT1 killed renamable $rdi, 1, $noreg, 0, $noreg :: (store (s8) into %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        ASMD(PREFETCHT1m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(PREFETCHT1m, FE_MEM(op0, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy,
          typename Config>bool EncodeCompiler<Adaptor, Derived, BaseTy, Config>::encode_prefetch_wl3(AsmOperand param_0) {
    // # Machine code for function prefetch_wl3: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   PREFETCHT0 killed renamable $rdi, 1, $noreg, 0, $noreg :: (store (s8) into %ir.0)
    //   RET64
    // 
    // # End machine code for function prefetch_wl3.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};


    // PREFETCHT0 killed renamable $rdi, 1, $noreg, 0, $noreg :: (store (s8) into %ir.0)
    do {
    {
    auto cond0 = param_0.encodeable_with(FE_MEM(FE_NOREG, 0, FE_NOREG, 0));
    if (cond0) {
        ASMD(PREFETCHT0m, (*cond0));
        break;
    }
    }
    {
    if (1) {
        AsmReg op0 = param_0.as_reg(this);
        ASMD(PREFETCHT0m, FE_MEM(op0, 0, FE_NOREG, 0));
        break;
    }
    }
    } while (false);
    // argument di is killed and marked as dead


    // RET64
    return true;

}



} // namespace tpde_encodegen

#undef ASMD
// SPDX-SnippetEnd
