// SPDX-FileCopyrightText: 2024 Tobias Schwarz <tobias.schwarz@tum.de>
// SPDX-FileCopyrightText: 2024 Tobias Kamm <tobias.kamm@tum.de>
//
// SPDX-License-Identifier: LicenseRef-Proprietary AND CC0-1.0

// NOTE: This file is autogenerated by tpde-encodegen. Please DO NOT edit this file
// as all changes will be overwritten once the file is generated again.
// NOTE: Some parts of this file are subject to the default license of TPDE
// and only the autogenerated code falls under the CC0-1.0 license

// SPDX-SnippetBegin
// SPDX-License-Identifier: LicenseRef-Proprietary
#pragma once

#include <variant>

#include "base.hpp"
#include "tpde/x64/CompilerX64.hpp"

// Helper macros for assembling in the compiler
#if defined(ASMD)
    #error Got definition for ASM macros from somewhere else. Maybe you included compilers for multiple architectures?
#endif

#define ASMD(...) ASMC(this->derived(), __VA_ARGS__)

namespace tpde_encodegen {

using namespace tpde;

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          typename BaseTy>
struct EncodeCompiler {
    using CompilerX64  = tpde::x64::CompilerX64<Adaptor, Derived, BaseTy>;
    using ScratchReg   = typename CompilerX64::ScratchReg;
    using AsmReg       = typename CompilerX64::AsmReg;
    using ValuePartRef = typename CompilerX64::ValuePartRef;
    using Assembler = typename CompilerX64::Assembler;
    using Label = typename Assembler::Label;
    using ValLocalIdx = typename CompilerX64::ValLocalIdx;

    struct AsmOperand {
        struct Address {
            AsmReg  base;
            AsmReg  index;
            uint8_t scale;
            int32_t disp;

            explicit Address(AsmReg base, int32_t disp = 0)
                : base(base), scale(0), disp(disp) {}

            [[nodiscard]] bool has_index() const noexcept { return scale != 0; }
        };

        struct Immediate {
            union {
                u64                const_u64;
                std::array<u8, 64> const_bytes;
            };

            u32 bank, size;
        };

        // TODO(ts): evaluate the use of std::variant
        // TODO(ts): I don't like the ValuePartRefs but we also don't want to
        // force all the operands into registers at the start of the encoding...
        std::variant<std::monostate,
                     ScratchReg,
                     ValuePartRef,
                     ValuePartRef *,
                     AsmReg,
                     Address,
                     Immediate>
            state;

        AsmOperand() = default;

        AsmOperand(AsmOperand &) = delete;

        AsmOperand(AsmOperand &&other) noexcept {
            state       = std::move(other.state);
            other.state = std::monostate{};
        }

        AsmOperand &operator=(const AsmOperand &) noexcept = delete;

        AsmOperand &operator=(AsmOperand &&other) noexcept {
            if (this == &other) {
                return *this;
            }
            state       = std::move(other.state);
            other.state = std::monostate{};
            return *this;
        }

        // ReSharper disable CppNonExplicitConvertingConstructor
        // NOLINTBEGIN(*-explicit-constructor)

        // reg can't be overwritten
        AsmOperand(AsmReg reg) noexcept : state{reg} {}

        // no salvaging
        AsmOperand(const ScratchReg &reg) noexcept {
            assert(!reg.cur_reg.invalid());
            state = reg.cur_reg;
        }

        // salvaging
        AsmOperand(ScratchReg &&reg) noexcept {
            assert(!reg.cur_reg.invalid());
            state = std::move(reg);
        }

        // no salvaging
        AsmOperand(ValuePartRef &ref) noexcept {
            if (ref.is_const) {
                state = Immediate{.const_bytes = ref.state.c.const_data,
                                  .bank        = ref.state.c.bank,
                                  .size        = ref.state.c.size};
                return;
            }
            // TODO(ts): check if it is a variable_ref/frame_ptr and then
            // turning it into an Address?
            state = &ref;
        }

        // salvaging
        AsmOperand(ValuePartRef &&ref) noexcept {
            if (ref.is_const) {
                state = Immediate{.const_bytes = ref.state.c.const_data,
                                  .bank        = ref.state.c.bank,
                                  .size        = ref.state.c.size};
                return;
            }
            state = std::move(ref);
        }

        AsmOperand(Address addr) noexcept { state = addr; }

        AsmOperand(Immediate imm) noexcept { state = imm; }

        // NOLINTEND(*-explicit-constructor)
        // ReSharper restore CppNonExplicitConvertingConstructor

        [[nodiscard]] bool is_addr() const noexcept {
            return std::holds_alternative<Address>(state);
        }

        [[nodiscard]] bool is_imm() const noexcept {
            return std::holds_alternative<Immediate>(state);
        }

        [[nodiscard]] Address &addr() noexcept {
            return std::get<Address>(state);
        }

        [[nodiscard]] Immediate &imm() noexcept {
            return std::get<Immediate>(state);
        }

        [[nodiscard]] ValuePartRef &val_ref() noexcept {
            return std::get<ValuePartRef>(state);
        }

        [[nodiscard]] bool encodeable_as_imm64() const noexcept;
        [[nodiscard]] bool encodeable_as_imm32_sext() const noexcept;
        [[nodiscard]] bool encodeable_as_imm16_sext() const noexcept;
        [[nodiscard]] bool encodeable_as_imm8_sext() const noexcept;
        [[nodiscard]] bool val_ref_prefers_mem_enc() const noexcept;
        [[nodiscard]] u32  val_ref_frame_off() const noexcept;
        AsmReg             as_reg(EncodeCompiler *compiler) noexcept;
        bool try_salvage(ScratchReg &, u8 bank) noexcept;
        bool try_salvage_if_nonalloc(ScratchReg &, u8 bank) noexcept;
        void try_salvage_or_materialize(EncodeCompiler *compiler,
                                        ScratchReg     &dst_scratch,
                                        u8              bank,
                                        u32             size) noexcept;
        // compatibility
        bool try_salvage(AsmReg&, ScratchReg &, u8 bank) noexcept;
        void try_salvage_or_materialize(EncodeCompiler *compiler,
                                        AsmReg &dst_reg,
                                        ScratchReg     &dst_scratch,
                                        u8              bank,
                                        u32             size) noexcept;
        void reset() noexcept;
    };

    CompilerX64 *derived() noexcept {
        return static_cast<CompilerX64 *>(static_cast<Derived *>(this));
    }

    const CompilerX64 *derived() const noexcept {
        return static_cast<const CompilerX64 *>(
            static_cast<const Derived *>(this));
    }

    static bool reg_needs_avx512(AsmReg reg) noexcept {
        if (reg.id() > AsmReg::XMM15) {
            return true;
        }
        return false;
    }

    [[nodiscard]] bool has_avx() const noexcept {
        return derived()->has_cpu_feats(CompilerX64::CPU_AVX);
    }

    [[nodiscard]] static bool disp_add_encodeable(int32_t disp, int32_t add) noexcept {
        const auto tmp = static_cast<int64_t>(disp) + add;
        return (static_cast<int64_t>(static_cast<int32_t>(tmp)) == tmp);
    }

    struct FixedRegBackup {
        ScratchReg  scratch;
        ValLocalIdx local_idx;
        u32         part;
        u32         lock_count;
    };

    void scratch_alloc_specific(AsmReg                              reg,
                                ScratchReg                         &scratch,
                                std::initializer_list<AsmOperand *> operands,
                                FixedRegBackup &backup_reg) noexcept;

    void scratch_check_fixed_backup(ScratchReg     &scratch,
                                    FixedRegBackup &backup_reg,
                                    bool            is_ret_reg) noexcept;

// SPDX-SnippetEnd
// SPDX-SnippetBegin
// SPDX-License-Identifier: CC0-1.0
// clang-format off

    bool encode_loadi8(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi16(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi24(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi40(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi48(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi56(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadi128(AsmOperand param_0, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_loadf32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadf64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadv128(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadv256(AsmOperand param_0, ScratchReg &result_0);
    bool encode_loadv512(AsmOperand param_0, ScratchReg &result_0);
    bool encode_storei8(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei16(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei32(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei64(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei24(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei40(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei48(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei56(AsmOperand param_0, AsmOperand param_1);
    bool encode_storei128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2);
    bool encode_storef32(AsmOperand param_0, AsmOperand param_1);
    bool encode_storef64(AsmOperand param_0, AsmOperand param_1);
    bool encode_storev128(AsmOperand param_0, AsmOperand param_1);
    bool encode_storev256(AsmOperand param_0, AsmOperand param_1);
    bool encode_storev512(AsmOperand param_0, AsmOperand param_1);
    bool encode_addi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_subi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_muli32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_udivi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_sdivi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_uremi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_sremi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_landi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_lori32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_lxori32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_shli32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_shri32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_ashri32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_addi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_subi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_muli64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_udivi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_sdivi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_uremi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_sremi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_landi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_lori64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_lxori64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_shli64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_shri64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_ashri64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_addi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_subi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_muli128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_landi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_lori128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_lxori128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_shli128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_shri128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_ashri128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1);
    bool encode_sext_8_to_32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_sext_16_to_32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_sext_32_to_64(AsmOperand param_0, ScratchReg &result_0);
    bool encode_sext_arbitrary_to_32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_sext_arbitrary_to_64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0);
    bool encode_zext_8_to_32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_zext_16_to_32(AsmOperand param_0, ScratchReg &result_0);
    bool encode_zext_32_to_64(AsmOperand param_0, ScratchReg &result_0);


};
// SPDX-SnippetEnd



// SPDX-SnippetBegin
// SPDX-License-Identifier: LicenseRef-Proprietary
// clang-format on
template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::
    encodeable_as_imm64() const noexcept {
    if (!is_imm() || std::get<Immediate>(state).size > 8) {
        return false;
    }

    const u64 imm = std::get<Immediate>(state).const_u64;
    return imm;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::
    encodeable_as_imm32_sext() const noexcept {
    if (!is_imm()) {
        return false;
    }

    const auto& data = std::get<Immediate>(state);
    assert(data.size <= 8);
    if (data.size <= 4) {
        // always encodeable
        return true;
    }

    const u64 imm = data.const_u64;
    return static_cast<i64>(static_cast<i32>(imm)) == static_cast<i64>(imm);
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::
    encodeable_as_imm16_sext() const noexcept {
    if (!is_imm()) {
        return false;
    }

    const auto& info = std::get<Immediate>(state);
    assert(info.bank == 0);
    assert(info.size <= 8);

    const u64 imm = std::get<Immediate>(state).const_u64;
    return static_cast<i64>(static_cast<i16>(imm)) == static_cast<i64>(imm);
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::
    encodeable_as_imm8_sext() const noexcept {
    if (!is_imm()) {
        return false;
    }

    const auto& info = std::get<Immediate>(state);
    assert(info.bank == 0);
    assert(info.size <= 8);

    const u64 imm = std::get<Immediate>(state).const_u64;
    return static_cast<i64>(static_cast<i8>(imm)) == static_cast<i8>(imm);
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::
    val_ref_prefers_mem_enc() const noexcept {
    const ValuePartRef *ptr;
    if (std::holds_alternative<ValuePartRef>(state)) {
        ptr = &std::get<ValuePartRef>(state);
    } else if (std::holds_alternative<ValuePartRef *>(state)) {
        ptr = std::get<ValuePartRef *>(state);
    } else {
        return false;
    }

    if (ptr->is_const) {
        return false;
    }

    const auto ap = ptr->assignment();
    return (!ap.register_valid() && !ap.variable_ref());
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
u32 EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::val_ref_frame_off()
    const noexcept {
    if (std::holds_alternative<ValuePartRef>(state)) {
        const auto &val_ref = std::get<ValuePartRef>(state);
        assert(!val_ref.is_const);
        const auto ap = val_ref.assignment();
        assert(!ap.variable_ref());
        return ap.frame_off();
    } else {
        assert(std::holds_alternative<ValuePartRef *>(state));
        const auto *val_ref = std::get<ValuePartRef *>(state);
        assert(!val_ref->is_const);
        const auto ap = val_ref->assignment();
        assert(!ap.variable_ref());
        return ap.frame_off();
    }
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
typename EncodeCompiler<Adaptor, Derived, BaseTy>::AsmReg
    EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::as_reg(
        EncodeCompiler<Adaptor, Derived, BaseTy> *compiler) noexcept {
    if (std::holds_alternative<ScratchReg>(state)) {
        return std::get<ScratchReg>(state).cur_reg;
    }
    if (std::holds_alternative<ValuePartRef>(state)) {
        return std::get<ValuePartRef>(state).alloc_reg();
    }
    if (std::holds_alternative<ValuePartRef *>(state)) {
        return std::get<ValuePartRef *>(state)->alloc_reg();
    }
    if (std::holds_alternative<AsmReg>(state)) {
        return std::get<AsmReg>(state);
    }
    if (is_imm()) {
        const auto &data = std::get<Immediate>(state);
        ScratchReg  dst{compiler->derived()};
        const auto  dst_reg = dst.alloc_from_bank(data.bank);
        compiler->derived()->materialize_constant(
            data.const_bytes, data.bank, data.size, dst_reg);
        state = std::move(dst);
        return dst_reg;
    }
    // TODO(ts): allow mem operands with scratchreg param?
    assert(0);
    exit(1);
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::try_salvage(
    ScratchReg &dst_scratch, const u8 bank) noexcept {
    if (!dst_scratch.cur_reg.invalid()) {
        return false;
    }

    if (std::holds_alternative<ScratchReg>(state)) {
        assert(std::get<ScratchReg>(state).compiler->register_file.reg_bank(
                   std::get<ScratchReg>(state).cur_reg)
               == bank);
        dst_scratch = std::move(std::get<ScratchReg>(state));
        state       = std::monostate{};
        return true;
    } else if (std::holds_alternative<ValuePartRef>(state)) {
        auto &ref = std::get<ValuePartRef>(state);
        assert(ref.bank() == bank);
        if (ref.can_salvage()) {
            auto reg = ref.salvage();
            dst_scratch.alloc_specific(reg);
            return true;
        }
        // dst = std::get<ValuePartRef>(state).alloc_reg();
        // return;
    } else if (std::holds_alternative<Immediate>(state)) {
        this->as_reg(static_cast<Derived *>(dst_scratch.compiler));
        assert(std::holds_alternative<ScratchReg>(state));
        assert(std::get<ScratchReg>(state).compiler->register_file.reg_bank(
                   std::get<ScratchReg>(state).cur_reg)
               == bank);

        dst_scratch = std::move(std::get<ScratchReg>(state));
        state       = std::monostate{};
        return true;
    }

    dst_scratch.alloc_from_bank(bank);
    return false;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::try_salvage_if_nonalloc(
    ScratchReg &dst_scratch, const u8 bank) noexcept {
    if (!dst_scratch.cur_reg.invalid()) {
        return false;
    }
    return try_salvage(dst_scratch, bank);
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::try_salvage(
    AsmReg &dst_reg, ScratchReg &dst_scratch, const u8 bank) noexcept {
    const auto res = try_salvage(dst_scratch, bank);
    dst_reg = dst_scratch.cur_reg;
    return res;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
void EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::
    try_salvage_or_materialize(EncodeCompiler *compiler,
                               AsmReg         &dst_reg,
                               ScratchReg     &dst_scratch,
                               u8              bank,
                               u32             size) noexcept {
    try_salvage_or_materialize(compiler, dst_scratch, bank, size);
    dst_reg = dst_scratch.cur_reg;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
void EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::
    try_salvage_or_materialize(EncodeCompiler *compiler,
                               ScratchReg     &dst_scratch,
                               u8              bank,
                               u32             size) noexcept {
    if (!this->try_salvage(dst_scratch, bank)) {
        if (bank == 0) {
            if (std::holds_alternative<Immediate>(state)) {
                const auto &data = std::get<Immediate>(state);
                compiler->derived()->materialize_constant(data.const_bytes,
                                                          data.bank,
                                                          data.size,
                                                          dst_scratch.cur_reg);
                return;
            }

            AsmReg val = this->as_reg(compiler);
            if (size <= 4) {
                ASMC(compiler->derived(), MOV32rr, dst_scratch.cur_reg, val);
            } else {
                ASMC(compiler->derived(), MOV64rr, dst_scratch.cur_reg, val);
            }
        } else {
            // TODO
            assert(0);
            exit(1);
        }
    }
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
void EncodeCompiler<Adaptor, Derived, BaseTy>::AsmOperand::reset() noexcept {
    state = std::monostate{};
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
void EncodeCompiler<Adaptor, Derived, BaseTy>::scratch_alloc_specific(
    AsmReg                              reg,
    ScratchReg                         &scratch,
    std::initializer_list<AsmOperand *> operands,
    FixedRegBackup                     &backup_reg) noexcept {
    if (!derived()->register_file.is_fixed(reg)) [[likely]] {
        scratch.alloc_specific(reg);
        return;
    }

    const auto bank = derived()->register_file.reg_bank(reg);
    if (bank != 0) {
        // TODO(ts): need to know the size
        assert(0);
        exit(1);
    }

    const auto alloc_backup = [this, &backup_reg, &scratch, reg, bank]() {
        const auto bak_reg    = backup_reg.scratch.alloc_from_bank(bank);
        auto      &reg_file   = derived()->register_file;
        auto      &assignment = reg_file.assignments[reg.id()];
        backup_reg.local_idx  = assignment.local_idx;
        backup_reg.part       = assignment.part;
        backup_reg.lock_count = assignment.lock_count;

        assignment.local_idx  = CompilerX64::INVALID_VAL_LOCAL_IDX;
        assignment.part       = 0;
        assignment.lock_count = 0;

        assert(scratch.cur_reg.invalid());
        scratch.cur_reg = reg;

        ASMD(MOV64rr, bak_reg, reg);
    };

    // check if one of the operands holds the fixed register
    for (auto *op_ptr : operands) {
        auto &op = op_ptr->state;
        if (std::holds_alternative<ScratchReg>(op)) {
            auto &op_scratch = std::get<ScratchReg>(op);
            if (op_scratch.cur_reg == reg) {
                scratch = std::move(op_scratch);
                op_scratch.alloc_from_bank(bank);
                ASMD(MOV64rr, op_scratch.cur_reg, reg);
                return;
            }
            continue;
        }

        if (std::holds_alternative<ValuePartRef>(op)) {
            auto &op_ref = std::get<ValuePartRef>(op);
            if (!op_ref.is_const) {
                assert(!op_ref.state.v.locked);
                const auto ap = op_ref.assignment();
                if (ap.register_valid()) {
                    assert(AsmReg{ap.full_reg_id()} != reg);
                }
            }
            continue;
        }

        if (std::holds_alternative<ValuePartRef *>(op)) {
            auto &op_ref = *std::get<ValuePartRef *>(op);
            if (!op_ref.is_const) {
                assert(!op_ref.state.v.locked);
                const auto ap = op_ref.assignment();
                if (ap.register_valid()) {
                    assert(AsmReg{ap.full_reg_id()} != reg);
                }
            }
            continue;
        }

        if (std::holds_alternative<AsmReg>(op)) {
            auto &op_reg = std::get<AsmReg>(op);
            if (op_reg == reg) {
                alloc_backup();
                op_reg = backup_reg.scratch.cur_reg;
                return;
            }
            continue;
        }

        if (std::holds_alternative<typename AsmOperand::Address>(op)) {
            auto &addr = std::get<typename AsmOperand::Address>(op);
            if (addr.base == reg) {
                alloc_backup();
                addr.base = backup_reg.scratch.cur_reg;
                return;
            }
            if (addr.scale != 0 && addr.index == reg) {
                alloc_backup();
                addr.index = backup_reg.scratch.cur_reg;
                return;
            }
            continue;
        }
    }

    // otherwise temporarily store it somewhere else
    alloc_backup();
    return;
}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
void EncodeCompiler<Adaptor, Derived, BaseTy>::scratch_check_fixed_backup(
    ScratchReg     &scratch,
    FixedRegBackup &backup_reg,
    const bool      is_ret_reg) noexcept {
    if (backup_reg.scratch.cur_reg.invalid()) [[likely]] {
        return;
    }

    assert(!scratch.cur_reg.invalid());
    auto &reg_file        = derived()->register_file;
    auto &assignment      = reg_file.assignments[scratch.cur_reg.id()];
    assignment.local_idx  = backup_reg.local_idx;
    assignment.part       = backup_reg.part;
    assignment.lock_count = backup_reg.lock_count;

    assert(reg_file.reg_bank(scratch.cur_reg) == 0);
    if (is_ret_reg) {
        // TODO(ts): allocate another scratch? Though at this point the scratch
        // regs have not been released yet so we might need to spill...

        // need to switch around backup and reg so it can be returned as a
        // ScratchReg
        ASMD(XCHG64rr, scratch.cur_reg, backup_reg.scratch.cur_reg);
        scratch.cur_reg            = backup_reg.scratch.cur_reg;
        backup_reg.scratch.cur_reg = AsmReg::make_invalid();
    } else {
        ASMD(MOV64rr, scratch.cur_reg, backup_reg.scratch.cur_reg);

        scratch.cur_reg = AsmReg::make_invalid();
        backup_reg.scratch.reset();
    }
}

// clang-format off
// SPDX-SnippetEnd
// SPDX-SnippetBegin
// SPDX-License-Identifier: CC0-1.0

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_loadi8(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s8) from %ir.0, !tbaa !5)
    //   RET64 killed $eax
    // 
    // # End machine code for function loadi8.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s8) from %ir.0, !tbaa !5)
    // operand 1 is a memory operand
    FeMem inst0_op1;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            base = scratch_ax.cur_reg;
        } else {
            base = param_0.as_reg(this);
        }
        inst0_op1 = FE_MEM(base, 0, FE_NOREG, 0);
    }

    // def ax has not been allocated yet
    scratch_ax.alloc_from_bank(0);
    ASMD(MOVZXr32m8, scratch_ax.cur_reg, inst0_op1);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_loadi16(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $eax = MOVZX32rm16 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s16) from %ir.0, !tbaa !8)
    //   RET64 killed $eax
    // 
    // # End machine code for function loadi16.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOVZX32rm16 killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s16) from %ir.0, !tbaa !8)
    // operand 1 is a memory operand
    FeMem inst0_op1;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            base = scratch_ax.cur_reg;
        } else {
            base = param_0.as_reg(this);
        }
        inst0_op1 = FE_MEM(base, 0, FE_NOREG, 0);
    }

    // def ax has not been allocated yet
    scratch_ax.alloc_from_bank(0);
    ASMD(MOVZXr32m16, scratch_ax.cur_reg, inst0_op1);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_loadi32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $eax = MOV32rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s32) from %ir.0, !tbaa !10)
    //   RET64 killed $eax
    // 
    // # End machine code for function loadi32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOV32rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s32) from %ir.0, !tbaa !10)
    // operand 1 is a memory operand
    FeMem inst0_op1;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            base = scratch_ax.cur_reg;
        } else {
            base = param_0.as_reg(this);
        }
        inst0_op1 = FE_MEM(base, 0, FE_NOREG, 0);
    }

    // def ax has not been allocated yet
    scratch_ax.alloc_from_bank(0);
    ASMD(MOV32rm, scratch_ax.cur_reg, inst0_op1);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_loadi64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $rax = MOV64rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s64) from %ir.0, !tbaa !12)
    //   RET64 killed $rax
    // 
    // # End machine code for function loadi64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $rax = MOV64rm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s64) from %ir.0, !tbaa !12)
    // operand 1 is a memory operand
    FeMem inst0_op1;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            base = scratch_ax.cur_reg;
        } else {
            base = param_0.as_reg(this);
        }
        inst0_op1 = FE_MEM(base, 0, FE_NOREG, 0);
    }

    // def ax has not been allocated yet
    scratch_ax.alloc_from_bank(0);
    ASMD(MOV64rm, scratch_ax.cur_reg, inst0_op1);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_loadi24(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi24: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $ecx = MOVZX32rm16 renamable $rdi, 1, $noreg, 0, $noreg :: (load (s16) from %ir.0, align 1)
    //   renamable $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 2, $noreg :: (load (s8) from %ir.0 + 2)
    //   renamable $eax = SHL32ri killed renamable $eax(tied-def 0), 16, implicit-def dead $eflags
    //   renamable $eax = OR32rr killed renamable $eax(tied-def 0), killed renamable $ecx, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function loadi24.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $ecx = MOVZX32rm16 renamable $rdi, 1, $noreg, 0, $noreg :: (load (s16) from %ir.0, align 1)
    // operand 1 is a memory operand
    FeMem inst0_op1;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst0_op1 = FE_MEM(base, 0, FE_NOREG, 0);
    }

    // def cx has not been allocated yet
    scratch_cx.alloc_from_bank(0);
    ASMD(MOVZXr32m16, scratch_cx.cur_reg, inst0_op1);
    // result cx is marked as alive


    // renamable $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 2, $noreg :: (load (s8) from %ir.0 + 2)
    // operand 1 is a memory operand
    FeMem inst1_op1;
    ScratchReg inst1_op1_scratch{derived()};
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // LLVM memory operand has displacement, check if it is encodeable with the disp from addr
        if (disp_add_encodeable(addr.disp, 2)) {
            inst1_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp + 2);
        } else {
            // displacements not encodeable together, need to materialize the addr
            AsmReg base_tmp = inst1_op1_scratch.alloc_from_bank(0);
            ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
            inst1_op1 = FE_MEM(base_tmp, 0, FE_NOREG, 2);
        }
    } else {
        // di maps to operand param_0
        AsmReg base;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            base = scratch_ax.cur_reg;
        } else {
            base = param_0.as_reg(this);
        }
        inst1_op1 = FE_MEM(base, 0, FE_NOREG, 2);
    }

    // def ax has not been allocated yet
    scratch_ax.alloc_from_bank(0);
    ASMD(MOVZXr32m8, scratch_ax.cur_reg, inst1_op1);
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = SHL32ri killed renamable $eax(tied-def 0), 16, implicit-def dead $eflags
    // operand 0 is ax
    // operand 0(ax) is the same as its tied destination
    scratch_ax.alloc_from_bank(0);
    // operand 1 is an immediate operand

    ASMD(SHL32ri, scratch_ax.cur_reg, 16);
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $eax = OR32rr killed renamable $eax(tied-def 0), killed renamable $ecx, implicit-def dead $eflags
    // operand 0 is ax
    // operand 0(ax) is the same as its tied destination
    scratch_ax.alloc_from_bank(0);
    // operand 1 is cx
    // operand 1(cx) is a simple register
    AsmReg inst3_op1 = scratch_cx.cur_reg;

    ASMD(OR32rr, scratch_ax.cur_reg, inst3_op1);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_loadi40(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi40: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $ecx = MOV32rm renamable $rdi, 1, $noreg, 0, $noreg, implicit-def $rcx :: (load (s32) from %ir.0, align 1)
    //   renamable $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 4, $noreg, implicit-def $rax :: (load (s8) from %ir.0 + 4)
    //   renamable $rax = SHL64ri killed renamable $rax(tied-def 0), 32, implicit-def dead $eflags
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function loadi40.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $ecx = MOV32rm renamable $rdi, 1, $noreg, 0, $noreg, implicit-def $rcx :: (load (s32) from %ir.0, align 1)
    // operand 1 is a memory operand
    FeMem inst0_op1;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst0_op1 = FE_MEM(base, 0, FE_NOREG, 0);
    }

    // def cx has not been allocated yet
    scratch_cx.alloc_from_bank(0);
    // Ignoring implicit def RCX as it exceeds the number of implicit defs in the MCInstrDesc
    ASMD(MOV32rm, scratch_cx.cur_reg, inst0_op1);
    // result cx is marked as alive
    // result cx is marked as alive


    // renamable $eax = MOVZX32rm8 killed renamable $rdi, 1, $noreg, 4, $noreg, implicit-def $rax :: (load (s8) from %ir.0 + 4)
    // operand 1 is a memory operand
    FeMem inst1_op1;
    ScratchReg inst1_op1_scratch{derived()};
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // LLVM memory operand has displacement, check if it is encodeable with the disp from addr
        if (disp_add_encodeable(addr.disp, 4)) {
            inst1_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp + 4);
        } else {
            // displacements not encodeable together, need to materialize the addr
            AsmReg base_tmp = inst1_op1_scratch.alloc_from_bank(0);
            ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
            inst1_op1 = FE_MEM(base_tmp, 0, FE_NOREG, 4);
        }
    } else {
        // di maps to operand param_0
        AsmReg base;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            base = scratch_ax.cur_reg;
        } else {
            base = param_0.as_reg(this);
        }
        inst1_op1 = FE_MEM(base, 0, FE_NOREG, 4);
    }

    // def ax has not been allocated yet
    scratch_ax.alloc_from_bank(0);
    // Ignoring implicit def RAX as it exceeds the number of implicit defs in the MCInstrDesc
    ASMD(MOVZXr32m8, scratch_ax.cur_reg, inst1_op1);
    // argument di is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $rax = SHL64ri killed renamable $rax(tied-def 0), 32, implicit-def dead $eflags
    // operand 0 is ax
    // operand 0(ax) is the same as its tied destination
    scratch_ax.alloc_from_bank(0);
    // operand 1 is an immediate operand

    ASMD(SHL64ri, scratch_ax.cur_reg, 32);
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    // operand 0 is ax
    // operand 0(ax) is the same as its tied destination
    scratch_ax.alloc_from_bank(0);
    // operand 1 is cx
    // operand 1(cx) is a simple register
    AsmReg inst3_op1 = scratch_cx.cur_reg;

    ASMD(OR64rr, scratch_ax.cur_reg, inst3_op1);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_loadi48(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi48: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $ecx = MOV32rm renamable $rdi, 1, $noreg, 0, $noreg, implicit-def $rcx :: (load (s32) from %ir.0, align 1)
    //   renamable $eax = MOVZX32rm16 killed renamable $rdi, 1, $noreg, 4, $noreg, implicit-def $rax :: (load (s16) from %ir.0 + 4, align 1)
    //   renamable $rax = SHL64ri killed renamable $rax(tied-def 0), 32, implicit-def dead $eflags
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function loadi48.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $ecx = MOV32rm renamable $rdi, 1, $noreg, 0, $noreg, implicit-def $rcx :: (load (s32) from %ir.0, align 1)
    // operand 1 is a memory operand
    FeMem inst0_op1;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst0_op1 = FE_MEM(base, 0, FE_NOREG, 0);
    }

    // def cx has not been allocated yet
    scratch_cx.alloc_from_bank(0);
    // Ignoring implicit def RCX as it exceeds the number of implicit defs in the MCInstrDesc
    ASMD(MOV32rm, scratch_cx.cur_reg, inst0_op1);
    // result cx is marked as alive
    // result cx is marked as alive


    // renamable $eax = MOVZX32rm16 killed renamable $rdi, 1, $noreg, 4, $noreg, implicit-def $rax :: (load (s16) from %ir.0 + 4, align 1)
    // operand 1 is a memory operand
    FeMem inst1_op1;
    ScratchReg inst1_op1_scratch{derived()};
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // LLVM memory operand has displacement, check if it is encodeable with the disp from addr
        if (disp_add_encodeable(addr.disp, 4)) {
            inst1_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp + 4);
        } else {
            // displacements not encodeable together, need to materialize the addr
            AsmReg base_tmp = inst1_op1_scratch.alloc_from_bank(0);
            ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
            inst1_op1 = FE_MEM(base_tmp, 0, FE_NOREG, 4);
        }
    } else {
        // di maps to operand param_0
        AsmReg base;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            base = scratch_ax.cur_reg;
        } else {
            base = param_0.as_reg(this);
        }
        inst1_op1 = FE_MEM(base, 0, FE_NOREG, 4);
    }

    // def ax has not been allocated yet
    scratch_ax.alloc_from_bank(0);
    // Ignoring implicit def RAX as it exceeds the number of implicit defs in the MCInstrDesc
    ASMD(MOVZXr32m16, scratch_ax.cur_reg, inst1_op1);
    // argument di is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $rax = SHL64ri killed renamable $rax(tied-def 0), 32, implicit-def dead $eflags
    // operand 0 is ax
    // operand 0(ax) is the same as its tied destination
    scratch_ax.alloc_from_bank(0);
    // operand 1 is an immediate operand

    ASMD(SHL64ri, scratch_ax.cur_reg, 32);
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    // operand 0 is ax
    // operand 0(ax) is the same as its tied destination
    scratch_ax.alloc_from_bank(0);
    // operand 1 is cx
    // operand 1(cx) is a simple register
    AsmReg inst3_op1 = scratch_cx.cur_reg;

    ASMD(OR64rr, scratch_ax.cur_reg, inst3_op1);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_loadi56(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadi56: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $eax = MOVZX32rm16 renamable $rdi, 1, $noreg, 4, $noreg :: (load (s16) from %ir.0 + 4, align 1)
    //   renamable $ecx = MOVZX32rm8 renamable $rdi, 1, $noreg, 6, $noreg, implicit-def $rcx :: (load (s8) from %ir.0 + 6)
    //   renamable $ecx = SHL32ri killed renamable $ecx(tied-def 0), 16, implicit-def dead $eflags, implicit killed $rcx, implicit-def $rcx
    //   renamable $ecx = OR32rr killed renamable $ecx(tied-def 0), killed renamable $eax, implicit-def dead $eflags, implicit killed $rcx, implicit-def $rcx
    //   renamable $rcx = SHL64ri killed renamable $rcx(tied-def 0), 32, implicit-def dead $eflags
    //   renamable $eax = MOV32rm killed renamable $rdi, 1, $noreg, 0, $noreg, implicit-def $rax :: (load (s32) from %ir.0, align 1)
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function loadi56.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_cx{derived()};


    // renamable $eax = MOVZX32rm16 renamable $rdi, 1, $noreg, 4, $noreg :: (load (s16) from %ir.0 + 4, align 1)
    // operand 1 is a memory operand
    FeMem inst0_op1;
    ScratchReg inst0_op1_scratch{derived()};
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // LLVM memory operand has displacement, check if it is encodeable with the disp from addr
        if (disp_add_encodeable(addr.disp, 4)) {
            inst0_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp + 4);
        } else {
            // displacements not encodeable together, need to materialize the addr
            AsmReg base_tmp = inst0_op1_scratch.alloc_from_bank(0);
            ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
            inst0_op1 = FE_MEM(base_tmp, 0, FE_NOREG, 4);
        }
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst0_op1 = FE_MEM(base, 0, FE_NOREG, 4);
    }

    // def ax has not been allocated yet
    scratch_ax.alloc_from_bank(0);
    ASMD(MOVZXr32m16, scratch_ax.cur_reg, inst0_op1);
    // result ax is marked as alive


    // renamable $ecx = MOVZX32rm8 renamable $rdi, 1, $noreg, 6, $noreg, implicit-def $rcx :: (load (s8) from %ir.0 + 6)
    // operand 1 is a memory operand
    FeMem inst1_op1;
    ScratchReg inst1_op1_scratch{derived()};
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // LLVM memory operand has displacement, check if it is encodeable with the disp from addr
        if (disp_add_encodeable(addr.disp, 6)) {
            inst1_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp + 6);
        } else {
            // displacements not encodeable together, need to materialize the addr
            AsmReg base_tmp = inst1_op1_scratch.alloc_from_bank(0);
            ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
            inst1_op1 = FE_MEM(base_tmp, 0, FE_NOREG, 6);
        }
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst1_op1 = FE_MEM(base, 0, FE_NOREG, 6);
    }

    // def cx has not been allocated yet
    scratch_cx.alloc_from_bank(0);
    // Ignoring implicit def RCX as it exceeds the number of implicit defs in the MCInstrDesc
    ASMD(MOVZXr32m8, scratch_cx.cur_reg, inst1_op1);
    // result cx is marked as alive
    // result cx is marked as alive


    // renamable $ecx = SHL32ri killed renamable $ecx(tied-def 0), 16, implicit-def dead $eflags, implicit killed $rcx, implicit-def $rcx
    // operand 0 is cx
    // operand 0(cx) is the same as its tied destination
    scratch_cx.alloc_from_bank(0);
    // operand 1 is an immediate operand
    // Handling implicit operand cx
    // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

    // Ignoring implicit def RCX as it exceeds the number of implicit defs in the MCInstrDesc
    ASMD(SHL32ri, scratch_cx.cur_reg, 16);
    // argument cx is killed and marked as dead
    // argument cx is killed and marked as dead
    // result cx is marked as alive
    // result cx is marked as alive


    // renamable $ecx = OR32rr killed renamable $ecx(tied-def 0), killed renamable $eax, implicit-def dead $eflags, implicit killed $rcx, implicit-def $rcx
    // operand 0 is cx
    // operand 0(cx) is the same as its tied destination
    scratch_cx.alloc_from_bank(0);
    // operand 1 is ax
    // operand 1(ax) is a simple register
    AsmReg inst3_op1 = scratch_ax.cur_reg;
    // Handling implicit operand cx
    // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

    // Ignoring implicit def RCX as it exceeds the number of implicit defs in the MCInstrDesc
    ASMD(OR32rr, scratch_cx.cur_reg, inst3_op1);
    // argument cx is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result cx is marked as alive
    // result cx is marked as alive


    // renamable $rcx = SHL64ri killed renamable $rcx(tied-def 0), 32, implicit-def dead $eflags
    // operand 0 is cx
    // operand 0(cx) is the same as its tied destination
    scratch_cx.alloc_from_bank(0);
    // operand 1 is an immediate operand

    ASMD(SHL64ri, scratch_cx.cur_reg, 32);
    // argument cx is killed and marked as dead
    // result cx is marked as alive


    // renamable $eax = MOV32rm killed renamable $rdi, 1, $noreg, 0, $noreg, implicit-def $rax :: (load (s32) from %ir.0, align 1)
    // operand 1 is a memory operand
    FeMem inst5_op1;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst5_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            base = scratch_ax.cur_reg;
        } else {
            base = param_0.as_reg(this);
        }
        inst5_op1 = FE_MEM(base, 0, FE_NOREG, 0);
    }

    // def ax has not been allocated yet
    scratch_ax.alloc_from_bank(0);
    // Ignoring implicit def RAX as it exceeds the number of implicit defs in the MCInstrDesc
    ASMD(MOV32rm, scratch_ax.cur_reg, inst5_op1);
    // argument di is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    // operand 0 is ax
    // operand 0(ax) is the same as its tied destination
    scratch_ax.alloc_from_bank(0);
    // operand 1 is cx
    // operand 1(cx) is a simple register
    AsmReg inst6_op1 = scratch_cx.cur_reg;

    ASMD(OR64rr, scratch_ax.cur_reg, inst6_op1);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_loadi128(AsmOperand param_0, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function loadi128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $rax = MOV64rm renamable $rdi, 1, $noreg, 0, $noreg :: (load (s64) from %ir.0, align 16, !tbaa !18)
    //   renamable $rdx = MOV64rm killed renamable $rdi, 1, $noreg, 8, $noreg :: (load (s64) from %ir.0 + 8, basealign 16, !tbaa !18)
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function loadi128.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};


    // renamable $rax = MOV64rm renamable $rdi, 1, $noreg, 0, $noreg :: (load (s64) from %ir.0, align 16, !tbaa !18)
    // operand 1 is a memory operand
    FeMem inst0_op1;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst0_op1 = FE_MEM(base, 0, FE_NOREG, 0);
    }

    // def ax has not been allocated yet
    scratch_ax.alloc_from_bank(0);
    ASMD(MOV64rm, scratch_ax.cur_reg, inst0_op1);
    // result ax is marked as alive


    // renamable $rdx = MOV64rm killed renamable $rdi, 1, $noreg, 8, $noreg :: (load (s64) from %ir.0 + 8, basealign 16, !tbaa !18)
    // operand 1 is a memory operand
    FeMem inst1_op1;
    ScratchReg inst1_op1_scratch{derived()};
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // LLVM memory operand has displacement, check if it is encodeable with the disp from addr
        if (disp_add_encodeable(addr.disp, 8)) {
            inst1_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp + 8);
        } else {
            // displacements not encodeable together, need to materialize the addr
            AsmReg base_tmp = inst1_op1_scratch.alloc_from_bank(0);
            ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
            inst1_op1 = FE_MEM(base_tmp, 0, FE_NOREG, 8);
        }
    } else {
        // di maps to operand param_0
        AsmReg base;
        if (param_0.try_salvage_if_nonalloc(scratch_dx, 0)) {
            base = scratch_dx.cur_reg;
        } else {
            base = param_0.as_reg(this);
        }
        inst1_op1 = FE_MEM(base, 0, FE_NOREG, 8);
    }

    // def dx has not been allocated yet
    scratch_dx.alloc_from_bank(0);
    ASMD(MOV64rm, scratch_dx.cur_reg, inst1_op1);
    // argument di is killed and marked as dead
    // result dx is marked as alive


    // RET64 killed $rax, killed $rdx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_loadf32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadf32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $xmm0 = MOVSSrm_alt killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s32) from %ir.0, !tbaa !20)
    //   RET64 killed $xmm0
    // 
    // # End machine code for function loadf32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = MOVSSrm_alt killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s32) from %ir.0, !tbaa !20)
    // operand 1 is a memory operand
    FeMem inst0_op1;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst0_op1 = FE_MEM(base, 0, FE_NOREG, 0);
    }

    // def xmm0 has not been allocated yet
    scratch_xmm0.alloc_from_bank(1);
    ASMD(SSE_MOVSSrm, scratch_xmm0.cur_reg, inst0_op1);
    // argument di is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_loadf64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadf64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $xmm0 = MOVSDrm_alt killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s64) from %ir.0, !tbaa !22)
    //   RET64 killed $xmm0
    // 
    // # End machine code for function loadf64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = MOVSDrm_alt killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s64) from %ir.0, !tbaa !22)
    // operand 1 is a memory operand
    FeMem inst0_op1;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst0_op1 = FE_MEM(base, 0, FE_NOREG, 0);
    }

    // def xmm0 has not been allocated yet
    scratch_xmm0.alloc_from_bank(1);
    ASMD(SSE_MOVSDrm, scratch_xmm0.cur_reg, inst0_op1);
    // argument di is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_loadv128(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadv128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $xmm0 = MOVAPSrm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s128) from %ir.0, !tbaa !5)
    //   RET64 killed $xmm0
    // 
    // # End machine code for function loadv128.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $xmm0 = MOVAPSrm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s128) from %ir.0, !tbaa !5)
    // operand 1 is a memory operand
    FeMem inst0_op1;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst0_op1 = FE_MEM(base, 0, FE_NOREG, 0);
    }

    // def xmm0 has not been allocated yet
    scratch_xmm0.alloc_from_bank(1);
    ASMD(SSE_MOVAPSrm, scratch_xmm0.cur_reg, inst0_op1);
    // argument di is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $xmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_loadv256(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadv256: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $ymm0 = VMOVAPSYrm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s256) from %ir.0, !tbaa !5)
    //   RET64 killed $ymm0
    // 
    // # End machine code for function loadv256.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $ymm0 = VMOVAPSYrm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s256) from %ir.0, !tbaa !5)
    // operand 1 is a memory operand
    FeMem inst0_op1;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst0_op1 = FE_MEM(base, 0, FE_NOREG, 0);
    }

    // def xmm0 has not been allocated yet
    scratch_xmm0.alloc_from_bank(1);
    ASMD(VMOVAPS256rm, scratch_xmm0.cur_reg, inst0_op1);
    // argument di is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $ymm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_loadv512(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function loadv512: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $rdi
    //   renamable $zmm0 = VMOVAPSZrm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s512) from %ir.0, !tbaa !5)
    //   RET64 killed $zmm0
    // 
    // # End machine code for function loadv512.
    // 

    // Mapping di to param_0
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // renamable $zmm0 = VMOVAPSZrm killed renamable $rdi, 1, $noreg, 0, $noreg :: (load (s512) from %ir.0, !tbaa !5)
    // operand 1 is a memory operand
    FeMem inst0_op1;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op1 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst0_op1 = FE_MEM(base, 0, FE_NOREG, 0);
    }

    // def xmm0 has not been allocated yet
    scratch_xmm0.alloc_from_bank(1);
    ASMD(VMOVAPS512rm, scratch_xmm0.cur_reg, inst0_op1);
    // argument di is killed and marked as dead
    // result xmm0 is marked as alive


    // RET64 killed $zmm0
    // returning reg xmm0 as result_0
    result_0 = std::move(scratch_xmm0);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_storei8(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei8: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $esi, $rdi
    //   MOV8mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $sil, implicit killed $esi :: (store (s8) into %ir.0, !tbaa !5)
    //   RET64
    // 
    // # End machine code for function storei8.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // MOV8mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $sil, implicit killed $esi :: (store (s8) into %ir.0, !tbaa !5)
    // MOV8mr has a preferred encoding as MOV8mi if possible
    if (param_1.encodeable_as_imm8_sext()) {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();
        // Handling implicit operand si
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        ASMD(MOV8mi, inst0_op0, imm.const_u64);
    } else {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst0_op1 = param_1.as_reg(this);
        // Handling implicit operand si
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        ASMD(MOV8mr, inst0_op0, inst0_op1);
    }
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_storei16(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei16: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $esi, $rdi
    //   MOV16mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $si, implicit killed $esi :: (store (s16) into %ir.0, !tbaa !8)
    //   RET64
    // 
    // # End machine code for function storei16.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // MOV16mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $si, implicit killed $esi :: (store (s16) into %ir.0, !tbaa !8)
    // MOV16mr has a preferred encoding as MOV16mi if possible
    if (param_1.encodeable_as_imm16_sext()) {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();
        // Handling implicit operand si
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        ASMD(MOV16mi, inst0_op0, imm.const_u64);
    } else {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst0_op1 = param_1.as_reg(this);
        // Handling implicit operand si
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        ASMD(MOV16mr, inst0_op0, inst0_op1);
    }
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_storei32(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $esi, $rdi
    //   MOV32mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $esi :: (store (s32) into %ir.0, !tbaa !10)
    //   RET64
    // 
    // # End machine code for function storei32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // MOV32mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $esi :: (store (s32) into %ir.0, !tbaa !10)
    // MOV32mr has a preferred encoding as MOV32mi if possible
    if (param_1.encodeable_as_imm32_sext()) {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(MOV32mi, inst0_op0, imm.const_u64);
    } else {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst0_op1 = param_1.as_reg(this);

        ASMD(MOV32mr, inst0_op0, inst0_op1);
    }
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_storei64(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   MOV64mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rsi :: (store (s64) into %ir.0, !tbaa !12)
    //   RET64
    // 
    // # End machine code for function storei64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // MOV64mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rsi :: (store (s64) into %ir.0, !tbaa !12)
    // MOV64mr has a preferred encoding as MOV64mi if possible
    if (param_1.encodeable_as_imm32_sext()) {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(MOV64mi, inst0_op0, imm.const_u64);
    } else {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst0_op1 = param_1.as_reg(this);

        ASMD(MOV64mr, inst0_op0, inst0_op1);
    }
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_storei24(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei24: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $esi, $rdi
    //   MOV16mr renamable $rdi, 1, $noreg, 0, $noreg, renamable $si :: (store (s16) into %ir.0, align 1)
    //   renamable $esi = SHR32ri killed renamable $esi(tied-def 0), 16, implicit-def dead $eflags
    //   MOV8mr killed renamable $rdi, 1, $noreg, 2, $noreg, killed renamable $sil, implicit killed $esi :: (store (s8) into %ir.0 + 2)
    //   RET64
    // 
    // # End machine code for function storei24.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // MOV16mr renamable $rdi, 1, $noreg, 0, $noreg, renamable $si :: (store (s16) into %ir.0, align 1)
    // MOV16mr has a preferred encoding as MOV16mi if possible
    if (param_1.encodeable_as_imm16_sext()) {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(MOV16mi, inst0_op0, imm.const_u64);
    } else {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst0_op1 = param_1.as_reg(this);

        ASMD(MOV16mr, inst0_op0, inst0_op1);
    }


    // renamable $esi = SHR32ri killed renamable $esi(tied-def 0), 16, implicit-def dead $eflags
    // operand 0 is si
    // si is mapped to param_1
    // operand 0(param_1) is tied so try to salvage or materialize
    param_1.try_salvage_or_materialize(this, scratch_si, 0, 4);
    // operand 1 is an immediate operand

    ASMD(SHR32ri, scratch_si.cur_reg, 16);
    // argument si is killed and marked as dead
    // result si is marked as alive


    // MOV8mr killed renamable $rdi, 1, $noreg, 2, $noreg, killed renamable $sil, implicit killed $esi :: (store (s8) into %ir.0 + 2)
    // operand 0 is a memory operand
    FeMem inst2_op0;
    ScratchReg inst2_op0_scratch{derived()};
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // LLVM memory operand has displacement, check if it is encodeable with the disp from addr
        if (disp_add_encodeable(addr.disp, 2)) {
            inst2_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp + 2);
        } else {
            // displacements not encodeable together, need to materialize the addr
            AsmReg base_tmp = inst2_op0_scratch.alloc_from_bank(0);
            ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
            inst2_op0 = FE_MEM(base_tmp, 0, FE_NOREG, 2);
        }
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst2_op0 = FE_MEM(base, 0, FE_NOREG, 2);
    }
    // operand 1 is si
    // operand 1(si) is a simple register
    AsmReg inst2_op1 = scratch_si.cur_reg;
    // Handling implicit operand si
    // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

    ASMD(MOV8mr, inst2_op0, inst2_op1);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_storei40(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei40: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   MOV32mr renamable $rdi, 1, $noreg, 0, $noreg, renamable $esi :: (store (s32) into %ir.0, align 1)
    //   renamable $rsi = SHR64ri killed renamable $rsi(tied-def 0), 32, implicit-def dead $eflags
    //   MOV8mr killed renamable $rdi, 1, $noreg, 4, $noreg, killed renamable $sil, implicit killed $rsi :: (store (s8) into %ir.0 + 4)
    //   RET64
    // 
    // # End machine code for function storei40.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // MOV32mr renamable $rdi, 1, $noreg, 0, $noreg, renamable $esi :: (store (s32) into %ir.0, align 1)
    // MOV32mr has a preferred encoding as MOV32mi if possible
    if (param_1.encodeable_as_imm32_sext()) {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(MOV32mi, inst0_op0, imm.const_u64);
    } else {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst0_op1 = param_1.as_reg(this);

        ASMD(MOV32mr, inst0_op0, inst0_op1);
    }


    // renamable $rsi = SHR64ri killed renamable $rsi(tied-def 0), 32, implicit-def dead $eflags
    // operand 0 is si
    // si is mapped to param_1
    // operand 0(param_1) is tied so try to salvage or materialize
    param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
    // operand 1 is an immediate operand

    ASMD(SHR64ri, scratch_si.cur_reg, 32);
    // argument si is killed and marked as dead
    // result si is marked as alive


    // MOV8mr killed renamable $rdi, 1, $noreg, 4, $noreg, killed renamable $sil, implicit killed $rsi :: (store (s8) into %ir.0 + 4)
    // operand 0 is a memory operand
    FeMem inst2_op0;
    ScratchReg inst2_op0_scratch{derived()};
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // LLVM memory operand has displacement, check if it is encodeable with the disp from addr
        if (disp_add_encodeable(addr.disp, 4)) {
            inst2_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp + 4);
        } else {
            // displacements not encodeable together, need to materialize the addr
            AsmReg base_tmp = inst2_op0_scratch.alloc_from_bank(0);
            ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
            inst2_op0 = FE_MEM(base_tmp, 0, FE_NOREG, 4);
        }
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst2_op0 = FE_MEM(base, 0, FE_NOREG, 4);
    }
    // operand 1 is si
    // operand 1(si) is a simple register
    AsmReg inst2_op1 = scratch_si.cur_reg;
    // Handling implicit operand si
    // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

    ASMD(MOV8mr, inst2_op0, inst2_op1);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_storei48(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei48: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   MOV32mr renamable $rdi, 1, $noreg, 0, $noreg, renamable $esi :: (store (s32) into %ir.0, align 1)
    //   renamable $rsi = SHR64ri killed renamable $rsi(tied-def 0), 32, implicit-def dead $eflags
    //   MOV16mr killed renamable $rdi, 1, $noreg, 4, $noreg, killed renamable $si, implicit killed $rsi :: (store (s16) into %ir.0 + 4, align 1)
    //   RET64
    // 
    // # End machine code for function storei48.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // MOV32mr renamable $rdi, 1, $noreg, 0, $noreg, renamable $esi :: (store (s32) into %ir.0, align 1)
    // MOV32mr has a preferred encoding as MOV32mi if possible
    if (param_1.encodeable_as_imm32_sext()) {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(MOV32mi, inst0_op0, imm.const_u64);
    } else {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst0_op1 = param_1.as_reg(this);

        ASMD(MOV32mr, inst0_op0, inst0_op1);
    }


    // renamable $rsi = SHR64ri killed renamable $rsi(tied-def 0), 32, implicit-def dead $eflags
    // operand 0 is si
    // si is mapped to param_1
    // operand 0(param_1) is tied so try to salvage or materialize
    param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
    // operand 1 is an immediate operand

    ASMD(SHR64ri, scratch_si.cur_reg, 32);
    // argument si is killed and marked as dead
    // result si is marked as alive


    // MOV16mr killed renamable $rdi, 1, $noreg, 4, $noreg, killed renamable $si, implicit killed $rsi :: (store (s16) into %ir.0 + 4, align 1)
    // operand 0 is a memory operand
    FeMem inst2_op0;
    ScratchReg inst2_op0_scratch{derived()};
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // LLVM memory operand has displacement, check if it is encodeable with the disp from addr
        if (disp_add_encodeable(addr.disp, 4)) {
            inst2_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp + 4);
        } else {
            // displacements not encodeable together, need to materialize the addr
            AsmReg base_tmp = inst2_op0_scratch.alloc_from_bank(0);
            ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
            inst2_op0 = FE_MEM(base_tmp, 0, FE_NOREG, 4);
        }
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst2_op0 = FE_MEM(base, 0, FE_NOREG, 4);
    }
    // operand 1 is si
    // operand 1(si) is a simple register
    AsmReg inst2_op1 = scratch_si.cur_reg;
    // Handling implicit operand si
    // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

    ASMD(MOV16mr, inst2_op0, inst2_op1);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_storei56(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storei56: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   MOV32mr renamable $rdi, 1, $noreg, 0, $noreg, renamable $esi :: (store (s32) into %ir.0, align 1)
    //   $rax = MOV64rr $rsi
    //   renamable $rax = SHR64ri killed renamable $rax(tied-def 0), 48, implicit-def dead $eflags
    //   MOV8mr renamable $rdi, 1, $noreg, 6, $noreg, killed renamable $al, implicit killed $rax :: (store (s8) into %ir.0 + 6)
    //   renamable $rsi = SHR64ri killed renamable $rsi(tied-def 0), 32, implicit-def dead $eflags
    //   MOV16mr killed renamable $rdi, 1, $noreg, 4, $noreg, killed renamable $si, implicit killed $rsi :: (store (s16) into %ir.0 + 4, align 1)
    //   RET64
    // 
    // # End machine code for function storei56.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // MOV32mr renamable $rdi, 1, $noreg, 0, $noreg, renamable $esi :: (store (s32) into %ir.0, align 1)
    // MOV32mr has a preferred encoding as MOV32mi if possible
    if (param_1.encodeable_as_imm32_sext()) {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(MOV32mi, inst0_op0, imm.const_u64);
    } else {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst0_op1 = param_1.as_reg(this);

        ASMD(MOV32mr, inst0_op0, inst0_op1);
    }


    // $rax = MOV64rr $rsi
    // aliasing ax to si


    // renamable $rax = SHR64ri killed renamable $rax(tied-def 0), 48, implicit-def dead $eflags
    // operand 0 is ax
    // ax is an alias for si
    // si is mapped to param_1
    AsmReg inst2_op0 = scratch_ax.alloc_from_bank(0);
    AsmReg inst2_op0_tmp = param_1.as_reg(this);
    ASMD(MOV64rr, inst2_op0, inst2_op0_tmp);
    // operand 1 is an immediate operand

    ASMD(SHR64ri, scratch_ax.cur_reg, 48);
    // argument ax is killed and marked as dead
    // removing alias from ax to si
    // result ax is marked as alive


    // MOV8mr renamable $rdi, 1, $noreg, 6, $noreg, killed renamable $al, implicit killed $rax :: (store (s8) into %ir.0 + 6)
    // operand 0 is a memory operand
    FeMem inst3_op0;
    ScratchReg inst3_op0_scratch{derived()};
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // LLVM memory operand has displacement, check if it is encodeable with the disp from addr
        if (disp_add_encodeable(addr.disp, 6)) {
            inst3_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp + 6);
        } else {
            // displacements not encodeable together, need to materialize the addr
            AsmReg base_tmp = inst3_op0_scratch.alloc_from_bank(0);
            ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
            inst3_op0 = FE_MEM(base_tmp, 0, FE_NOREG, 6);
        }
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst3_op0 = FE_MEM(base, 0, FE_NOREG, 6);
    }
    // operand 1 is ax
    // operand 1(ax) is a simple register
    AsmReg inst3_op1 = scratch_ax.cur_reg;
    // Handling implicit operand ax
    // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

    ASMD(MOV8mr, inst3_op0, inst3_op1);
    // argument ax is killed and marked as dead
    // argument ax is killed and marked as dead


    // renamable $rsi = SHR64ri killed renamable $rsi(tied-def 0), 32, implicit-def dead $eflags
    // operand 0 is si
    // si is mapped to param_1
    // operand 0(param_1) is tied so try to salvage or materialize
    param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
    // operand 1 is an immediate operand

    ASMD(SHR64ri, scratch_si.cur_reg, 32);
    // argument si is killed and marked as dead
    // result si is marked as alive


    // MOV16mr killed renamable $rdi, 1, $noreg, 4, $noreg, killed renamable $si, implicit killed $rsi :: (store (s16) into %ir.0 + 4, align 1)
    // operand 0 is a memory operand
    FeMem inst5_op0;
    ScratchReg inst5_op0_scratch{derived()};
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // LLVM memory operand has displacement, check if it is encodeable with the disp from addr
        if (disp_add_encodeable(addr.disp, 4)) {
            inst5_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp + 4);
        } else {
            // displacements not encodeable together, need to materialize the addr
            AsmReg base_tmp = inst5_op0_scratch.alloc_from_bank(0);
            ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
            inst5_op0 = FE_MEM(base_tmp, 0, FE_NOREG, 4);
        }
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst5_op0 = FE_MEM(base, 0, FE_NOREG, 4);
    }
    // operand 1 is si
    // operand 1(si) is a simple register
    AsmReg inst5_op1 = scratch_si.cur_reg;
    // Handling implicit operand si
    // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

    ASMD(MOV16mr, inst5_op0, inst5_op1);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_storei128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2) {
    // # Machine code for function storei128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.3):
    //   liveins: $rdi, $rdx, $rsi
    //   MOV64mr renamable $rdi, 1, $noreg, 8, $noreg, killed renamable $rdx :: (store (s64) into %ir.0 + 8, basealign 16, !tbaa !18)
    //   MOV64mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rsi :: (store (s64) into %ir.0, align 16, !tbaa !18)
    //   RET64
    // 
    // # End machine code for function storei128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};


    // MOV64mr renamable $rdi, 1, $noreg, 8, $noreg, killed renamable $rdx :: (store (s64) into %ir.0 + 8, basealign 16, !tbaa !18)
    // MOV64mr has a preferred encoding as MOV64mi if possible
    if (param_2.encodeable_as_imm32_sext()) {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        ScratchReg inst0_op0_scratch{derived()};
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // LLVM memory operand has displacement, check if it is encodeable with the disp from addr
            if (disp_add_encodeable(addr.disp, 8)) {
                inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp + 8);
            } else {
                // displacements not encodeable together, need to materialize the addr
                AsmReg base_tmp = inst0_op0_scratch.alloc_from_bank(0);
                ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
                inst0_op0 = FE_MEM(base_tmp, 0, FE_NOREG, 8);
            }
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 8);
        }
        // operand 1 is an immediate operand
        const auto& imm = param_2.imm();

        ASMD(MOV64mi, inst0_op0, imm.const_u64);
    } else {
        // operand 0 is a memory operand
        FeMem inst0_op0;
        ScratchReg inst0_op0_scratch{derived()};
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // LLVM memory operand has displacement, check if it is encodeable with the disp from addr
            if (disp_add_encodeable(addr.disp, 8)) {
                inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp + 8);
            } else {
                // displacements not encodeable together, need to materialize the addr
                AsmReg base_tmp = inst0_op0_scratch.alloc_from_bank(0);
                ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
                inst0_op0 = FE_MEM(base_tmp, 0, FE_NOREG, 8);
            }
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst0_op0 = FE_MEM(base, 0, FE_NOREG, 8);
        }
        // operand 1 is dx
        // dx is mapped to param_2
        AsmReg inst0_op1 = param_2.as_reg(this);

        ASMD(MOV64mr, inst0_op0, inst0_op1);
    }
    // argument dx is killed and marked as dead


    // MOV64mr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $rsi :: (store (s64) into %ir.0, align 16, !tbaa !18)
    // MOV64mr has a preferred encoding as MOV64mi if possible
    if (param_1.encodeable_as_imm32_sext()) {
        // operand 0 is a memory operand
        FeMem inst1_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst1_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst1_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(MOV64mi, inst1_op0, imm.const_u64);
    } else {
        // operand 0 is a memory operand
        FeMem inst1_op0;
        // looking at base di
        // di maps to param_0, so could be an address
        if (param_0.is_addr()) {
            const auto& addr = param_0.addr();
            // no index/disp in LLVM, can simply use the operand address
            inst1_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
        } else {
            // di maps to operand param_0
            AsmReg base = param_0.as_reg(this);
            inst1_op0 = FE_MEM(base, 0, FE_NOREG, 0);
        }
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst1_op1 = param_1.as_reg(this);

        ASMD(MOV64mr, inst1_op0, inst1_op1);
    }
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_storef32(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storef32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $xmm0
    //   MOVSSmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store (s32) into %ir.0, !tbaa !20)
    //   RET64
    // 
    // # End machine code for function storef32.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // MOVSSmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store (s32) into %ir.0, !tbaa !20)
    // operand 0 is a memory operand
    FeMem inst0_op0;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
    }
    // operand 1 is xmm0
    // xmm0 is mapped to param_1
    AsmReg inst0_op1 = param_1.as_reg(this);

    ASMD(SSE_MOVSSmr, inst0_op0, inst0_op1);
    // argument di is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_storef64(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storef64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $xmm0
    //   MOVSDmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store (s64) into %ir.0, !tbaa !22)
    //   RET64
    // 
    // # End machine code for function storef64.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // MOVSDmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store (s64) into %ir.0, !tbaa !22)
    // operand 0 is a memory operand
    FeMem inst0_op0;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
    }
    // operand 1 is xmm0
    // xmm0 is mapped to param_1
    AsmReg inst0_op1 = param_1.as_reg(this);

    ASMD(SSE_MOVSDmr, inst0_op0, inst0_op1);
    // argument di is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_storev128(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storev128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $xmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $xmm0
    //   MOVAPSmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store (s128) into %ir.0, !tbaa !5)
    //   RET64
    // 
    // # End machine code for function storev128.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // MOVAPSmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store (s128) into %ir.0, !tbaa !5)
    // operand 0 is a memory operand
    FeMem inst0_op0;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
    }
    // operand 1 is xmm0
    // xmm0 is mapped to param_1
    AsmReg inst0_op1 = param_1.as_reg(this);

    ASMD(SSE_MOVAPSmr, inst0_op0, inst0_op1);
    // argument di is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_storev256(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storev256: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $ymm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $ymm0
    //   VMOVAPSYmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $ymm0 :: (store (s256) into %ir.0, !tbaa !5)
    //   VZEROUPPER implicit-def dead $ymm0, implicit-def dead $ymm1, implicit-def dead $ymm2, implicit-def dead $ymm3, implicit-def dead $ymm4, implicit-def dead $ymm5, implicit-def dead $ymm6, implicit-def dead $ymm7, implicit-def dead $ymm8, implicit-def dead $ymm9, implicit-def dead $ymm10, implicit-def dead $ymm11, implicit-def dead $ymm12, implicit-def dead $ymm13, implicit-def dead $ymm14, implicit-def dead $ymm15
    //   RET64
    // 
    // # End machine code for function storev256.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // VMOVAPSYmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $ymm0 :: (store (s256) into %ir.0, !tbaa !5)
    // operand 0 is a memory operand
    FeMem inst0_op0;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
    }
    // operand 1 is xmm0
    // xmm0 is mapped to param_1
    AsmReg inst0_op1 = param_1.as_reg(this);

    ASMD(VMOVAPS256mr, inst0_op0, inst0_op1);
    // argument di is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // VZEROUPPER implicit-def dead $ymm0, implicit-def dead $ymm1, implicit-def dead $ymm2, implicit-def dead $ymm3, implicit-def dead $ymm4, implicit-def dead $ymm5, implicit-def dead $ymm6, implicit-def dead $ymm7, implicit-def dead $ymm8, implicit-def dead $ymm9, implicit-def dead $ymm10, implicit-def dead $ymm11, implicit-def dead $ymm12, implicit-def dead $ymm13, implicit-def dead $ymm14, implicit-def dead $ymm15
    // Skipping


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_storev512(AsmOperand param_0, AsmOperand param_1) {
    // # Machine code for function storev512: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $zmm0
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $zmm0
    //   VMOVAPSZmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $zmm0 :: (store (s512) into %ir.0, !tbaa !5)
    //   VZEROUPPER implicit-def dead $ymm0, implicit-def dead $ymm1, implicit-def dead $ymm2, implicit-def dead $ymm3, implicit-def dead $ymm4, implicit-def dead $ymm5, implicit-def dead $ymm6, implicit-def dead $ymm7, implicit-def dead $ymm8, implicit-def dead $ymm9, implicit-def dead $ymm10, implicit-def dead $ymm11, implicit-def dead $ymm12, implicit-def dead $ymm13, implicit-def dead $ymm14, implicit-def dead $ymm15
    //   RET64
    // 
    // # End machine code for function storev512.
    // 

    // Mapping di to param_0
    // Mapping xmm0 to param_1
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_xmm0{derived()};


    // VMOVAPSZmr killed renamable $rdi, 1, $noreg, 0, $noreg, killed renamable $zmm0 :: (store (s512) into %ir.0, !tbaa !5)
    // operand 0 is a memory operand
    FeMem inst0_op0;
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // no index/disp in LLVM, can simply use the operand address
        inst0_op0 = FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp);
    } else {
        // di maps to operand param_0
        AsmReg base = param_0.as_reg(this);
        inst0_op0 = FE_MEM(base, 0, FE_NOREG, 0);
    }
    // operand 1 is xmm0
    // xmm0 is mapped to param_1
    AsmReg inst0_op1 = param_1.as_reg(this);

    ASMD(VMOVAPS512mr, inst0_op0, inst0_op1);
    // argument di is killed and marked as dead
    // argument xmm0 is killed and marked as dead


    // VZEROUPPER implicit-def dead $ymm0, implicit-def dead $ymm1, implicit-def dead $ymm2, implicit-def dead $ymm3, implicit-def dead $ymm4, implicit-def dead $ymm5, implicit-def dead $ymm6, implicit-def dead $ymm7, implicit-def dead $ymm8, implicit-def dead $ymm9, implicit-def dead $ymm10, implicit-def dead $ymm11, implicit-def dead $ymm12, implicit-def dead $ymm13, implicit-def dead $ymm14, implicit-def dead $ymm15
    // Skipping


    // RET64
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_addi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function addi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   renamable $esi = KILL killed $esi, implicit-def $rsi
    //   renamable $edi = KILL killed $edi, implicit-def $rdi
    //   renamable $eax = LEA64_32r killed renamable $rdi, 1, killed renamable $rsi, 0, $noreg
    //   RET64 killed $eax
    // 
    // # End machine code for function addi32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // renamable $esi = KILL killed $esi, implicit-def $rsi
    // KILL is a no-op


    // renamable $edi = KILL killed $edi, implicit-def $rdi
    // KILL is a no-op


    // renamable $eax = LEA64_32r killed renamable $rdi, 1, killed renamable $rsi, 0, $noreg
    // operand 1 is a memory operand
    FeMem inst2_op1;
    ScratchReg inst2_op1_scratch{derived()};
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // LLVM memory operand has index, need to materialize the addr
        AsmReg base_tmp = inst2_op1_scratch.alloc_from_bank(0);
        ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
        // gather the LLVM memory operand index si
        // si maps to operand param_1
        AsmReg index_tmp = param_1.as_reg(this);
        inst2_op1 = FE_MEM(base_tmp, 1, index_tmp, 0);
    } else {
        // di maps to operand param_0
        AsmReg base;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            base = scratch_ax.cur_reg;
        } else {
            base = param_0.as_reg(this);
        }
        // LLVM memory operand has index reg si
        // si maps to operand param_1
        if (param_1.encodeable_as_imm32_sext()) {
            inst2_op1 = FE_MEM(base, 0, FE_NOREG, 1 * (i32)param_1.imm().const_u64 + 0);
        } else {
            AsmReg index_tmp = param_1.as_reg(this);
            inst2_op1 = FE_MEM(base, 1, index_tmp, 0);
        }
    }

    // def ax has not been allocated yet
    scratch_ax.alloc_from_bank(0);
    ASMD(LEA32rm, scratch_ax.cur_reg, inst2_op1);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_subi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function subi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   renamable $eax = SUB32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function subi32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // renamable $eax = SUB32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    // SUB32rr has a preferred encoding as SUB32ri if possible
    if (param_1.encodeable_as_imm32_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(SUB32ri, scratch_ax.cur_reg, imm.const_u64);
    }    // SUB32rr has a preferred encoding as SUB32rm if possible
    else if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst1_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());

        ASMD(SUB32rm, scratch_ax.cur_reg, inst1_op1);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst1_op1 = param_1.as_reg(this);

        ASMD(SUB32rr, scratch_ax.cur_reg, inst1_op1);
    }
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_muli32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function muli32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   renamable $eax = IMUL32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function muli32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // renamable $eax = IMUL32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    // IMUL32rr has a preferred encoding as IMUL32rm if possible
    if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst1_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());

        ASMD(IMUL32rm, scratch_ax.cur_reg, inst1_op1);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst1_op1 = param_1.as_reg(this);

        ASMD(IMUL32rr, scratch_ax.cur_reg, inst1_op1);
    }
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_udivi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function udivi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   DIV32r killed renamable $esi, implicit-def $eax, implicit-def dead $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
    //   RET64 killed $eax
    // 
    // # End machine code for function udivi32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    // Skipping check for XOR32ri since associated use is undefined
    // Skipping check for XOR32rm since associated use is undefined
    // operand 0 is dx
    // operand is undef, just allocating scratch for it
    // operand is tied so no work needs to be done
    // operand 1 is dx
    // operand is undef, just allocating scratch for it
    AsmReg inst1_op1 = scratch_dx.alloc_from_bank(0);


    // def dx has not been allocated yet
    scratch_dx.alloc_from_bank(0);
    ASMD(XOR32rr, scratch_dx.cur_reg, inst1_op1);
    // result dx is marked as alive


    // DIV32r killed renamable $esi, implicit-def $eax, implicit-def dead $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
    // DIV32r has a preferred encoding as DIV32m if possible
    if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst2_op0 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());
        // Handling implicit operand ax
        // Need to break alias from ax to operand param_0 and copy the value
        AsmReg inst2_op4_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, inst2_op4_tmp);
        // Handling implicit operand dx
        // Value is already in register, no need to copy

        ASMD(DIV32m, inst2_op0);
    } else {
        // operand 0 is si
        // si is mapped to param_1
        AsmReg inst2_op0 = param_1.as_reg(this);
        // Handling implicit operand ax
        // Need to break alias from ax to operand param_0 and copy the value
        AsmReg inst2_op4_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, inst2_op4_tmp);
        // Handling implicit operand dx
        // Value is already in register, no need to copy

        ASMD(DIV32r, inst2_op0);
    }
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as dead


    // RET64 killed $eax
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_sdivi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sdivi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   CDQ implicit-def $eax, implicit-def $edx, implicit killed $eax
    //   IDIV32r killed renamable $esi, implicit-def $eax, implicit-def dead $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
    //   RET64 killed $eax
    // 
    // # End machine code for function sdivi32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // CDQ implicit-def $eax, implicit-def $edx, implicit killed $eax
    // Handling implicit operand ax
    // Need to break alias from ax to operand param_0 and copy the value
    AsmReg inst1_op2_tmp = param_0.as_reg(this);
    ASMD(MOV32rr, scratch_ax.cur_reg, inst1_op2_tmp);

    ASMD(CDQ);
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // IDIV32r killed renamable $esi, implicit-def $eax, implicit-def dead $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
    // IDIV32r has a preferred encoding as IDIV32m if possible
    if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst2_op0 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());
        // Handling implicit operand ax
        // Value is already in register, no need to copy
        // Handling implicit operand dx
        // Value is already in register, no need to copy

        ASMD(IDIV32m, inst2_op0);
    } else {
        // operand 0 is si
        // si is mapped to param_1
        AsmReg inst2_op0 = param_1.as_reg(this);
        // Handling implicit operand ax
        // Value is already in register, no need to copy
        // Handling implicit operand dx
        // Value is already in register, no need to copy

        ASMD(IDIV32r, inst2_op0);
    }
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as dead


    // RET64 killed $eax
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_uremi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function uremi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    //   DIV32r killed renamable $esi, implicit-def dead $eax, implicit-def $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
    //   $eax = MOV32rr killed $edx
    //   RET64 killed $eax
    // 
    // # End machine code for function uremi32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags
    // Skipping check for XOR32ri since associated use is undefined
    // Skipping check for XOR32rm since associated use is undefined
    // operand 0 is dx
    // operand is undef, just allocating scratch for it
    // operand is tied so no work needs to be done
    // operand 1 is dx
    // operand is undef, just allocating scratch for it
    AsmReg inst1_op1 = scratch_dx.alloc_from_bank(0);


    // def dx has not been allocated yet
    scratch_dx.alloc_from_bank(0);
    ASMD(XOR32rr, scratch_dx.cur_reg, inst1_op1);
    // result dx is marked as alive


    // DIV32r killed renamable $esi, implicit-def dead $eax, implicit-def $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
    // DIV32r has a preferred encoding as DIV32m if possible
    if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst2_op0 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());
        // Handling implicit operand ax
        // Need to break alias from ax to operand param_0 and copy the value
        AsmReg inst2_op4_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, inst2_op4_tmp);
        // Handling implicit operand dx
        // Value is already in register, no need to copy

        ASMD(DIV32m, inst2_op0);
    } else {
        // operand 0 is si
        // si is mapped to param_1
        AsmReg inst2_op0 = param_1.as_reg(this);
        // Handling implicit operand ax
        // Need to break alias from ax to operand param_0 and copy the value
        AsmReg inst2_op4_tmp = param_0.as_reg(this);
        ASMD(MOV32rr, scratch_ax.cur_reg, inst2_op4_tmp);
        // Handling implicit operand dx
        // Value is already in register, no need to copy

        ASMD(DIV32r, inst2_op0);
    }
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as dead
    // result dx is marked as alive


    // $eax = MOV32rr killed $edx
    // aliasing ax to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $eax
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    // ax is an alias for dx
    result_0 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_sremi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sremi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   CDQ implicit-def $eax, implicit-def $edx, implicit killed $eax
    //   IDIV32r killed renamable $esi, implicit-def dead $eax, implicit-def $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
    //   $eax = MOV32rr killed $edx
    //   RET64 killed $eax
    // 
    // # End machine code for function sremi32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // CDQ implicit-def $eax, implicit-def $edx, implicit killed $eax
    // Handling implicit operand ax
    // Need to break alias from ax to operand param_0 and copy the value
    AsmReg inst1_op2_tmp = param_0.as_reg(this);
    ASMD(MOV32rr, scratch_ax.cur_reg, inst1_op2_tmp);

    ASMD(CDQ);
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // IDIV32r killed renamable $esi, implicit-def dead $eax, implicit-def $edx, implicit-def dead $eflags, implicit killed $eax, implicit killed $edx
    // IDIV32r has a preferred encoding as IDIV32m if possible
    if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst2_op0 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());
        // Handling implicit operand ax
        // Value is already in register, no need to copy
        // Handling implicit operand dx
        // Value is already in register, no need to copy

        ASMD(IDIV32m, inst2_op0);
    } else {
        // operand 0 is si
        // si is mapped to param_1
        AsmReg inst2_op0 = param_1.as_reg(this);
        // Handling implicit operand ax
        // Value is already in register, no need to copy
        // Handling implicit operand dx
        // Value is already in register, no need to copy

        ASMD(IDIV32r, inst2_op0);
    }
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as dead
    // result dx is marked as alive


    // $eax = MOV32rr killed $edx
    // aliasing ax to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $eax
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    // ax is an alias for dx
    result_0 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_landi32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function landi32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   renamable $eax = AND32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function landi32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // renamable $eax = AND32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    // AND32rr has a preferred encoding as AND32ri if possible
    if (param_1.encodeable_as_imm32_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(AND32ri, scratch_ax.cur_reg, imm.const_u64);
    }    // AND32rr has a preferred encoding as AND32rm if possible
    else if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst1_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());

        ASMD(AND32rm, scratch_ax.cur_reg, inst1_op1);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst1_op1 = param_1.as_reg(this);

        ASMD(AND32rr, scratch_ax.cur_reg, inst1_op1);
    }
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_lori32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function lori32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   renamable $eax = OR32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function lori32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // renamable $eax = OR32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    // OR32rr has a preferred encoding as OR32ri if possible
    if (param_1.encodeable_as_imm32_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(OR32ri, scratch_ax.cur_reg, imm.const_u64);
    }    // OR32rr has a preferred encoding as OR32rm if possible
    else if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst1_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());

        ASMD(OR32rm, scratch_ax.cur_reg, inst1_op1);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst1_op1 = param_1.as_reg(this);

        ASMD(OR32rr, scratch_ax.cur_reg, inst1_op1);
    }
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_lxori32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function lxori32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $eax = MOV32rr killed $edi
    //   renamable $eax = XOR32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    //   RET64 killed $eax
    // 
    // # End machine code for function lxori32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // renamable $eax = XOR32rr killed renamable $eax(tied-def 0), killed renamable $esi, implicit-def dead $eflags
    // XOR32rr has a preferred encoding as XOR32ri if possible
    if (param_1.encodeable_as_imm32_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(XOR32ri, scratch_ax.cur_reg, imm.const_u64);
    }    // XOR32rr has a preferred encoding as XOR32rm if possible
    else if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst1_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());

        ASMD(XOR32rm, scratch_ax.cur_reg, inst1_op1);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst1_op1 = param_1.as_reg(this);

        ASMD(XOR32rr, scratch_ax.cur_reg, inst1_op1);
    }
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_shli32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function shli32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $ecx = MOV32rr killed $esi
    //   $eax = MOV32rr killed $edi
    //   $cl = KILL killed renamable $cl, implicit killed $ecx
    //   renamable $eax = SHL32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $eax
    // 
    // # End machine code for function shli32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if (((!param_1.encodeable_as_imm8_sext()))) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $ecx = MOV32rr killed $esi
    // aliasing cx to si
    // source si is killed, all aliases redirected and marked as dead


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // $cl = KILL killed renamable $cl, implicit killed $ecx
    // KILL is a no-op


    // renamable $eax = SHL32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    // SHL32rr has a preferred encoding as SHL32ri if possible
    if (param_1.encodeable_as_imm8_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(SHL32ri, scratch_ax.cur_reg, imm.const_u64);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is cx
        // cx is mapped to param_1
        // cx is an implicit operand, cannot salvage
        AsmReg inst3_op1_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst3_op1_tmp);

        ASMD(SHL32rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
    }
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_shri32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function shri32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $ecx = MOV32rr killed $esi
    //   $eax = MOV32rr killed $edi
    //   $cl = KILL killed renamable $cl, implicit killed $ecx
    //   renamable $eax = SHR32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $eax
    // 
    // # End machine code for function shri32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if (((!param_1.encodeable_as_imm8_sext()))) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $ecx = MOV32rr killed $esi
    // aliasing cx to si
    // source si is killed, all aliases redirected and marked as dead


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // $cl = KILL killed renamable $cl, implicit killed $ecx
    // KILL is a no-op


    // renamable $eax = SHR32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    // SHR32rr has a preferred encoding as SHR32ri if possible
    if (param_1.encodeable_as_imm8_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(SHR32ri, scratch_ax.cur_reg, imm.const_u64);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is cx
        // cx is mapped to param_1
        // cx is an implicit operand, cannot salvage
        AsmReg inst3_op1_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst3_op1_tmp);

        ASMD(SHR32rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
    }
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_ashri32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function ashri32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $ecx = MOV32rr killed $esi
    //   $eax = MOV32rr killed $edi
    //   $cl = KILL killed renamable $cl, implicit killed $ecx
    //   renamable $eax = SAR32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $eax
    // 
    // # End machine code for function ashri32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if (((!param_1.encodeable_as_imm8_sext()))) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $ecx = MOV32rr killed $esi
    // aliasing cx to si
    // source si is killed, all aliases redirected and marked as dead


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // $cl = KILL killed renamable $cl, implicit killed $ecx
    // KILL is a no-op


    // renamable $eax = SAR32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    // SAR32rr has a preferred encoding as SAR32ri if possible
    if (param_1.encodeable_as_imm8_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(SAR32ri, scratch_ax.cur_reg, imm.const_u64);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is cx
        // cx is mapped to param_1
        // cx is an implicit operand, cannot salvage
        AsmReg inst3_op1_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst3_op1_tmp);

        ASMD(SAR32rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
    }
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_addi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function addi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   renamable $rax = LEA64r killed renamable $rdi, 1, killed renamable $rsi, 0, $noreg
    //   RET64 killed $rax
    // 
    // # End machine code for function addi64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // renamable $rax = LEA64r killed renamable $rdi, 1, killed renamable $rsi, 0, $noreg
    // operand 1 is a memory operand
    FeMem inst0_op1;
    ScratchReg inst0_op1_scratch{derived()};
    // looking at base di
    // di maps to param_0, so could be an address
    if (param_0.is_addr()) {
        const auto& addr = param_0.addr();
        // LLVM memory operand has index, need to materialize the addr
        AsmReg base_tmp = inst0_op1_scratch.alloc_from_bank(0);
        ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
        // gather the LLVM memory operand index si
        // si maps to operand param_1
        AsmReg index_tmp = param_1.as_reg(this);
        inst0_op1 = FE_MEM(base_tmp, 1, index_tmp, 0);
    } else {
        // di maps to operand param_0
        AsmReg base;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            base = scratch_ax.cur_reg;
        } else {
            base = param_0.as_reg(this);
        }
        // LLVM memory operand has index reg si
        // si maps to operand param_1
        if (param_1.encodeable_as_imm32_sext()) {
            inst0_op1 = FE_MEM(base, 0, FE_NOREG, 1 * (i32)param_1.imm().const_u64 + 0);
        } else {
            AsmReg index_tmp = param_1.as_reg(this);
            inst0_op1 = FE_MEM(base, 1, index_tmp, 0);
        }
    }

    // def ax has not been allocated yet
    scratch_ax.alloc_from_bank(0);
    ASMD(LEA64rm, scratch_ax.cur_reg, inst0_op1);
    // argument di is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_subi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function subi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = SUB64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function subi64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = SUB64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    // SUB64rr has a preferred encoding as SUB64ri if possible
    if (param_1.encodeable_as_imm32_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(SUB64ri, scratch_ax.cur_reg, imm.const_u64);
    }    // SUB64rr has a preferred encoding as SUB64rm if possible
    else if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst1_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());

        ASMD(SUB64rm, scratch_ax.cur_reg, inst1_op1);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst1_op1 = param_1.as_reg(this);

        ASMD(SUB64rr, scratch_ax.cur_reg, inst1_op1);
    }
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_muli64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function muli64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = IMUL64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function muli64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = IMUL64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    // IMUL64rr has a preferred encoding as IMUL64rm if possible
    if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst1_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());

        ASMD(IMUL64rm, scratch_ax.cur_reg, inst1_op1);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst1_op1 = param_1.as_reg(this);

        ASMD(IMUL64rr, scratch_ax.cur_reg, inst1_op1);
    }
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_udivi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function udivi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags, implicit-def $rdx
    //   DIV64r killed renamable $rsi, implicit-def $rax, implicit-def dead $rdx, implicit-def dead $eflags, implicit killed $rax, implicit killed $rdx
    //   RET64 killed $rax
    // 
    // # End machine code for function udivi64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags, implicit-def $rdx
    // Skipping check for XOR32ri since associated use is undefined
    // Skipping check for XOR32rm since associated use is undefined
    // operand 0 is dx
    // operand is undef, just allocating scratch for it
    // operand is tied so no work needs to be done
    // operand 1 is dx
    // operand is undef, just allocating scratch for it
    AsmReg inst1_op1 = scratch_dx.alloc_from_bank(0);


    // def dx has not been allocated yet
    scratch_dx.alloc_from_bank(0);
    // Ignoring implicit def RDX as it exceeds the number of implicit defs in the MCInstrDesc
    ASMD(XOR32rr, scratch_dx.cur_reg, inst1_op1);
    // result dx is marked as alive
    // result dx is marked as alive


    // DIV64r killed renamable $rsi, implicit-def $rax, implicit-def dead $rdx, implicit-def dead $eflags, implicit killed $rax, implicit killed $rdx
    // DIV64r has a preferred encoding as DIV64m if possible
    if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst2_op0 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());
        // Handling implicit operand ax
        // Need to break alias from ax to operand param_0 and copy the value
        AsmReg inst2_op4_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, inst2_op4_tmp);
        // Handling implicit operand dx
        // Value is already in register, no need to copy

        ASMD(DIV64m, inst2_op0);
    } else {
        // operand 0 is si
        // si is mapped to param_1
        AsmReg inst2_op0 = param_1.as_reg(this);
        // Handling implicit operand ax
        // Need to break alias from ax to operand param_0 and copy the value
        AsmReg inst2_op4_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, inst2_op4_tmp);
        // Handling implicit operand dx
        // Value is already in register, no need to copy

        ASMD(DIV64r, inst2_op0);
    }
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as dead


    // RET64 killed $rax
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_sdivi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sdivi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   CQO implicit-def $rax, implicit-def $rdx, implicit killed $rax
    //   IDIV64r killed renamable $rsi, implicit-def $rax, implicit-def dead $rdx, implicit-def dead $eflags, implicit killed $rax, implicit killed $rdx
    //   RET64 killed $rax
    // 
    // # End machine code for function sdivi64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // CQO implicit-def $rax, implicit-def $rdx, implicit killed $rax
    // Handling implicit operand ax
    // Need to break alias from ax to operand param_0 and copy the value
    AsmReg inst1_op2_tmp = param_0.as_reg(this);
    ASMD(MOV64rr, scratch_ax.cur_reg, inst1_op2_tmp);

    ASMD(CQO);
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // IDIV64r killed renamable $rsi, implicit-def $rax, implicit-def dead $rdx, implicit-def dead $eflags, implicit killed $rax, implicit killed $rdx
    // IDIV64r has a preferred encoding as IDIV64m if possible
    if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst2_op0 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());
        // Handling implicit operand ax
        // Value is already in register, no need to copy
        // Handling implicit operand dx
        // Value is already in register, no need to copy

        ASMD(IDIV64m, inst2_op0);
    } else {
        // operand 0 is si
        // si is mapped to param_1
        AsmReg inst2_op0 = param_1.as_reg(this);
        // Handling implicit operand ax
        // Value is already in register, no need to copy
        // Handling implicit operand dx
        // Value is already in register, no need to copy

        ASMD(IDIV64r, inst2_op0);
    }
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as dead


    // RET64 killed $rax
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_uremi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function uremi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags, implicit-def $rdx
    //   DIV64r killed renamable $rsi, implicit-def dead $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax, implicit killed $rdx
    //   $rax = MOV64rr killed $rdx
    //   RET64 killed $rax
    // 
    // # End machine code for function uremi64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags, implicit-def $rdx
    // Skipping check for XOR32ri since associated use is undefined
    // Skipping check for XOR32rm since associated use is undefined
    // operand 0 is dx
    // operand is undef, just allocating scratch for it
    // operand is tied so no work needs to be done
    // operand 1 is dx
    // operand is undef, just allocating scratch for it
    AsmReg inst1_op1 = scratch_dx.alloc_from_bank(0);


    // def dx has not been allocated yet
    scratch_dx.alloc_from_bank(0);
    // Ignoring implicit def RDX as it exceeds the number of implicit defs in the MCInstrDesc
    ASMD(XOR32rr, scratch_dx.cur_reg, inst1_op1);
    // result dx is marked as alive
    // result dx is marked as alive


    // DIV64r killed renamable $rsi, implicit-def dead $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax, implicit killed $rdx
    // DIV64r has a preferred encoding as DIV64m if possible
    if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst2_op0 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());
        // Handling implicit operand ax
        // Need to break alias from ax to operand param_0 and copy the value
        AsmReg inst2_op4_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, inst2_op4_tmp);
        // Handling implicit operand dx
        // Value is already in register, no need to copy

        ASMD(DIV64m, inst2_op0);
    } else {
        // operand 0 is si
        // si is mapped to param_1
        AsmReg inst2_op0 = param_1.as_reg(this);
        // Handling implicit operand ax
        // Need to break alias from ax to operand param_0 and copy the value
        AsmReg inst2_op4_tmp = param_0.as_reg(this);
        ASMD(MOV64rr, scratch_ax.cur_reg, inst2_op4_tmp);
        // Handling implicit operand dx
        // Value is already in register, no need to copy

        ASMD(DIV64r, inst2_op0);
    }
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as dead
    // result dx is marked as alive


    // $rax = MOV64rr killed $rdx
    // aliasing ax to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $rax
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    // ax is an alias for dx
    result_0 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_sremi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sremi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   CQO implicit-def $rax, implicit-def $rdx, implicit killed $rax
    //   IDIV64r killed renamable $rsi, implicit-def dead $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax, implicit killed $rdx
    //   $rax = MOV64rr killed $rdx
    //   RET64 killed $rax
    // 
    // # End machine code for function sremi64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1}, reg_backup_dx);


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // CQO implicit-def $rax, implicit-def $rdx, implicit killed $rax
    // Handling implicit operand ax
    // Need to break alias from ax to operand param_0 and copy the value
    AsmReg inst1_op2_tmp = param_0.as_reg(this);
    ASMD(MOV64rr, scratch_ax.cur_reg, inst1_op2_tmp);

    ASMD(CQO);
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // IDIV64r killed renamable $rsi, implicit-def dead $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax, implicit killed $rdx
    // IDIV64r has a preferred encoding as IDIV64m if possible
    if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst2_op0 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());
        // Handling implicit operand ax
        // Value is already in register, no need to copy
        // Handling implicit operand dx
        // Value is already in register, no need to copy

        ASMD(IDIV64m, inst2_op0);
    } else {
        // operand 0 is si
        // si is mapped to param_1
        AsmReg inst2_op0 = param_1.as_reg(this);
        // Handling implicit operand ax
        // Value is already in register, no need to copy
        // Handling implicit operand dx
        // Value is already in register, no need to copy

        ASMD(IDIV64r, inst2_op0);
    }
    // argument si is killed and marked as dead
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as dead
    // result dx is marked as alive


    // $rax = MOV64rr killed $rdx
    // aliasing ax to dx
    // source dx is killed, all aliases redirected and marked as dead


    // RET64 killed $rax
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, false);
    // returning reg ax as result_0
    // ax is an alias for dx
    result_0 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_landi64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function landi64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = AND64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function landi64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = AND64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    // AND64rr has a preferred encoding as AND64ri if possible
    if (param_1.encodeable_as_imm32_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(AND64ri, scratch_ax.cur_reg, imm.const_u64);
    }    // AND64rr has a preferred encoding as AND64rm if possible
    else if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst1_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());

        ASMD(AND64rm, scratch_ax.cur_reg, inst1_op1);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst1_op1 = param_1.as_reg(this);

        ASMD(AND64rr, scratch_ax.cur_reg, inst1_op1);
    }
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_lori64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function lori64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function lori64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    // OR64rr has a preferred encoding as OR64ri if possible
    if (param_1.encodeable_as_imm32_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(OR64ri, scratch_ax.cur_reg, imm.const_u64);
    }    // OR64rr has a preferred encoding as OR64rm if possible
    else if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst1_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());

        ASMD(OR64rm, scratch_ax.cur_reg, inst1_op1);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst1_op1 = param_1.as_reg(this);

        ASMD(OR64rr, scratch_ax.cur_reg, inst1_op1);
    }
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_lxori64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function lxori64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = XOR64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    //   RET64 killed $rax
    // 
    // # End machine code for function lxori64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = XOR64rr killed renamable $rax(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    // XOR64rr has a preferred encoding as XOR64ri if possible
    if (param_1.encodeable_as_imm32_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(XOR64ri, scratch_ax.cur_reg, imm.const_u64);
    }    // XOR64rr has a preferred encoding as XOR64rm if possible
    else if (param_1.val_ref_prefers_mem_enc()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is a memory operand
        // si is base for memory operand to use
        // si maps to operand param_1 which is known to be a ValuePartRef
        FeMem inst1_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_1.val_ref_frame_off());

        ASMD(XOR64rm, scratch_ax.cur_reg, inst1_op1);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is si
        // si is mapped to param_1
        AsmReg inst1_op1 = param_1.as_reg(this);

        ASMD(XOR64rr, scratch_ax.cur_reg, inst1_op1);
    }
    // argument ax is killed and marked as dead
    // argument si is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_shli64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function shli64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rcx = MOV64rr killed $rsi
    //   $rax = MOV64rr killed $rdi
    //   $cl = KILL killed renamable $cl, implicit killed $rcx
    //   renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $rax
    // 
    // # End machine code for function shli64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if (((!param_1.encodeable_as_imm8_sext()))) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $rcx = MOV64rr killed $rsi
    // aliasing cx to si
    // source si is killed, all aliases redirected and marked as dead


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // $cl = KILL killed renamable $cl, implicit killed $rcx
    // KILL is a no-op


    // renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    // SHL64rr has a preferred encoding as SHL64ri if possible
    if (param_1.encodeable_as_imm8_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(SHL64ri, scratch_ax.cur_reg, imm.const_u64);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is cx
        // cx is mapped to param_1
        // cx is an implicit operand, cannot salvage
        AsmReg inst3_op1_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst3_op1_tmp);

        ASMD(SHL64rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
    }
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_shri64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function shri64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rcx = MOV64rr killed $rsi
    //   $rax = MOV64rr killed $rdi
    //   $cl = KILL killed renamable $cl, implicit killed $rcx
    //   renamable $rax = SHR64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $rax
    // 
    // # End machine code for function shri64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if (((!param_1.encodeable_as_imm8_sext()))) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $rcx = MOV64rr killed $rsi
    // aliasing cx to si
    // source si is killed, all aliases redirected and marked as dead


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // $cl = KILL killed renamable $cl, implicit killed $rcx
    // KILL is a no-op


    // renamable $rax = SHR64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    // SHR64rr has a preferred encoding as SHR64ri if possible
    if (param_1.encodeable_as_imm8_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(SHR64ri, scratch_ax.cur_reg, imm.const_u64);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is cx
        // cx is mapped to param_1
        // cx is an implicit operand, cannot salvage
        AsmReg inst3_op1_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst3_op1_tmp);

        ASMD(SHR64rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
    }
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_ashri64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function ashri64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $rdi, $rsi
    //   $rcx = MOV64rr killed $rsi
    //   $rax = MOV64rr killed $rdi
    //   $cl = KILL killed renamable $cl, implicit killed $rcx
    //   renamable $rax = SAR64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $rax
    // 
    // # End machine code for function ashri64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if (((!param_1.encodeable_as_imm8_sext()))) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $rcx = MOV64rr killed $rsi
    // aliasing cx to si
    // source si is killed, all aliases redirected and marked as dead


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // $cl = KILL killed renamable $cl, implicit killed $rcx
    // KILL is a no-op


    // renamable $rax = SAR64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    // SAR64rr has a preferred encoding as SAR64ri if possible
    if (param_1.encodeable_as_imm8_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_1.imm();

        ASMD(SAR64ri, scratch_ax.cur_reg, imm.const_u64);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is cx
        // cx is mapped to param_1
        // cx is an implicit operand, cannot salvage
        AsmReg inst3_op1_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst3_op1_tmp);

        ASMD(SAR64rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
    }
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_addi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function addi128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx, $rcx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rcx, $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def $eflags
    //   renamable $rsi = ADC64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags, implicit killed $eflags
    //   $rdx = MOV64rr killed $rsi
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function addi128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    // Mapping cx to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = ADD64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def $eflags
    // ADD64rr has a preferred encoding as ADD64ri if possible
    if (param_2.encodeable_as_imm32_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_2.imm();

        ASMD(ADD64ri, scratch_ax.cur_reg, imm.const_u64);
    }    // ADD64rr has a preferred encoding as ADD64rm if possible
    else if (param_2.val_ref_prefers_mem_enc()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is a memory operand
        // dx is base for memory operand to use
        // dx maps to operand param_2 which is known to be a ValuePartRef
        FeMem inst1_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_2.val_ref_frame_off());

        ASMD(ADD64rm, scratch_ax.cur_reg, inst1_op1);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is dx
        // dx is mapped to param_2
        AsmReg inst1_op1 = param_2.as_reg(this);

        ASMD(ADD64rr, scratch_ax.cur_reg, inst1_op1);
    }
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rsi = ADC64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags, implicit killed $eflags
    // ADC64rr has a preferred encoding as ADC64ri if possible
    if (param_3.encodeable_as_imm32_sext()) {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_3.imm();

        ASMD(ADC64ri, scratch_si.cur_reg, imm.const_u64);
    }    // ADC64rr has a preferred encoding as ADC64rm if possible
    else if (param_3.val_ref_prefers_mem_enc()) {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is a memory operand
        // cx is base for memory operand to use
        // cx maps to operand param_3 which is known to be a ValuePartRef
        FeMem inst2_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_3.val_ref_frame_off());

        ASMD(ADC64rm, scratch_si.cur_reg, inst2_op1);
    } else {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is cx
        // cx is mapped to param_3
        AsmReg inst2_op1 = param_3.as_reg(this);

        ASMD(ADC64rr, scratch_si.cur_reg, inst2_op1);
    }
    // argument si is killed and marked as dead
    // argument cx is killed and marked as dead
    // result si is marked as alive


    // $rdx = MOV64rr killed $rsi
    // aliasing dx to si
    // source si is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $rdx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    // dx is an alias for si
    result_1 = std::move(scratch_si);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_subi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function subi128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx, $rcx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rcx, $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = SUB64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def $eflags
    //   renamable $rsi = SBB64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags, implicit killed $eflags
    //   $rdx = MOV64rr killed $rsi
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function subi128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    // Mapping cx to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = SUB64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def $eflags
    // SUB64rr has a preferred encoding as SUB64ri if possible
    if (param_2.encodeable_as_imm32_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_2.imm();

        ASMD(SUB64ri, scratch_ax.cur_reg, imm.const_u64);
    }    // SUB64rr has a preferred encoding as SUB64rm if possible
    else if (param_2.val_ref_prefers_mem_enc()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is a memory operand
        // dx is base for memory operand to use
        // dx maps to operand param_2 which is known to be a ValuePartRef
        FeMem inst1_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_2.val_ref_frame_off());

        ASMD(SUB64rm, scratch_ax.cur_reg, inst1_op1);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is dx
        // dx is mapped to param_2
        AsmReg inst1_op1 = param_2.as_reg(this);

        ASMD(SUB64rr, scratch_ax.cur_reg, inst1_op1);
    }
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rsi = SBB64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags, implicit killed $eflags
    // SBB64rr has a preferred encoding as SBB64ri if possible
    if (param_3.encodeable_as_imm32_sext()) {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_3.imm();

        ASMD(SBB64ri, scratch_si.cur_reg, imm.const_u64);
    }    // SBB64rr has a preferred encoding as SBB64rm if possible
    else if (param_3.val_ref_prefers_mem_enc()) {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is a memory operand
        // cx is base for memory operand to use
        // cx maps to operand param_3 which is known to be a ValuePartRef
        FeMem inst2_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_3.val_ref_frame_off());

        ASMD(SBB64rm, scratch_si.cur_reg, inst2_op1);
    } else {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is cx
        // cx is mapped to param_3
        AsmReg inst2_op1 = param_3.as_reg(this);

        ASMD(SBB64rr, scratch_si.cur_reg, inst2_op1);
    }
    // argument si is killed and marked as dead
    // argument cx is killed and marked as dead
    // result si is marked as alive


    // $rdx = MOV64rr killed $rsi
    // aliasing dx to si
    // source si is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $rdx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    // dx is an alias for si
    result_1 = std::move(scratch_si);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_muli128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function muli128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx, $rcx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rcx, $rdi, $rdx, $rsi
    //   $rax = MOV64rr $rdx
    //   renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed $rdx, implicit-def dead $eflags
    //   MUL64r renamable $rdi, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    //   renamable $rdx = ADD64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    //   renamable $rcx = IMUL64rr killed renamable $rcx(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
    //   renamable $rdx = ADD64rr killed renamable $rdx(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function muli128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    // Mapping cx to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    FixedRegBackup reg_backup_ax = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::AX, scratch_ax, {&param_0, &param_1, &param_2, &param_3}, reg_backup_ax);
    FixedRegBackup reg_backup_dx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::DX, scratch_dx, {&param_0, &param_1, &param_2, &param_3}, reg_backup_dx);


    // $rax = MOV64rr $rdx
    // aliasing ax to dx


    // renamable $rsi = IMUL64rr killed renamable $rsi(tied-def 0), killed $rdx, implicit-def dead $eflags
    // IMUL64rr has a preferred encoding as IMUL64rm if possible
    if (param_2.val_ref_prefers_mem_enc()) {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is a memory operand
        // dx is base for memory operand to use
        // dx maps to operand param_2 which is known to be a ValuePartRef
        FeMem inst1_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_2.val_ref_frame_off());

        ASMD(IMUL64rm, scratch_si.cur_reg, inst1_op1);
    } else {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is dx
        // dx is mapped to param_2
        AsmReg inst1_op1 = param_2.as_reg(this);

        ASMD(IMUL64rr, scratch_si.cur_reg, inst1_op1);
    }
    // argument si is killed and marked as dead
    // argument dx is killed and marked as dead
    // result si is marked as alive


    // MUL64r renamable $rdi, implicit-def $rax, implicit-def $rdx, implicit-def dead $eflags, implicit killed $rax
    // MUL64r has a preferred encoding as MUL64m if possible
    if (param_0.val_ref_prefers_mem_enc()) {
        // operand 0 is a memory operand
        // di is base for memory operand to use
        // di maps to operand param_0 which is known to be a ValuePartRef
        FeMem inst2_op0 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_0.val_ref_frame_off());
        // Handling implicit operand ax
        // ax is an alias for dx
        // Need to break alias from ax to dx and copy the value
        ASMD(MOV64rr, scratch_ax.cur_reg, scratch_dx.cur_reg);

        ASMD(MUL64m, inst2_op0);
    } else {
        // operand 0 is di
        // di is mapped to param_0
        AsmReg inst2_op0 = param_0.as_reg(this);
        // Handling implicit operand ax
        // ax is an alias for dx
        // Need to break alias from ax to dx and copy the value
        ASMD(MOV64rr, scratch_ax.cur_reg, scratch_dx.cur_reg);
    // removing alias from ax to dx

        ASMD(MUL64r, inst2_op0);
    }
    // argument ax is killed and marked as dead
    // result ax is marked as alive
    // result dx is marked as alive


    // renamable $rdx = ADD64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    // operand 0 is dx
    // operand 0(dx) is the same as its tied destination
    scratch_dx.alloc_from_bank(0);
    // operand 1 is si
    // operand 1(si) is a simple register
    AsmReg inst3_op1 = scratch_si.cur_reg;

    ASMD(ADD64rr, scratch_dx.cur_reg, inst3_op1);
    // argument dx is killed and marked as dead
    // argument si is killed and marked as dead
    // result dx is marked as alive


    // renamable $rcx = IMUL64rr killed renamable $rcx(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
    // IMUL64rr has a preferred encoding as IMUL64rm if possible
    if (param_0.val_ref_prefers_mem_enc()) {
        // operand 0 is cx
        // cx is mapped to param_3
        // operand 0(param_3) is tied so try to salvage or materialize
        param_3.try_salvage_or_materialize(this, scratch_cx, 0, 8);
        // operand 1 is a memory operand
        // di is base for memory operand to use
        // di maps to operand param_0 which is known to be a ValuePartRef
        FeMem inst4_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_0.val_ref_frame_off());

        ASMD(IMUL64rm, scratch_cx.cur_reg, inst4_op1);
    } else {
        // operand 0 is cx
        // cx is mapped to param_3
        // operand 0(param_3) is tied so try to salvage or materialize
        param_3.try_salvage_or_materialize(this, scratch_cx, 0, 8);
        // operand 1 is di
        // di is mapped to param_0
        AsmReg inst4_op1 = param_0.as_reg(this);

        ASMD(IMUL64rr, scratch_cx.cur_reg, inst4_op1);
    }
    // argument cx is killed and marked as dead
    // argument di is killed and marked as dead
    // result cx is marked as alive


    // renamable $rdx = ADD64rr killed renamable $rdx(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    // operand 0 is dx
    // operand 0(dx) is the same as its tied destination
    scratch_dx.alloc_from_bank(0);
    // operand 1 is cx
    // operand 1(cx) is a simple register
    AsmReg inst5_op1 = scratch_cx.cur_reg;

    ASMD(ADD64rr, scratch_dx.cur_reg, inst5_op1);
    // argument dx is killed and marked as dead
    // argument cx is killed and marked as dead
    // result dx is marked as alive


    // RET64 killed $rax, killed $rdx
    scratch_check_fixed_backup(scratch_ax, reg_backup_ax, true);
    scratch_check_fixed_backup(scratch_dx, reg_backup_dx, true);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_landi128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function landi128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx, $rcx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rcx, $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = AND64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def dead $eflags
    //   renamable $rsi = AND64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   $rdx = MOV64rr killed $rsi
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function landi128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    // Mapping cx to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = AND64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def dead $eflags
    // AND64rr has a preferred encoding as AND64ri if possible
    if (param_2.encodeable_as_imm32_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_2.imm();

        ASMD(AND64ri, scratch_ax.cur_reg, imm.const_u64);
    }    // AND64rr has a preferred encoding as AND64rm if possible
    else if (param_2.val_ref_prefers_mem_enc()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is a memory operand
        // dx is base for memory operand to use
        // dx maps to operand param_2 which is known to be a ValuePartRef
        FeMem inst1_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_2.val_ref_frame_off());

        ASMD(AND64rm, scratch_ax.cur_reg, inst1_op1);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is dx
        // dx is mapped to param_2
        AsmReg inst1_op1 = param_2.as_reg(this);

        ASMD(AND64rr, scratch_ax.cur_reg, inst1_op1);
    }
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rsi = AND64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    // AND64rr has a preferred encoding as AND64ri if possible
    if (param_3.encodeable_as_imm32_sext()) {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_3.imm();

        ASMD(AND64ri, scratch_si.cur_reg, imm.const_u64);
    }    // AND64rr has a preferred encoding as AND64rm if possible
    else if (param_3.val_ref_prefers_mem_enc()) {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is a memory operand
        // cx is base for memory operand to use
        // cx maps to operand param_3 which is known to be a ValuePartRef
        FeMem inst2_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_3.val_ref_frame_off());

        ASMD(AND64rm, scratch_si.cur_reg, inst2_op1);
    } else {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is cx
        // cx is mapped to param_3
        AsmReg inst2_op1 = param_3.as_reg(this);

        ASMD(AND64rr, scratch_si.cur_reg, inst2_op1);
    }
    // argument si is killed and marked as dead
    // argument cx is killed and marked as dead
    // result si is marked as alive


    // $rdx = MOV64rr killed $rsi
    // aliasing dx to si
    // source si is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $rdx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    // dx is an alias for si
    result_1 = std::move(scratch_si);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_lori128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function lori128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx, $rcx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rcx, $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def dead $eflags
    //   renamable $rsi = OR64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   $rdx = MOV64rr killed $rsi
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function lori128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    // Mapping cx to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def dead $eflags
    // OR64rr has a preferred encoding as OR64ri if possible
    if (param_2.encodeable_as_imm32_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_2.imm();

        ASMD(OR64ri, scratch_ax.cur_reg, imm.const_u64);
    }    // OR64rr has a preferred encoding as OR64rm if possible
    else if (param_2.val_ref_prefers_mem_enc()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is a memory operand
        // dx is base for memory operand to use
        // dx maps to operand param_2 which is known to be a ValuePartRef
        FeMem inst1_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_2.val_ref_frame_off());

        ASMD(OR64rm, scratch_ax.cur_reg, inst1_op1);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is dx
        // dx is mapped to param_2
        AsmReg inst1_op1 = param_2.as_reg(this);

        ASMD(OR64rr, scratch_ax.cur_reg, inst1_op1);
    }
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rsi = OR64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    // OR64rr has a preferred encoding as OR64ri if possible
    if (param_3.encodeable_as_imm32_sext()) {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_3.imm();

        ASMD(OR64ri, scratch_si.cur_reg, imm.const_u64);
    }    // OR64rr has a preferred encoding as OR64rm if possible
    else if (param_3.val_ref_prefers_mem_enc()) {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is a memory operand
        // cx is base for memory operand to use
        // cx maps to operand param_3 which is known to be a ValuePartRef
        FeMem inst2_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_3.val_ref_frame_off());

        ASMD(OR64rm, scratch_si.cur_reg, inst2_op1);
    } else {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is cx
        // cx is mapped to param_3
        AsmReg inst2_op1 = param_3.as_reg(this);

        ASMD(OR64rr, scratch_si.cur_reg, inst2_op1);
    }
    // argument si is killed and marked as dead
    // argument cx is killed and marked as dead
    // result si is marked as alive


    // $rdx = MOV64rr killed $rsi
    // aliasing dx to si
    // source si is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $rdx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    // dx is an alias for si
    result_1 = std::move(scratch_si);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_lxori128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, AsmOperand param_3, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function lxori128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx, $rcx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rcx, $rdi, $rdx, $rsi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = XOR64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def dead $eflags
    //   renamable $rsi = XOR64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    //   $rdx = MOV64rr killed $rsi
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function lxori128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    // Mapping cx to param_3
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed, all aliases redirected and marked as dead


    // renamable $rax = XOR64rr killed renamable $rax(tied-def 0), killed renamable $rdx, implicit-def dead $eflags
    // XOR64rr has a preferred encoding as XOR64ri if possible
    if (param_2.encodeable_as_imm32_sext()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_2.imm();

        ASMD(XOR64ri, scratch_ax.cur_reg, imm.const_u64);
    }    // XOR64rr has a preferred encoding as XOR64rm if possible
    else if (param_2.val_ref_prefers_mem_enc()) {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is a memory operand
        // dx is base for memory operand to use
        // dx maps to operand param_2 which is known to be a ValuePartRef
        FeMem inst1_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_2.val_ref_frame_off());

        ASMD(XOR64rm, scratch_ax.cur_reg, inst1_op1);
    } else {
        // operand 0 is ax
        // ax is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is dx
        // dx is mapped to param_2
        AsmReg inst1_op1 = param_2.as_reg(this);

        ASMD(XOR64rr, scratch_ax.cur_reg, inst1_op1);
    }
    // argument ax is killed and marked as dead
    // argument dx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rsi = XOR64rr killed renamable $rsi(tied-def 0), killed renamable $rcx, implicit-def dead $eflags
    // XOR64rr has a preferred encoding as XOR64ri if possible
    if (param_3.encodeable_as_imm32_sext()) {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is an immediate operand
        const auto& imm = param_3.imm();

        ASMD(XOR64ri, scratch_si.cur_reg, imm.const_u64);
    }    // XOR64rr has a preferred encoding as XOR64rm if possible
    else if (param_3.val_ref_prefers_mem_enc()) {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is a memory operand
        // cx is base for memory operand to use
        // cx maps to operand param_3 which is known to be a ValuePartRef
        FeMem inst2_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_3.val_ref_frame_off());

        ASMD(XOR64rm, scratch_si.cur_reg, inst2_op1);
    } else {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is cx
        // cx is mapped to param_3
        AsmReg inst2_op1 = param_3.as_reg(this);

        ASMD(XOR64rr, scratch_si.cur_reg, inst2_op1);
    }
    // argument si is killed and marked as dead
    // argument cx is killed and marked as dead
    // result si is marked as alive


    // $rdx = MOV64rr killed $rsi
    // aliasing dx to si
    // source si is killed, all aliases redirected and marked as dead


    // RET64 killed $rax, killed $rdx
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    // dx is an alias for si
    result_1 = std::move(scratch_si);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_shli128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function shli128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rdi, $rdx, $rsi
    //   $r8 = MOV64rr killed $rdx
    //   $ecx = MOV32rr undef $r8d, implicit $r8b
    //   renamable $rsi = SHL64rCL killed renamable $rsi(tied-def 0), implicit-def dead $eflags, implicit $cl
    //   $rdx = MOV64rr $rdi
    //   renamable $rdx = SHR64ri killed renamable $rdx(tied-def 0), 1, implicit-def dead $eflags
    //   renamable $cl = NOT8r killed renamable $cl(tied-def 0)
    //   renamable $rdx = SHR64rCL killed renamable $rdx(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   renamable $rdx = OR64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    //   $ecx = MOV32rr undef $r8d, implicit $r8b
    //   renamable $rdi = SHL64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $rax
    //   TEST8ri killed renamable $r8b, 64, implicit-def $eflags, implicit killed $r8
    //   renamable $rdx = CMOV64rr killed renamable $rdx(tied-def 0), renamable $rdi, 5, implicit $eflags
    //   renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), killed renamable $rdi, 4, implicit killed $eflags
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function shli128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    ScratchReg scratch_r8{derived()};
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1, &param_2}, reg_backup_cx);


    // $r8 = MOV64rr killed $rdx
    // aliasing r8 to dx
    // source dx is killed, all aliases redirected and marked as dead


    // $ecx = MOV32rr undef $r8d, implicit $r8b
    // aliasing cx to r8


    // renamable $rsi = SHL64rCL killed renamable $rsi(tied-def 0), implicit-def dead $eflags, implicit $cl
    // SHL64rr has a preferred encoding as SHL64ri if possible
    if (param_2.encodeable_as_imm8_sext()) {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is an immediate operand
        // cx is an alias for r8
        const auto& imm = param_2.imm();

        ASMD(SHL64ri, scratch_si.cur_reg, imm.const_u64);
    } else {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is cx
        // cx is an alias for r8
        // r8 is mapped to param_2
        // cx is an implicit operand, cannot salvage
        AsmReg inst2_op1_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst2_op1_tmp);

        ASMD(SHL64rr, scratch_si.cur_reg, scratch_cx.cur_reg);
    }
    // argument si is killed and marked as dead
    // result si is marked as alive


    // $rdx = MOV64rr $rdi
    // aliasing dx to di


    // renamable $rdx = SHR64ri killed renamable $rdx(tied-def 0), 1, implicit-def dead $eflags
    // operand 0 is dx
    // dx is an alias for di
    // di is mapped to param_0
    AsmReg inst4_op0 = scratch_dx.alloc_from_bank(0);
    AsmReg inst4_op0_tmp = param_0.as_reg(this);
    ASMD(MOV64rr, inst4_op0, inst4_op0_tmp);
    // operand 1 is an immediate operand

    ASMD(SHR64ri, scratch_dx.cur_reg, 1);
    // argument dx is killed and marked as dead
    // removing alias from dx to di
    // result dx is marked as alive


    // renamable $cl = NOT8r killed renamable $cl(tied-def 0)
    // operand 0 is cx
    // cx is an alias for r8
    // r8 is mapped to param_2
    AsmReg inst5_op0 = scratch_cx.alloc_from_bank(0);
    AsmReg inst5_op0_tmp = param_2.as_reg(this);
    ASMD(MOV32rr, inst5_op0, inst5_op0_tmp);

    ASMD(NOT8r, scratch_cx.cur_reg);
    // argument cx is killed and marked as dead
    // removing alias from cx to r8
    // result cx is marked as alive


    // renamable $rdx = SHR64rCL killed renamable $rdx(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    // operand 0 is dx
    // operand 0(dx) is the same as its tied destination
    scratch_dx.alloc_from_bank(0);
    // operand 1 is cx
    // operand 1(cx) is a simple register
    AsmReg inst6_op1 = scratch_cx.cur_reg;

    ASMD(SHR64rr, scratch_dx.cur_reg, inst6_op1);
    // argument dx is killed and marked as dead
    // argument cx is killed and marked as dead
    // result dx is marked as alive


    // renamable $rdx = OR64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, implicit-def dead $eflags
    // operand 0 is dx
    // operand 0(dx) is the same as its tied destination
    scratch_dx.alloc_from_bank(0);
    // operand 1 is si
    // operand 1(si) is a simple register
    AsmReg inst7_op1 = scratch_si.cur_reg;

    ASMD(OR64rr, scratch_dx.cur_reg, inst7_op1);
    // argument dx is killed and marked as dead
    // argument si is killed and marked as dead
    // result dx is marked as alive


    // $ecx = MOV32rr undef $r8d, implicit $r8b
    // aliasing cx to r8


    // renamable $rdi = SHL64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    // SHL64rr has a preferred encoding as SHL64ri if possible
    if (param_2.encodeable_as_imm8_sext()) {
        // operand 0 is di
        // di is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        // operand 1 is an immediate operand
        // cx is an alias for r8
        const auto& imm = param_2.imm();

        ASMD(SHL64ri, scratch_di.cur_reg, imm.const_u64);
    } else {
        // operand 0 is di
        // di is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        // operand 1 is cx
        // cx is an alias for r8
        // r8 is mapped to param_2
        // cx is an implicit operand, cannot salvage
        AsmReg inst9_op1_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst9_op1_tmp);

        ASMD(SHL64rr, scratch_di.cur_reg, scratch_cx.cur_reg);
    }
    // argument di is killed and marked as dead
    // argument cx is killed and marked as dead
    // removing alias from cx to r8
    // result di is marked as alive


    // renamable $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, implicit-def $rax
    // Skipping check for XOR32ri since associated use is undefined
    // Skipping check for XOR32rm since associated use is undefined
    // operand 0 is ax
    // operand is undef, just allocating scratch for it
    // operand is tied so no work needs to be done
    // operand 1 is ax
    // operand is undef, just allocating scratch for it
    AsmReg inst10_op1 = scratch_ax.alloc_from_bank(0);


    // def ax has not been allocated yet
    scratch_ax.alloc_from_bank(0);
    // Ignoring implicit def RAX as it exceeds the number of implicit defs in the MCInstrDesc
    ASMD(XOR32rr, scratch_ax.cur_reg, inst10_op1);
    // result ax is marked as alive
    // result ax is marked as alive


    // TEST8ri killed renamable $r8b, 64, implicit-def $eflags, implicit killed $r8
    // TEST8ri has a preferred encoding as TEST8mi if possible
    if (param_2.val_ref_prefers_mem_enc()) {
        // operand 0 is a memory operand
        // r8 is base for memory operand to use
        // r8 maps to operand param_2 which is known to be a ValuePartRef
        FeMem inst11_op0 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_2.val_ref_frame_off());
        // operand 1 is an immediate operand
        // Handling implicit operand r8
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        ASMD(TEST8mi, inst11_op0, 64);
    } else {
        // operand 0 is r8
        // r8 is mapped to param_2
        AsmReg inst11_op0 = param_2.as_reg(this);
        // operand 1 is an immediate operand
        // Handling implicit operand r8
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        ASMD(TEST8ri, inst11_op0, 64);
    }
    // argument r8 is killed and marked as dead
    // argument r8 is killed and marked as dead


    // renamable $rdx = CMOV64rr killed renamable $rdx(tied-def 0), renamable $rdi, 5, implicit $eflags
    // operand 0 is dx
    // operand 0(dx) is the same as its tied destination
    scratch_dx.alloc_from_bank(0);
    // operand 1 is di
    // operand 1(di) is a simple register
    AsmReg inst12_op1 = scratch_di.cur_reg;

    ASMD(CMOVNZ64rr, scratch_dx.cur_reg, inst12_op1);
    // argument dx is killed and marked as dead
    // result dx is marked as alive


    // renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), killed renamable $rdi, 4, implicit killed $eflags
    // operand 0 is ax
    // operand 0(ax) is the same as its tied destination
    scratch_ax.alloc_from_bank(0);
    // operand 1 is di
    // operand 1(di) is a simple register
    AsmReg inst13_op1 = scratch_di.cur_reg;

    ASMD(CMOVZ64rr, scratch_ax.cur_reg, inst13_op1);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax, killed $rdx
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_shri128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function shri128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rdi, $rdx, $rsi
    //   $r8 = MOV64rr killed $rdx
    //   $ecx = MOV32rr undef $r8d, implicit $r8b
    //   renamable $rdi = SHR64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit $cl
    //   renamable $rax = LEA64r renamable $rsi, 1, renamable $rsi, 0, $noreg
    //   renamable $cl = NOT8r killed renamable $cl(tied-def 0)
    //   renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
    //   $ecx = MOV32rr undef $r8d, implicit $r8b
    //   renamable $rsi = SHR64rCL killed renamable $rsi(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags, implicit-def $rdx
    //   TEST8ri killed renamable $r8b, 64, implicit-def $eflags, implicit killed $r8
    //   renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), renamable $rsi, 5, implicit $eflags
    //   renamable $rdx = CMOV64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, 4, implicit killed $eflags
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function shri128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    ScratchReg scratch_r8{derived()};
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1, &param_2}, reg_backup_cx);


    // $r8 = MOV64rr killed $rdx
    // aliasing r8 to dx
    // source dx is killed, all aliases redirected and marked as dead


    // $ecx = MOV32rr undef $r8d, implicit $r8b
    // aliasing cx to r8


    // renamable $rdi = SHR64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit $cl
    // SHR64rr has a preferred encoding as SHR64ri if possible
    if (param_2.encodeable_as_imm8_sext()) {
        // operand 0 is di
        // di is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        // operand 1 is an immediate operand
        // cx is an alias for r8
        const auto& imm = param_2.imm();

        ASMD(SHR64ri, scratch_di.cur_reg, imm.const_u64);
    } else {
        // operand 0 is di
        // di is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        // operand 1 is cx
        // cx is an alias for r8
        // r8 is mapped to param_2
        // cx is an implicit operand, cannot salvage
        AsmReg inst2_op1_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst2_op1_tmp);

        ASMD(SHR64rr, scratch_di.cur_reg, scratch_cx.cur_reg);
    }
    // argument di is killed and marked as dead
    // result di is marked as alive


    // renamable $rax = LEA64r renamable $rsi, 1, renamable $rsi, 0, $noreg
    // operand 1 is a memory operand
    FeMem inst3_op1;
    ScratchReg inst3_op1_scratch{derived()};
    // looking at base si
    // si maps to param_1, so could be an address
    if (param_1.is_addr()) {
        const auto& addr = param_1.addr();
        // LLVM memory operand has index, need to materialize the addr
        AsmReg base_tmp = inst3_op1_scratch.alloc_from_bank(0);
        ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
        // gather the LLVM memory operand index si
        // si maps to operand param_1
        AsmReg index_tmp = param_1.as_reg(this);
        inst3_op1 = FE_MEM(base_tmp, 1, index_tmp, 0);
    } else {
        // si maps to operand param_1
        AsmReg base = param_1.as_reg(this);
        // LLVM memory operand has index reg si
        // si maps to operand param_1
        if (param_1.encodeable_as_imm32_sext()) {
            inst3_op1 = FE_MEM(base, 0, FE_NOREG, 1 * (i32)param_1.imm().const_u64 + 0);
        } else {
            AsmReg index_tmp = param_1.as_reg(this);
            inst3_op1 = FE_MEM(base, 1, index_tmp, 0);
        }
    }

    // def ax has not been allocated yet
    scratch_ax.alloc_from_bank(0);
    ASMD(LEA64rm, scratch_ax.cur_reg, inst3_op1);
    // result ax is marked as alive


    // renamable $cl = NOT8r killed renamable $cl(tied-def 0)
    // operand 0 is cx
    // cx is an alias for r8
    // r8 is mapped to param_2
    AsmReg inst4_op0 = scratch_cx.alloc_from_bank(0);
    AsmReg inst4_op0_tmp = param_2.as_reg(this);
    ASMD(MOV32rr, inst4_op0, inst4_op0_tmp);

    ASMD(NOT8r, scratch_cx.cur_reg);
    // argument cx is killed and marked as dead
    // removing alias from cx to r8
    // result cx is marked as alive


    // renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    // operand 0 is ax
    // operand 0(ax) is the same as its tied destination
    scratch_ax.alloc_from_bank(0);
    // operand 1 is cx
    // operand 1(cx) is a simple register
    AsmReg inst5_op1 = scratch_cx.cur_reg;

    ASMD(SHL64rr, scratch_ax.cur_reg, inst5_op1);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
    // operand 0 is ax
    // operand 0(ax) is the same as its tied destination
    scratch_ax.alloc_from_bank(0);
    // operand 1 is di
    // operand 1(di) is a simple register
    AsmReg inst6_op1 = scratch_di.cur_reg;

    ASMD(OR64rr, scratch_ax.cur_reg, inst6_op1);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // $ecx = MOV32rr undef $r8d, implicit $r8b
    // aliasing cx to r8


    // renamable $rsi = SHR64rCL killed renamable $rsi(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    // SHR64rr has a preferred encoding as SHR64ri if possible
    if (param_2.encodeable_as_imm8_sext()) {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is an immediate operand
        // cx is an alias for r8
        const auto& imm = param_2.imm();

        ASMD(SHR64ri, scratch_si.cur_reg, imm.const_u64);
    } else {
        // operand 0 is si
        // si is mapped to param_1
        // operand 0(param_1) is tied so try to salvage or materialize
        param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
        // operand 1 is cx
        // cx is an alias for r8
        // r8 is mapped to param_2
        // cx is an implicit operand, cannot salvage
        AsmReg inst8_op1_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst8_op1_tmp);

        ASMD(SHR64rr, scratch_si.cur_reg, scratch_cx.cur_reg);
    }
    // argument si is killed and marked as dead
    // argument cx is killed and marked as dead
    // removing alias from cx to r8
    // result si is marked as alive


    // renamable $edx = XOR32rr undef $edx(tied-def 0), undef $edx, implicit-def dead $eflags, implicit-def $rdx
    // Skipping check for XOR32ri since associated use is undefined
    // Skipping check for XOR32rm since associated use is undefined
    // operand 0 is dx
    // operand is undef, just allocating scratch for it
    // operand is tied so no work needs to be done
    // operand 1 is dx
    // operand is undef, just allocating scratch for it
    AsmReg inst9_op1 = scratch_dx.alloc_from_bank(0);


    // def dx has not been allocated yet
    scratch_dx.alloc_from_bank(0);
    // Ignoring implicit def RDX as it exceeds the number of implicit defs in the MCInstrDesc
    ASMD(XOR32rr, scratch_dx.cur_reg, inst9_op1);
    // result dx is marked as alive
    // result dx is marked as alive


    // TEST8ri killed renamable $r8b, 64, implicit-def $eflags, implicit killed $r8
    // TEST8ri has a preferred encoding as TEST8mi if possible
    if (param_2.val_ref_prefers_mem_enc()) {
        // operand 0 is a memory operand
        // r8 is base for memory operand to use
        // r8 maps to operand param_2 which is known to be a ValuePartRef
        FeMem inst10_op0 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_2.val_ref_frame_off());
        // operand 1 is an immediate operand
        // Handling implicit operand r8
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        ASMD(TEST8mi, inst10_op0, 64);
    } else {
        // operand 0 is r8
        // r8 is mapped to param_2
        AsmReg inst10_op0 = param_2.as_reg(this);
        // operand 1 is an immediate operand
        // Handling implicit operand r8
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        ASMD(TEST8ri, inst10_op0, 64);
    }
    // argument r8 is killed and marked as dead
    // argument r8 is killed and marked as dead


    // renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), renamable $rsi, 5, implicit $eflags
    // operand 0 is ax
    // operand 0(ax) is the same as its tied destination
    scratch_ax.alloc_from_bank(0);
    // operand 1 is si
    // operand 1(si) is a simple register
    AsmReg inst11_op1 = scratch_si.cur_reg;

    ASMD(CMOVNZ64rr, scratch_ax.cur_reg, inst11_op1);
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $rdx = CMOV64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, 4, implicit killed $eflags
    // operand 0 is dx
    // operand 0(dx) is the same as its tied destination
    scratch_dx.alloc_from_bank(0);
    // operand 1 is si
    // operand 1(si) is a simple register
    AsmReg inst12_op1 = scratch_si.cur_reg;

    ASMD(CMOVZ64rr, scratch_dx.cur_reg, inst12_op1);
    // argument dx is killed and marked as dead
    // argument si is killed and marked as dead
    // result dx is marked as alive


    // RET64 killed $rax, killed $rdx
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_ashri128(AsmOperand param_0, AsmOperand param_1, AsmOperand param_2, ScratchReg &result_0, ScratchReg &result_1) {
    // # Machine code for function ashri128: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $rsi, $rdx
    // 
    // bb.0 (%ir-block.4):
    //   liveins: $rdi, $rdx, $rsi
    //   $r8 = MOV64rr killed $rdx
    //   $ecx = MOV32rr undef $r8d, implicit $r8b
    //   renamable $rdi = SHR64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit $cl
    //   renamable $rax = LEA64r renamable $rsi, 1, renamable $rsi, 0, $noreg
    //   renamable $cl = NOT8r killed renamable $cl(tied-def 0)
    //   renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
    //   $rdx = MOV64rr $rsi
    //   $ecx = MOV32rr undef $r8d, implicit $r8b
    //   renamable $rdx = SAR64rCL killed renamable $rdx(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   renamable $rsi = SAR64ri killed renamable $rsi(tied-def 0), 63, implicit-def dead $eflags
    //   TEST8ri killed renamable $r8b, 64, implicit-def $eflags, implicit killed $r8
    //   renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), renamable $rdx, 5, implicit $eflags
    //   renamable $rdx = CMOV64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, 5, implicit killed $eflags
    //   RET64 killed $rax, killed $rdx
    // 
    // # End machine code for function ashri128.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    // Mapping dx to param_2
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_dx{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    ScratchReg scratch_r8{derived()};
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1, &param_2}, reg_backup_cx);


    // $r8 = MOV64rr killed $rdx
    // aliasing r8 to dx
    // source dx is killed, all aliases redirected and marked as dead


    // $ecx = MOV32rr undef $r8d, implicit $r8b
    // aliasing cx to r8


    // renamable $rdi = SHR64rCL killed renamable $rdi(tied-def 0), implicit-def dead $eflags, implicit $cl
    // SHR64rr has a preferred encoding as SHR64ri if possible
    if (param_2.encodeable_as_imm8_sext()) {
        // operand 0 is di
        // di is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        // operand 1 is an immediate operand
        // cx is an alias for r8
        const auto& imm = param_2.imm();

        ASMD(SHR64ri, scratch_di.cur_reg, imm.const_u64);
    } else {
        // operand 0 is di
        // di is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_di, 0, 8);
        // operand 1 is cx
        // cx is an alias for r8
        // r8 is mapped to param_2
        // cx is an implicit operand, cannot salvage
        AsmReg inst2_op1_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst2_op1_tmp);

        ASMD(SHR64rr, scratch_di.cur_reg, scratch_cx.cur_reg);
    }
    // argument di is killed and marked as dead
    // result di is marked as alive


    // renamable $rax = LEA64r renamable $rsi, 1, renamable $rsi, 0, $noreg
    // operand 1 is a memory operand
    FeMem inst3_op1;
    ScratchReg inst3_op1_scratch{derived()};
    // looking at base si
    // si maps to param_1, so could be an address
    if (param_1.is_addr()) {
        const auto& addr = param_1.addr();
        // LLVM memory operand has index, need to materialize the addr
        AsmReg base_tmp = inst3_op1_scratch.alloc_from_bank(0);
        ASMD(LEA64rm, base_tmp, FE_MEM(addr.base, addr.scale, addr.scale ? addr.index : FE_NOREG, addr.disp));
        // gather the LLVM memory operand index si
        // si maps to operand param_1
        AsmReg index_tmp = param_1.as_reg(this);
        inst3_op1 = FE_MEM(base_tmp, 1, index_tmp, 0);
    } else {
        // si maps to operand param_1
        AsmReg base = param_1.as_reg(this);
        // LLVM memory operand has index reg si
        // si maps to operand param_1
        if (param_1.encodeable_as_imm32_sext()) {
            inst3_op1 = FE_MEM(base, 0, FE_NOREG, 1 * (i32)param_1.imm().const_u64 + 0);
        } else {
            AsmReg index_tmp = param_1.as_reg(this);
            inst3_op1 = FE_MEM(base, 1, index_tmp, 0);
        }
    }

    // def ax has not been allocated yet
    scratch_ax.alloc_from_bank(0);
    ASMD(LEA64rm, scratch_ax.cur_reg, inst3_op1);
    // result ax is marked as alive


    // renamable $cl = NOT8r killed renamable $cl(tied-def 0)
    // operand 0 is cx
    // cx is an alias for r8
    // r8 is mapped to param_2
    AsmReg inst4_op0 = scratch_cx.alloc_from_bank(0);
    AsmReg inst4_op0_tmp = param_2.as_reg(this);
    ASMD(MOV32rr, inst4_op0, inst4_op0_tmp);

    ASMD(NOT8r, scratch_cx.cur_reg);
    // argument cx is killed and marked as dead
    // removing alias from cx to r8
    // result cx is marked as alive


    // renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    // operand 0 is ax
    // operand 0(ax) is the same as its tied destination
    scratch_ax.alloc_from_bank(0);
    // operand 1 is cx
    // operand 1(cx) is a simple register
    AsmReg inst5_op1 = scratch_cx.cur_reg;

    ASMD(SHL64rr, scratch_ax.cur_reg, inst5_op1);
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // result ax is marked as alive


    // renamable $rax = OR64rr killed renamable $rax(tied-def 0), killed renamable $rdi, implicit-def dead $eflags
    // operand 0 is ax
    // operand 0(ax) is the same as its tied destination
    scratch_ax.alloc_from_bank(0);
    // operand 1 is di
    // operand 1(di) is a simple register
    AsmReg inst6_op1 = scratch_di.cur_reg;

    ASMD(OR64rr, scratch_ax.cur_reg, inst6_op1);
    // argument ax is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // $rdx = MOV64rr $rsi
    // aliasing dx to si


    // $ecx = MOV32rr undef $r8d, implicit $r8b
    // aliasing cx to r8


    // renamable $rdx = SAR64rCL killed renamable $rdx(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    // SAR64rr has a preferred encoding as SAR64ri if possible
    if (param_2.encodeable_as_imm8_sext()) {
        // operand 0 is dx
        // dx is an alias for si
        // si is mapped to param_1
        AsmReg inst9_op0 = scratch_dx.alloc_from_bank(0);
        AsmReg inst9_op0_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, inst9_op0, inst9_op0_tmp);
        // operand 1 is an immediate operand
        // cx is an alias for r8
        const auto& imm = param_2.imm();

        ASMD(SAR64ri, scratch_dx.cur_reg, imm.const_u64);
    } else {
        // operand 0 is dx
        // dx is an alias for si
        // si is mapped to param_1
        AsmReg inst9_op0 = scratch_dx.alloc_from_bank(0);
        AsmReg inst9_op0_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, inst9_op0, inst9_op0_tmp);
        // operand 1 is cx
        // cx is an alias for r8
        // r8 is mapped to param_2
        // cx is an implicit operand, cannot salvage
        AsmReg inst9_op1_tmp = param_2.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst9_op1_tmp);

        ASMD(SAR64rr, scratch_dx.cur_reg, scratch_cx.cur_reg);
    }
    // argument dx is killed and marked as dead
    // removing alias from dx to si
    // argument cx is killed and marked as dead
    // removing alias from cx to r8
    // result dx is marked as alive


    // renamable $rsi = SAR64ri killed renamable $rsi(tied-def 0), 63, implicit-def dead $eflags
    // operand 0 is si
    // si is mapped to param_1
    // operand 0(param_1) is tied so try to salvage or materialize
    param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
    // operand 1 is an immediate operand

    ASMD(SAR64ri, scratch_si.cur_reg, 63);
    // argument si is killed and marked as dead
    // result si is marked as alive


    // TEST8ri killed renamable $r8b, 64, implicit-def $eflags, implicit killed $r8
    // TEST8ri has a preferred encoding as TEST8mi if possible
    if (param_2.val_ref_prefers_mem_enc()) {
        // operand 0 is a memory operand
        // r8 is base for memory operand to use
        // r8 maps to operand param_2 which is known to be a ValuePartRef
        FeMem inst11_op0 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_2.val_ref_frame_off());
        // operand 1 is an immediate operand
        // Handling implicit operand r8
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        ASMD(TEST8mi, inst11_op0, 64);
    } else {
        // operand 0 is r8
        // r8 is mapped to param_2
        AsmReg inst11_op0 = param_2.as_reg(this);
        // operand 1 is an immediate operand
        // Handling implicit operand r8
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        ASMD(TEST8ri, inst11_op0, 64);
    }
    // argument r8 is killed and marked as dead
    // argument r8 is killed and marked as dead


    // renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), renamable $rdx, 5, implicit $eflags
    // operand 0 is ax
    // operand 0(ax) is the same as its tied destination
    scratch_ax.alloc_from_bank(0);
    // operand 1 is dx
    // operand 1(dx) is a simple register
    AsmReg inst12_op1 = scratch_dx.cur_reg;

    ASMD(CMOVNZ64rr, scratch_ax.cur_reg, inst12_op1);
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $rdx = CMOV64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, 5, implicit killed $eflags
    // operand 0 is dx
    // operand 0(dx) is the same as its tied destination
    scratch_dx.alloc_from_bank(0);
    // operand 1 is si
    // operand 1(si) is a simple register
    AsmReg inst13_op1 = scratch_si.cur_reg;

    ASMD(CMOVNZ64rr, scratch_dx.cur_reg, inst13_op1);
    // argument dx is killed and marked as dead
    // argument si is killed and marked as dead
    // result dx is marked as alive


    // RET64 killed $rax, killed $rdx
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}
    if (param_1.encodeable_as_imm8_sext()) {
        // operand 0 is dx
        // dx is an alias for si
        // si is mapped to param_1
        AsmReg inst9_op0 = scratch_dx.alloc_from_bank(0);
        AsmReg inst9_op0_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, inst9_op0, inst9_op0_tmp);
        // operand 1 is an immediate operand
        // cx is an alias for r8
        // r8 is an alias for dx
        // dx is an alias for si
        const auto& imm = param_1.imm();

        ASMD(SAR64ri, scratch_dx.cur_reg, imm.const_u64);
    } else {
        // operand 0 is dx
        // dx is an alias for si
        // si is mapped to param_1
        AsmReg inst9_op0 = scratch_dx.alloc_from_bank(0);
        AsmReg inst9_op0_tmp = param_1.as_reg(this);
        ASMD(MOV64rr, inst9_op0, inst9_op0_tmp);
        // operand 1 is cx
        // cx is an alias for r8
        // r8 is an alias for dx
        // dx is an alias for si
        // si is mapped to param_1
        // cx is an implicit operand, cannot salvage
        AsmReg inst9_op1_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst9_op1_tmp);

        ASMD(SAR64rr, scratch_dx.cur_reg, scratch_cx.cur_reg);
    }
    // argument dx is killed and marked as dead
    // removing alias from dx to si
    // argument cx is killed and marked as dead
    // removing alias from cx to r8
    // result dx is marked as alive


    // renamable $rsi = SAR64ri killed renamable $rsi(tied-def 0), 63, implicit-def dead $eflags
    // operand 0 is si
    // si is mapped to param_1
    // operand 0(param_1) is tied so try to salvage or materialize
    param_1.try_salvage_or_materialize(this, scratch_si, 0, 8);
    // operand 1 is an immediate operand

    ASMD(SAR64ri, scratch_si.cur_reg, 63);
    // argument si is killed and marked as dead
    // result si is marked as alive


    // TEST8ri killed renamable $r8b, 64, implicit-def $eflags, implicit killed $r8
    // operand 0 is r8
    // r8 is an alias for dx
    // operand 0(dx) is a simple register
    AsmReg inst11_op0 = scratch_dx.cur_reg;
    // operand 1 is an immediate operand
    // Handling implicit operand r8
    // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

    ASMD(TEST8ri, inst11_op0, 64);
    // argument r8 is killed and marked as dead
    // removing alias from r8 to dx
    // argument r8 is killed and marked as dead


    // renamable $rax = CMOV64rr killed renamable $rax(tied-def 0), renamable $rdx, 5, implicit $eflags
    // operand 0 is ax
    // operand 0(ax) is the same as its tied destination
    scratch_ax.alloc_from_bank(0);
    // operand 1 is dx
    // operand 1(dx) is a simple register
    AsmReg inst12_op1 = scratch_dx.cur_reg;

    ASMD(CMOVNZ64rr, scratch_ax.cur_reg, inst12_op1);
    // argument ax is killed and marked as dead
    // result ax is marked as alive


    // renamable $rdx = CMOV64rr killed renamable $rdx(tied-def 0), killed renamable $rsi, 5, implicit killed $eflags
    // operand 0 is dx
    // operand 0(dx) is the same as its tied destination
    scratch_dx.alloc_from_bank(0);
    // operand 1 is si
    // operand 1(si) is a simple register
    AsmReg inst13_op1 = scratch_si.cur_reg;

    ASMD(CMOVNZ64rr, scratch_dx.cur_reg, inst13_op1);
    // argument dx is killed and marked as dead
    // argument si is killed and marked as dead
    // result dx is marked as alive


    // RET64 killed $rax, killed $rdx
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    // returning reg dx as result_1
    result_1 = std::move(scratch_dx);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_sext_8_to_32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function sext_8_to_32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVSX32rr8 killed renamable $dil, implicit killed $edi
    //   RET64 killed $eax
    // 
    // # End machine code for function sext_8_to_32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOVSX32rr8 killed renamable $dil, implicit killed $edi
    // MOVSXr32r8 has a preferred encoding as MOVSXr32m8 if possible
    if (param_0.val_ref_prefers_mem_enc()) {
        // operand 1 is a memory operand
        // di is base for memory operand to use
        // di maps to operand param_0 which is known to be a ValuePartRef
        FeMem inst0_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_0.val_ref_frame_off());
        // Handling implicit operand di
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVSXr32m8, scratch_ax.cur_reg, inst0_op1);
    } else {
        // operand 1 is di
        // di is mapped to param_0
        AsmReg inst0_op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            inst0_op1 = scratch_ax.cur_reg;
        } else {
            inst0_op1 = param_0.as_reg(this);
        }
        // Handling implicit operand di
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVSXr32r8, scratch_ax.cur_reg, inst0_op1);
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_sext_16_to_32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function sext_16_to_32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVSX32rr16 killed renamable $di, implicit killed $edi
    //   RET64 killed $eax
    // 
    // # End machine code for function sext_16_to_32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOVSX32rr16 killed renamable $di, implicit killed $edi
    // MOVSXr32r16 has a preferred encoding as MOVSXr32m16 if possible
    if (param_0.val_ref_prefers_mem_enc()) {
        // operand 1 is a memory operand
        // di is base for memory operand to use
        // di maps to operand param_0 which is known to be a ValuePartRef
        FeMem inst0_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_0.val_ref_frame_off());
        // Handling implicit operand di
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVSXr32m16, scratch_ax.cur_reg, inst0_op1);
    } else {
        // operand 1 is di
        // di is mapped to param_0
        AsmReg inst0_op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            inst0_op1 = scratch_ax.cur_reg;
        } else {
            inst0_op1 = param_0.as_reg(this);
        }
        // Handling implicit operand di
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVSXr32r16, scratch_ax.cur_reg, inst0_op1);
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_sext_32_to_64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function sext_32_to_64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $rax = MOVSX64rr32 killed renamable $edi
    //   RET64 killed $rax
    // 
    // # End machine code for function sext_32_to_64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $rax = MOVSX64rr32 killed renamable $edi
    // MOVSXr64r32 has a preferred encoding as MOVSXr64m32 if possible
    if (param_0.val_ref_prefers_mem_enc()) {
        // operand 1 is a memory operand
        // di is base for memory operand to use
        // di maps to operand param_0 which is known to be a ValuePartRef
        FeMem inst0_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_0.val_ref_frame_off());

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVSXr64m32, scratch_ax.cur_reg, inst0_op1);
    } else {
        // operand 1 is di
        // di is mapped to param_0
        AsmReg inst0_op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            inst0_op1 = scratch_ax.cur_reg;
        } else {
            inst0_op1 = param_0.as_reg(this);
        }

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVSXr64r32, scratch_ax.cur_reg, inst0_op1);
    }
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_sext_arbitrary_to_32(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sext_arbitrary_to_32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $edi, $esi
    //   $ecx = MOV32rr killed $esi
    //   $eax = MOV32rr killed $edi
    //   renamable $eax = SHL32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit $cl
    //   $cl = KILL killed renamable $cl, implicit killed $ecx
    //   renamable $eax = exact SAR32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $eax
    // 
    // # End machine code for function sext_arbitrary_to_32.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if (((!param_1.encodeable_as_imm8_sext()))) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $ecx = MOV32rr killed $esi
    // aliasing cx to si
    // source si is killed and marked as dead but not yet destroyed


    // $eax = MOV32rr killed $edi
    // aliasing ax to di
    // source di is killed and marked as dead but not yet destroyed


    // renamable $eax = SHL32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit $cl
    // SHL32rr has a preferred encoding as SHL32ri if possible
    if (param_1.encodeable_as_imm8_sext()) {
        // operand 0 is ax
        // ax is an alias for di
        // di is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is an immediate operand
        // cx is an alias for si
        const auto& imm = param_1.imm();

        ASMD(SHL32ri, scratch_ax.cur_reg, imm.const_u64);
    } else {
        // operand 0 is ax
        // ax is an alias for di
        // di is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 4);
        // operand 1 is cx
        // cx is an alias for si
        // si is mapped to param_1
        // cx is an implicit operand, cannot salvage
        AsmReg inst2_op1_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst2_op1_tmp);

        ASMD(SHL32rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
    }
    // argument ax is killed and marked as dead
    // removing alias from ax to di
    // result ax is marked as alive


    // $cl = KILL killed renamable $cl, implicit killed $ecx
    // KILL is a no-op


    // renamable $eax = exact SAR32rCL killed renamable $eax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    // SAR32rr has a preferred encoding as SAR32ri if possible
    if (param_1.encodeable_as_imm8_sext()) {
        // operand 0 is ax
        // operand 0(ax) is the same as its tied destination
        scratch_ax.alloc_from_bank(0);
        // operand 1 is an immediate operand
        // cx is an alias for si
        const auto& imm = param_1.imm();

        ASMD(SAR32ri, scratch_ax.cur_reg, imm.const_u64);
    } else {
        // operand 0 is ax
        // operand 0(ax) is the same as its tied destination
        scratch_ax.alloc_from_bank(0);
        // operand 1 is cx
        // cx is an alias for si
        // si is mapped to param_1
        // cx is an implicit operand, cannot salvage
        AsmReg inst4_op1_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst4_op1_tmp);

        ASMD(SAR32rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
    }
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // removing alias from cx to si
    // result ax is marked as alive


    // RET64 killed $eax
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_sext_arbitrary_to_64(AsmOperand param_0, AsmOperand param_1, ScratchReg &result_0) {
    // # Machine code for function sext_arbitrary_to_64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $rdi, $esi
    // 
    // bb.0 (%ir-block.2):
    //   liveins: $esi, $rdi
    //   $ecx = MOV32rr killed $esi
    //   $rax = MOV64rr killed $rdi
    //   renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit $cl
    //   $cl = KILL killed renamable $cl, implicit killed $ecx
    //   renamable $rax = exact SAR64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    //   RET64 killed $rax
    // 
    // # End machine code for function sext_arbitrary_to_64.
    // 

    // Mapping di to param_0
    // Mapping si to param_1
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};
    ScratchReg scratch_si{derived()};
    ScratchReg scratch_cx{derived()};
    FixedRegBackup reg_backup_cx = {.scratch = ScratchReg{derived()}};
    if (((!param_1.encodeable_as_imm8_sext()))) {
        scratch_alloc_specific(AsmReg::CX, scratch_cx, {&param_0, &param_1}, reg_backup_cx);
    }


    // $ecx = MOV32rr killed $esi
    // aliasing cx to si
    // source si is killed and marked as dead but not yet destroyed


    // $rax = MOV64rr killed $rdi
    // aliasing ax to di
    // source di is killed and marked as dead but not yet destroyed


    // renamable $rax = SHL64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit $cl
    // SHL64rr has a preferred encoding as SHL64ri if possible
    if (param_1.encodeable_as_imm8_sext()) {
        // operand 0 is ax
        // ax is an alias for di
        // di is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is an immediate operand
        // cx is an alias for si
        const auto& imm = param_1.imm();

        ASMD(SHL64ri, scratch_ax.cur_reg, imm.const_u64);
    } else {
        // operand 0 is ax
        // ax is an alias for di
        // di is mapped to param_0
        // operand 0(param_0) is tied so try to salvage or materialize
        param_0.try_salvage_or_materialize(this, scratch_ax, 0, 8);
        // operand 1 is cx
        // cx is an alias for si
        // si is mapped to param_1
        // cx is an implicit operand, cannot salvage
        AsmReg inst2_op1_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst2_op1_tmp);

        ASMD(SHL64rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
    }
    // argument ax is killed and marked as dead
    // removing alias from ax to di
    // result ax is marked as alive


    // $cl = KILL killed renamable $cl, implicit killed $ecx
    // KILL is a no-op


    // renamable $rax = exact SAR64rCL killed renamable $rax(tied-def 0), implicit-def dead $eflags, implicit killed $cl
    // SAR64rr has a preferred encoding as SAR64ri if possible
    if (param_1.encodeable_as_imm8_sext()) {
        // operand 0 is ax
        // operand 0(ax) is the same as its tied destination
        scratch_ax.alloc_from_bank(0);
        // operand 1 is an immediate operand
        // cx is an alias for si
        const auto& imm = param_1.imm();

        ASMD(SAR64ri, scratch_ax.cur_reg, imm.const_u64);
    } else {
        // operand 0 is ax
        // operand 0(ax) is the same as its tied destination
        scratch_ax.alloc_from_bank(0);
        // operand 1 is cx
        // cx is an alias for si
        // si is mapped to param_1
        // cx is an implicit operand, cannot salvage
        AsmReg inst4_op1_tmp = param_1.as_reg(this);
        ASMD(MOV32rr, scratch_cx.cur_reg, inst4_op1_tmp);

        ASMD(SAR64rr, scratch_ax.cur_reg, scratch_cx.cur_reg);
    }
    // argument ax is killed and marked as dead
    // argument cx is killed and marked as dead
    // removing alias from cx to si
    // result ax is marked as alive


    // RET64 killed $rax
    scratch_check_fixed_backup(scratch_cx, reg_backup_cx, false);
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_zext_8_to_32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function zext_8_to_32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVZX32rr8 killed renamable $dil, implicit killed $edi
    //   RET64 killed $eax
    // 
    // # End machine code for function zext_8_to_32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOVZX32rr8 killed renamable $dil, implicit killed $edi
    // MOVZXr32r8 has a preferred encoding as MOVZXr32m8 if possible
    if (param_0.val_ref_prefers_mem_enc()) {
        // operand 1 is a memory operand
        // di is base for memory operand to use
        // di maps to operand param_0 which is known to be a ValuePartRef
        FeMem inst0_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_0.val_ref_frame_off());
        // Handling implicit operand di
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m8, scratch_ax.cur_reg, inst0_op1);
    } else {
        // operand 1 is di
        // di is mapped to param_0
        AsmReg inst0_op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            inst0_op1 = scratch_ax.cur_reg;
        } else {
            inst0_op1 = param_0.as_reg(this);
        }
        // Handling implicit operand di
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r8, scratch_ax.cur_reg, inst0_op1);
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_zext_16_to_32(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function zext_16_to_32: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOVZX32rr16 killed renamable $di, implicit killed $edi
    //   RET64 killed $eax
    // 
    // # End machine code for function zext_16_to_32.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOVZX32rr16 killed renamable $di, implicit killed $edi
    // MOVZXr32r16 has a preferred encoding as MOVZXr32m16 if possible
    if (param_0.val_ref_prefers_mem_enc()) {
        // operand 1 is a memory operand
        // di is base for memory operand to use
        // di maps to operand param_0 which is known to be a ValuePartRef
        FeMem inst0_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_0.val_ref_frame_off());
        // Handling implicit operand di
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32m16, scratch_ax.cur_reg, inst0_op1);
    } else {
        // operand 1 is di
        // di is mapped to param_0
        AsmReg inst0_op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            inst0_op1 = scratch_ax.cur_reg;
        } else {
            inst0_op1 = param_0.as_reg(this);
        }
        // Handling implicit operand di
        // Ignoring since the number of implicit operands on the LLVM inst exceeds the number in the MCInstrDesc

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        ASMD(MOVZXr32r16, scratch_ax.cur_reg, inst0_op1);
    }
    // argument di is killed and marked as dead
    // argument di is killed and marked as dead
    // result ax is marked as alive


    // RET64 killed $eax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}

template <typename Adaptor,
          typename Derived,
          template <typename, typename, typename>
          class BaseTy>
bool EncodeCompiler<Adaptor, Derived, BaseTy>::encode_zext_32_to_64(AsmOperand param_0, ScratchReg &result_0) {
    // # Machine code for function zext_32_to_64: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
    // Function Live Ins: $edi
    // 
    // bb.0 (%ir-block.1):
    //   liveins: $edi
    //   renamable $eax = MOV32rr killed renamable $edi, implicit-def $rax
    //   RET64 killed $rax
    // 
    // # End machine code for function zext_32_to_64.
    // 

    // Mapping di to param_0
    ScratchReg scratch_ax{derived()};
    ScratchReg scratch_di{derived()};


    // renamable $eax = MOV32rr killed renamable $edi, implicit-def $rax
    // MOV32rr has a preferred encoding as MOV32ri if possible
    if (param_0.encodeable_as_imm32_sext()) {
        // operand 1 is an immediate operand
        const auto& imm = param_0.imm();

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        // Ignoring implicit def RAX as it exceeds the number of implicit defs in the MCInstrDesc
        ASMD(MOV32ri, scratch_ax.cur_reg, imm.const_u64);
    }    // MOV32rr has a preferred encoding as MOV32rm if possible
    else if (param_0.val_ref_prefers_mem_enc()) {
        // operand 1 is a memory operand
        // di is base for memory operand to use
        // di maps to operand param_0 which is known to be a ValuePartRef
        FeMem inst0_op1 = FE_MEM(FE_BP, 0, FE_NOREG, -(i32)param_0.val_ref_frame_off());

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        // Ignoring implicit def RAX as it exceeds the number of implicit defs in the MCInstrDesc
        ASMD(MOV32rm, scratch_ax.cur_reg, inst0_op1);
    } else {
        // operand 1 is di
        // di is mapped to param_0
        AsmReg inst0_op1;
        if (param_0.try_salvage_if_nonalloc(scratch_ax, 0)) {
            inst0_op1 = scratch_ax.cur_reg;
        } else {
            inst0_op1 = param_0.as_reg(this);
        }

        // def ax has not been allocated yet
        scratch_ax.alloc_from_bank(0);
        // Ignoring implicit def RAX as it exceeds the number of implicit defs in the MCInstrDesc
        ASMD(MOV32rr, scratch_ax.cur_reg, inst0_op1);
    }
    // argument di is killed and marked as dead
    // result ax is marked as alive
    // result ax is marked as alive


    // RET64 killed $rax
    // returning reg ax as result_0
    result_0 = std::move(scratch_ax);
    return true;

}



} // namespace tpde_encodegen

#undef ASMD
// SPDX-SnippetEnd
