; NOTE: Assertions have been autogenerated by utils/update_tpde_llvm_test_checks.py UTC_ARGS: --tool tpde_llvm --default-march x86-64-v2 --filter-out "int3" --version 5
; SPDX-FileCopyrightText: 2024 Tobias Schwarz <tobias.schwarz@tum.de>
;
; SPDX-License-Identifier: LicenseRef-Proprietary

; RUN: tpde_llvm %s | llvm-objdump -d -r --no-show-raw-insn --symbolize-operands --no-addresses --x86-asm-syntax=intel --section=.text --section=.rodata - | FileCheck %s -check-prefixes=X64,CHECK --enable-var-scope --dump-input always
; RUN: tpde_llvm --target=aarch64 %s | llvm-objdump -d -r --no-show-raw-insn --symbolize-operands --no-addresses - | FileCheck %s -check-prefixes=ARM64,CHECK --enable-var-scope --dump-input always


declare void @fn_void_void();
declare i32 @fn_i32_void();
declare i128 @fn_i128_void();

declare void @fn_void_i32(i32);
declare i32 @fn_i32_i32_i32(i32, i32);

declare i32 @fn_i32_i32_i128_i128_i128(i32, i128, i128, i128);

declare i32 @fn_var_arg(ptr, ...);


define void @call_void_void() {
; X64-LABEL: call_void_void>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x30
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_void_void-0x4
; X64:    add rsp, 0x30
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rbp + 0x48], dl
;
; ARM64-LABEL: call_void_void>:
; ARM64:    sub sp, sp, #0xa0
; ARM64:    stp x29, x30, [sp]
; ARM64:    mov x29, sp
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    bl 0x30 <call_void_void+0x30>
; ARM64:     R_AARCH64_CALL26 fn_void_void
; ARM64:    ldp x29, x30, [sp]
; ARM64:    add sp, sp, #0xa0
; ARM64:    ret
; ARM64:     ...
entry:
  call void @fn_void_void()
  ret void
}

define i32 @call_i32_void() {
; X64-LABEL: call_i32_void>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x30
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_i32_void-0x4
; X64:    lea eax, [rax + 0xa]
; X64:    add rsp, 0x30
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
;
; ARM64-LABEL: call_i32_void>:
; ARM64:    sub sp, sp, #0xb0
; ARM64:    stp x29, x30, [sp]
; ARM64:    mov x29, sp
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    bl 0xa0 <call_i32_void+0x30>
; ARM64:     R_AARCH64_CALL26 fn_i32_void
; ARM64:    mov x1, #0xa // =10
; ARM64:    add w1, w1, w0
; ARM64:    mov w0, w1
; ARM64:    ldp x29, x30, [sp]
; ARM64:    add sp, sp, #0xb0
; ARM64:    ret
; ARM64:     ...
entry:
  %0 = call i32 @fn_i32_void()
  %1 = add i32 %0, 10
  ret i32 %1
}

define i128 @call_i128_void() {
; X64-LABEL: call_i128_void>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x50
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_i128_void-0x4
; X64:    mov rcx, rax
; X64:    add rcx, 0xa
; X64:    adc rdx, 0x0
; X64:    mov rax, rcx
; X64:    add rsp, 0x50
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rbp + 0x48], dl
;
; ARM64-LABEL: call_i128_void>:
; ARM64:    sub sp, sp, #0xc0
; ARM64:    stp x29, x30, [sp]
; ARM64:    mov x29, sp
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    bl 0x110 <call_i128_void+0x30>
; ARM64:     R_AARCH64_CALL26 fn_i128_void
; ARM64:    mov x2, #0xa // =10
; ARM64:    adds x2, x2, x0
; ARM64:    mov w3, #0x0 // =0
; ARM64:    adc x3, x3, x1
; ARM64:    mov x0, x2
; ARM64:    mov x1, x3
; ARM64:    ldp x29, x30, [sp]
; ARM64:    add sp, sp, #0xc0
; ARM64:    ret
; ARM64:     ...
entry:
  %0 = call i128 @fn_i128_void()
  %1 = add i128 %0, 10
  ret i128 %1
}

define i32 @call_i128_void_ret_i32(i32 %0) {
; X64-LABEL: call_i128_void_ret_i32>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x50
; X64:    mov dword ptr [rbp - 0x2c], edi
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_i128_void-0x4
; X64:    mov rcx, rax
; X64:    add rcx, 0xa
; X64:    adc rdx, 0x0
; X64:    mov eax, dword ptr [rbp - 0x2c]
; X64:    add rsp, 0x50
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
;
; ARM64-LABEL: call_i128_void_ret_i32>:
; ARM64:    sub sp, sp, #0xd0
; ARM64:    stp x29, x30, [sp]
; ARM64:    mov x29, sp
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    str w0, [x29, #0xa0]
; ARM64:    bl 0x194 <call_i128_void_ret_i32+0x34>
; ARM64:     R_AARCH64_CALL26 fn_i128_void
; ARM64:    mov x2, #0xa // =10
; ARM64:    adds x2, x2, x0
; ARM64:    mov w3, #0x0 // =0
; ARM64:    adc x3, x3, x1
; ARM64:    ldr w0, [x29, #0xa0]
; ARM64:    ldp x29, x30, [sp]
; ARM64:    add sp, sp, #0xd0
; ARM64:    ret
; ARM64:     ...
entry:
  %1 = call i128 @fn_i128_void()
  %2 = add i128 %1, 10
  ret i32 %0
}

define i32 @call_void_i32(i32 %0, i32 %1) {
; X64-LABEL: call_void_i32>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x30
; X64:    mov dword ptr [rbp - 0x2c], edi
; X64:    mov edi, esi
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_void_i32-0x4
; X64:    mov eax, dword ptr [rbp - 0x2c]
; X64:    add rsp, 0x30
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rbp + 0x48], dl
;
; ARM64-LABEL: call_void_i32>:
; ARM64:    sub sp, sp, #0xb0
; ARM64:    stp x29, x30, [sp]
; ARM64:    mov x29, sp
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    str w0, [x29, #0xa0]
; ARM64:    mov w0, w1
; ARM64:    bl 0x218 <call_void_i32+0x38>
; ARM64:     R_AARCH64_CALL26 fn_void_i32
; ARM64:    ldr w0, [x29, #0xa0]
; ARM64:    ldp x29, x30, [sp]
; ARM64:    add sp, sp, #0xb0
; ARM64:    ret
; ARM64:     ...
entry:
  call void @fn_void_i32(i32 %1)
  ret i32 %0
}

define void @call_void_i32_mismatch(i32 %0, i32 %1) {
; X64-LABEL: call_void_i32_mismatch>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x30
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_void_i32-0x4
; X64:    add rsp, 0x30
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rbp + 0x48], dl
;
; ARM64-LABEL: call_void_i32_mismatch>:
; ARM64:    sub sp, sp, #0xb0
; ARM64:    stp x29, x30, [sp]
; ARM64:    mov x29, sp
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    bl 0x280 <call_void_i32_mismatch+0x30>
; ARM64:     R_AARCH64_CALL26 fn_void_i32
; ARM64:    ldp x29, x30, [sp]
; ARM64:    add sp, sp, #0xb0
; ARM64:    ret
; ARM64:     ...
entry:
  call void (i32, i32) @fn_void_i32(i32 %0, i32 %1)
  ret void
}

define i32 @call_i32_i32_i32(i32 %0, i32 %1) {
; X64-LABEL: call_i32_i32_i32>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov dword ptr [rbp - 0x2c], edi
; X64:    mov edi, esi
; X64:    mov esi, dword ptr [rbp - 0x2c]
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_i32_i32_i32-0x4
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rbp + 0x48], dl
;
; ARM64-LABEL: call_i32_i32_i32>:
; ARM64:    sub sp, sp, #0xb0
; ARM64:    stp x29, x30, [sp]
; ARM64:    mov x29, sp
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    str w0, [x29, #0xa0]
; ARM64:    mov w0, w1
; ARM64:    ldr w1, [x29, #0xa0]
; ARM64:    bl 0x2fc <call_i32_i32_i32+0x3c>
; ARM64:     R_AARCH64_CALL26 fn_i32_i32_i32
; ARM64:    ldp x29, x30, [sp]
; ARM64:    add sp, sp, #0xb0
; ARM64:    ret
; ARM64:     ...
entry:
  %2 = call i32 @fn_i32_i32_i32(i32 %1, i32 %0)
  ret i32 %2
}

define i32 @call_i32_i32_i128_i128_i128(i32 %0, i128 %1) {
; X64-LABEL: call_i32_i32_i128_i128_i128>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    sub rsp, 0x10
; X64:    mov qword ptr [rbp - 0x40], rsi
; X64:    mov qword ptr [rbp - 0x38], rdx
; X64:    mov rcx, qword ptr [rbp - 0x40]
; X64:    mov r8, qword ptr [rbp - 0x38]
; X64:    mov rax, qword ptr [rbp - 0x40]
; X64:    mov qword ptr [rsp], rax
; X64:    mov rax, qword ptr [rbp - 0x38]
; X64:    mov qword ptr [rsp + 0x8], rax
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_i32_i32_i128_i128_i128-0x4
; X64:    add rsp, 0x10
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:     ...
;
; ARM64-LABEL: call_i32_i32_i128_i128_i128>:
; ARM64:    sub sp, sp, #0xc0
; ARM64:    stp x29, x30, [sp]
; ARM64:    mov x29, sp
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    str x2, [x29, #0xb0]
; ARM64:    str x3, [x29, #0xb8]
; ARM64:    ldr x4, [x29, #0xb0]
; ARM64:    ldr x5, [x29, #0xb8]
; ARM64:    ldr x6, [x29, #0xb0]
; ARM64:    ldr x7, [x29, #0xb8]
; ARM64:    bl 0x378 <call_i32_i32_i128_i128_i128+0x48>
; ARM64:     R_AARCH64_CALL26 fn_i32_i32_i128_i128_i128
; ARM64:    ldp x29, x30, [sp]
; ARM64:    add sp, sp, #0xc0
; ARM64:    ret
; ARM64:     ...
entry:
  %2 = call i32 @fn_i32_i32_i128_i128_i128(i32 %0, i128 %1, i128 %1, i128 %1)
  ret i32 %2
}

define i32 @call_i32_vararg(ptr %0, i32 %1, i128 %2) {
; X64-LABEL: call_i32_vararg>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x50
; X64:    mov dword ptr [rbp - 0x34], esi
; X64:    mov rsi, rdx
; X64:    mov qword ptr [rbp - 0x50], rdx
; X64:    mov rdx, rcx
; X64:    mov ecx, dword ptr [rbp - 0x34]
; X64:    mov eax, 0x0
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_var_arg-0x4
; X64:    add rsp, 0x50
; X64:    pop rbp
; X64:    ret
;
; ARM64-LABEL: call_i32_vararg>:
; ARM64:    sub sp, sp, #0xc0
; ARM64:    stp x29, x30, [sp]
; ARM64:    mov x29, sp
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    mov w4, w1
; ARM64:    bl 0x3e4 <call_i32_vararg+0x34>
; ARM64:     R_AARCH64_CALL26 fn_var_arg
; ARM64:    ldp x29, x30, [sp]
; ARM64:    add sp, sp, #0xc0
; ARM64:    ret
; ARM64:     ...
entry:
    %3 = call i32 (ptr, ...) @fn_var_arg(ptr %0, i128 %2, i32 %1)
    ret i32 %3
}

define i32 @call_indirect(ptr %0) {
; X64-LABEL: call_indirect>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov qword ptr [rbp - 0x30], rdi
; X64:    mov edi, 0xa
; X64:    call qword ptr [rbp - 0x30]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rax], al
;
; ARM64-LABEL: call_indirect>:
; ARM64:    sub sp, sp, #0xb0
; ARM64:    stp x29, x30, [sp]
; ARM64:    mov x29, sp
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    str x0, [x29, #0xa0]
; ARM64:    mov x0, #0xa // =10
; ARM64:    ldr x9, [x29, #0xa0]
; ARM64:    blr x9
; ARM64:    ldp x29, x30, [sp]
; ARM64:    add sp, sp, #0xb0
; ARM64:    ret
; ARM64:     ...
entry:
  %1 = call i32 (i32) %0 (i32 10)
  ret i32 %1
}

%struct.ptr_i32 = type { ptr, i32 }
define i32 @fn_i32_byval_ptr_i32_i32(ptr byval(%struct.ptr_i32) align 8 %0, i32 %1) {
; X64-LABEL: fn_i32_byval_ptr_i32_i32>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x50
; X64:    lea rax, [rbp + 0x10]
; X64:    lea rax, [rax + 0x8]
; X64:    mov eax, dword ptr [rax]
; X64:    lea eax, [rax + rdi]
; X64:    add rsp, 0x50
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rbp + 0x48], dl
;
; ARM64-LABEL: fn_i32_byval_ptr_i32_i32>:
; ARM64:    sub sp, sp, #0xc0
; ARM64:    stp x29, x30, [sp]
; ARM64:    mov x29, sp
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    add x8, sp, #0xc0
; ARM64:    add x9, x8, #0x0
; ARM64:    add x9, x9, #0x8
; ARM64:    ldr w9, [x9]
; ARM64:    add w0, w0, w9
; ARM64:    ldp x29, x30, [sp]
; ARM64:    add sp, sp, #0xc0
; ARM64:    ret
; ARM64:     ...
entry:
  %addr = getelementptr %struct.ptr_i32, ptr %0, i64 0, i32 1
  %val = load i32, ptr %addr
  %res = add i32 %val, %1
  ret i32 %res
}

define i32 @call_byval(i32 %0) {
; X64-LABEL: call_byval>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x50
; X64:    sub rsp, 0x10
; X64:    lea rax, [rbp - 0x40]
; X64:    mov rcx, qword ptr [rax]
; X64:    mov qword ptr [rsp], rcx
; X64:    mov rcx, qword ptr [rax + 0x8]
; X64:    mov qword ptr [rsp + 0x8], rcx
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_i32_byval_ptr_i32_i32-0x4
; X64:    add rsp, 0x10
; X64:    add rsp, 0x50
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rbp + 0x48], dl
;
; ARM64-LABEL: call_byval>:
; ARM64:    sub sp, sp, #0xc0
; ARM64:    stp x29, x30, [sp]
; ARM64:    mov x29, sp
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    sub sp, sp, #0x10
; ARM64:    add x1, x29, #0xa0
; ARM64:    ldr x2, [x1]
; ARM64:    str x2, [sp]
; ARM64:    ldr x2, [x1, #0x8]
; ARM64:    str x2, [sp, #0x8]
; ARM64:    bl 0x558 <call_byval+0x48>
; ARM64:     R_AARCH64_CALL26 fn_i32_byval_ptr_i32_i32
; ARM64:    add sp, sp, #0x10
; ARM64:    ldp x29, x30, [sp]
; ARM64:    add sp, sp, #0xc0
; ARM64:    ret
; ARM64:     ...
entry:
  %val = alloca %struct.ptr_i32, align 8
  %1 = call i32 @fn_i32_byval_ptr_i32_i32(ptr byval(%struct.ptr_i32) align 8 %val, i32 %0)
  ret i32 %1
}

%struct.3i64 = type { [3 x i64] }

define void @call_sret_tgt(ptr sret(%struct.3i64) align 8) {
; X64-LABEL: call_sret_tgt>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov rax, rdi
; X64:    mov qword ptr [rax], 0x1
; X64:    lea rax, [rdi + 0x8]
; X64:    mov qword ptr [rax], 0x2
; X64:    lea rdi, [rdi + 0x10]
; X64:    mov qword ptr [rdi], 0x3
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rax], al
;
; ARM64-LABEL: call_sret_tgt>:
; ARM64:    sub sp, sp, #0xb0
; ARM64:    stp x29, x30, [sp]
; ARM64:    mov x29, sp
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    mov x0, x8
; ARM64:    mov x1, #0x1 // =1
; ARM64:    str x1, [x0]
; ARM64:    add x0, x8, #0x8
; ARM64:    mov x1, #0x2 // =2
; ARM64:    str x1, [x0]
; ARM64:    add x8, x8, #0x10
; ARM64:    mov x0, #0x3 // =3
; ARM64:    str x0, [x8]
; ARM64:    ldp x29, x30, [sp]
; ARM64:    add sp, sp, #0xb0
; ARM64:    ret
; ARM64:     ...
  %gep1 = getelementptr inbounds %struct.3i64, ptr %0, i64 0, i32 0, i32 0
  store i64 1, ptr %gep1
  %gep2 = getelementptr inbounds %struct.3i64, ptr %0, i64 0, i32 0, i32 1
  store i64 2, ptr %gep2
  %gep3 = getelementptr inbounds %struct.3i64, ptr %0, i64 0, i32 0, i32 2
  store i64 3, ptr %gep3
  ret void
}

define void @call_sret() {
; X64-LABEL: call_sret>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x50
; X64:    lea rdi, [rbp - 0x50]
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 call_sret_tgt-0x4
; X64:    add rsp, 0x50
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    <unknown>
;
; ARM64-LABEL: call_sret>:
; ARM64:    sub sp, sp, #0xc0
; ARM64:    stp x29, x30, [sp]
; ARM64:    mov x29, sp
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    nop
; ARM64:    add x8, x29, #0xa0
; ARM64:    bl 0x654 <call_sret+0x34>
; ARM64:     R_AARCH64_CALL26 call_sret_tgt
; ARM64:    ldp x29, x30, [sp]
; ARM64:    add sp, sp, #0xc0
; ARM64:    ret
; ARM64:     ...
  %1 = alloca %struct.3i64, align 8
  call void @call_sret_tgt(ptr sret(%struct.3i64) align 8 %1)
  ret void
}

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
