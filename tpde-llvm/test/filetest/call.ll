; NOTE: Assertions have been autogenerated by utils/update_tpde_llvm_test_checks.py UTC_ARGS: --tool tpde_llvm --default-march x86-64-v2 --filter-out "int3" --version 5
; SPDX-FileCopyrightText: 2024 Tobias Schwarz <tobias.schwarz@tum.de>
;
; SPDX-License-Identifier: LicenseRef-Proprietary

; RUN: tpde_llvm %s | llvm-objdump -d -r --no-show-raw-insn --symbolize-operands --no-addresses --x86-asm-syntax=intel --section=.text --section=.rodata - | FileCheck %s -check-prefixes=X64,CHECK --enable-var-scope --dump-input always


declare void @fn_void_void();
declare i32 @fn_i32_void();
declare i128 @fn_i128_void();

declare void @fn_void_i32(i32);
declare i32 @fn_i32_i32_i32(i32, i32);

declare i32 @fn_i32_i32_i128_i128_i128(i32, i128, i128, i128);

declare i32 @fn_var_arg(ptr, ...);


define void @call_void_void() {
; X64-LABEL: call_void_void>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x30
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_void_void-0x4
; X64:    add rsp, 0x30
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rbp + 0x48], dl
entry:
  call void @fn_void_void()
  ret void
}

define i32 @call_i32_void() {
; X64-LABEL: call_i32_void>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x30
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_i32_void-0x4
; X64:    lea eax, [rax + 0xa]
; X64:    add rsp, 0x30
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
entry:
  %0 = call i32 @fn_i32_void()
  %1 = add i32 %0, 10
  ret i32 %1
}

define i128 @call_i128_void() {
; X64-LABEL: call_i128_void>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    push rbx
; X64:    nop dword ptr [rax + rax]
; X64:    sub rsp, 0x48
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_i128_void-0x4
; X64:    mov rcx, rax
; X64:    add rcx, 0xa
; X64:    mov rbx, rdx
; X64:    adc rbx, 0x0
; X64:    mov rax, rcx
; X64:    mov rdx, rbx
; X64:    add rsp, 0x48
; X64:    pop rbx
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rbp + 0x48], dl
entry:
  %0 = call i128 @fn_i128_void()
  %1 = add i128 %0, 10
  ret i128 %1
}

define i32 @call_i128_void_ret_i32(i32 %0) {
; X64-LABEL: call_i128_void_ret_i32>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    push rbx
; X64:    nop dword ptr [rax + rax]
; X64:    sub rsp, 0x48
; X64:    mov dword ptr [rbp - 0x2c], edi
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_i128_void-0x4
; X64:    mov rcx, rax
; X64:    add rcx, 0xa
; X64:    mov rbx, rdx
; X64:    adc rbx, 0x0
; X64:    mov eax, dword ptr [rbp - 0x2c]
; X64:    add rsp, 0x48
; X64:    pop rbx
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rbp + 0x48], dl
entry:
  %1 = call i128 @fn_i128_void()
  %2 = add i128 %1, 10
  ret i32 %0
}

define i32 @call_void_i32(i32 %0, i32 %1) {
; X64-LABEL: call_void_i32>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x30
; X64:    mov dword ptr [rbp - 0x2c], edi
; X64:    mov edi, esi
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_void_i32-0x4
; X64:    mov eax, dword ptr [rbp - 0x2c]
; X64:    add rsp, 0x30
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rbp + 0x48], dl
entry:
  call void @fn_void_i32(i32 %1)
  ret i32 %0
}

define void @call_void_i32_mismatch(i32 %0, i32 %1) {
; X64-LABEL: call_void_i32_mismatch>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x30
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_void_i32-0x4
; X64:    add rsp, 0x30
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rbp + 0x48], dl
entry:
  call void (i32, i32) @fn_void_i32(i32 %0, i32 %1)
  ret void
}

define i32 @call_i32_i32_i32(i32 %0, i32 %1) {
; X64-LABEL: call_i32_i32_i32>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov dword ptr [rbp - 0x2c], edi
; X64:    mov edi, esi
; X64:    mov esi, dword ptr [rbp - 0x2c]
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_i32_i32_i32-0x4
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rbp + 0x48], dl
entry:
  %2 = call i32 @fn_i32_i32_i32(i32 %1, i32 %0)
  ret i32 %2
}

define i32 @call_i32_i32_i128_i128_i128(i32 %0, i128 %1) {
; X64-LABEL: call_i32_i32_i128_i128_i128>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    sub rsp, 0x10
; X64:    mov qword ptr [rbp - 0x40], rsi
; X64:    mov qword ptr [rbp - 0x38], rdx
; X64:    mov rcx, qword ptr [rbp - 0x40]
; X64:    mov r8, qword ptr [rbp - 0x38]
; X64:    mov rax, qword ptr [rbp - 0x40]
; X64:    mov qword ptr [rsp], rax
; X64:    mov rax, qword ptr [rbp - 0x38]
; X64:    mov qword ptr [rsp + 0x8], rax
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_i32_i32_i128_i128_i128-0x4
; X64:    add rsp, 0x10
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:     ...
entry:
  %2 = call i32 @fn_i32_i32_i128_i128_i128(i32 %0, i128 %1, i128 %1, i128 %1)
  ret i32 %2
}

define i32 @call_i32_vararg(ptr %0, i32 %1, i128 %2) {
; X64-LABEL: call_i32_vararg>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x50
; X64:    mov dword ptr [rbp - 0x34], esi
; X64:    mov rsi, rdx
; X64:    mov qword ptr [rbp - 0x50], rdx
; X64:    mov rdx, rcx
; X64:    mov ecx, dword ptr [rbp - 0x34]
; X64:    mov eax, 0x0
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_var_arg-0x4
; X64:    add rsp, 0x50
; X64:    pop rbp
; X64:    ret
entry:
    %3 = call i32 (ptr, ...) @fn_var_arg(ptr %0, i128 %2, i32 %1)
    ret i32 %3
}

define i32 @call_indirect(ptr %0) {
; X64-LABEL: call_indirect>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov qword ptr [rbp - 0x30], rdi
; X64:    mov edi, 0xa
; X64:    call qword ptr [rbp - 0x30]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rax], al
entry:
  %1 = call i32 (i32) %0 (i32 10)
  ret i32 %1
}

%struct.ptr_i32 = type { ptr, i32 }
define i32 @fn_i32_byval_ptr_i32_i32(ptr byval(%struct.ptr_i32) align 8 %0, i32 %1) {
; X64-LABEL: fn_i32_byval_ptr_i32_i32>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x50
; X64:    lea rax, [rbp + 0x10]
; X64:    lea rax, [rax + 0x8]
; X64:    mov eax, dword ptr [rax]
; X64:    lea eax, [rax + rdi]
; X64:    add rsp, 0x50
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rbp + 0x48], dl
entry:
  %addr = getelementptr %struct.ptr_i32, ptr %0, i64 0, i32 1
  %val = load i32, ptr %addr
  %res = add i32 %val, %1
  ret i32 %res
}

define i32 @call_byval(i32 %0) {
; X64-LABEL: call_byval>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x50
; X64:    sub rsp, 0x10
; X64:    lea rax, [rbp - 0x40]
; X64:    mov rcx, qword ptr [rax]
; X64:    mov qword ptr [rsp], rcx
; X64:    mov rcx, qword ptr [rax + 0x8]
; X64:    mov qword ptr [rsp + 0x8], rcx
; X64:  <L0>:
; X64:    call <L0>
; X64:     R_X86_64_PLT32 fn_i32_byval_ptr_i32_i32-0x4
; X64:    add rsp, 0x10
; X64:    add rsp, 0x50
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    <unknown>
entry:
  %val = alloca %struct.ptr_i32, align 8
  %1 = call i32 @fn_i32_byval_ptr_i32_i32(ptr byval(%struct.ptr_i32) align 8 %val, i32 %0)
  ret i32 %1
}

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
