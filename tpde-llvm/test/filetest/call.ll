; NOTE: Assertions have been autogenerated by test/update_tpde_llc_test_checks.py UTC_ARGS: --version 5
; SPDX-FileCopyrightText: 2024 Tobias Schwarz <tobias.schwarz@tum.de>
;
; SPDX-License-Identifier: LicenseRef-Proprietary

; RUN: tpde-llc --target=x86_64 %s | %objdump | FileCheck %s -check-prefixes=X64
; RUN: tpde-llc --target=aarch64 %s | %objdump | FileCheck %s -check-prefixes=ARM64


declare void @fn_void_void();
declare i32 @fn_i32_void();
declare i128 @fn_i128_void();

declare void @fn_void_i32(i32);
declare i32 @fn_i32_i32_i32(i32, i32);

declare i32 @fn_i32_i32_i128_i128_i128(i32, i128, i128, i128);

declare i32 @fn_var_arg(ptr, ...);


define void @call_void_void() {
; X64-LABEL: <call_void_void>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_void_void-0x4
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop
;
; ARM64-LABEL: <call_void_void>:
; ARM64:         sub sp, sp, #0xa0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    bl 0x30 <call_void_void+0x10>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_void_void
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xa0
; ARM64-NEXT:    ret
entry:
  call void @fn_void_void()
  ret void
}

define i32 @call_i32_void() {
; X64-LABEL: <call_i32_void>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i32_void-0x4
; X64-NEXT:    lea eax, [rax + 0xa]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <call_i32_void>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    bl 0xa0 <call_i32_void+0x10>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i32_void
; ARM64-NEXT:    add w0, w0, #0xa
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
  %0 = call i32 @fn_i32_void()
  %1 = add i32 %0, 10
  ret i32 %1
}

define i128 @call_i128_void() {
; X64-LABEL: <call_i128_void>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x50
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i128_void-0x4
; X64-NEXT:    mov rcx, rax
; X64-NEXT:    add rcx, 0xa
; X64-NEXT:    adc rdx, 0x0
; X64-NEXT:    mov rax, rcx
; X64-NEXT:    add rsp, 0x50
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax]
;
; ARM64-LABEL: <call_i128_void>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    bl 0x110 <call_i128_void+0x10>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i128_void
; ARM64-NEXT:    adds x2, x0, #0xa
; ARM64-NEXT:    mov w3, #0x0 // =0
; ARM64-NEXT:    adc x3, x3, x1
; ARM64-NEXT:    mov x0, x2
; ARM64-NEXT:    mov x1, x3
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
entry:
  %0 = call i128 @fn_i128_void()
  %1 = add i128 %0, 10
  ret i128 %1
}

define i32 @call_i128_void_ret_i32(i32 %0) {
; X64-LABEL: <call_i128_void_ret_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x50
; X64-NEXT:    mov dword ptr [rbp - 0x2c], edi
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i128_void-0x4
; X64-NEXT:    mov rcx, rax
; X64-NEXT:    add rcx, 0xa
; X64-NEXT:    adc rdx, 0x0
; X64-NEXT:    mov eax, dword ptr [rbp - 0x2c]
; X64-NEXT:    add rsp, 0x50
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <call_i128_void_ret_i32>:
; ARM64:         sub sp, sp, #0xd0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str w0, [x29, #0xa0]
; ARM64-NEXT:    bl 0x194 <call_i128_void_ret_i32+0x14>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i128_void
; ARM64-NEXT:    adds x2, x0, #0xa
; ARM64-NEXT:    mov w3, #0x0 // =0
; ARM64-NEXT:    adc x3, x3, x1
; ARM64-NEXT:    ldr w0, [x29, #0xa0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xd0
; ARM64-NEXT:    ret
entry:
  %1 = call i128 @fn_i128_void()
  %2 = add i128 %1, 10
  ret i32 %0
}

define i32 @call_void_i32(i32 %0, i32 %1) {
; X64-LABEL: <call_void_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov dword ptr [rbp - 0x2c], edi
; X64-NEXT:    mov edi, esi
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_void_i32-0x4
; X64-NEXT:    mov eax, dword ptr [rbp - 0x2c]
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
;
; ARM64-LABEL: <call_void_i32>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str w0, [x29, #0xa0]
; ARM64-NEXT:    mov w0, w1
; ARM64-NEXT:    bl 0x218 <call_void_i32+0x18>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_void_i32
; ARM64-NEXT:    ldr w0, [x29, #0xa0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
  call void @fn_void_i32(i32 %1)
  ret i32 %0
}

define void @call_void_i32_mismatch(i32 %0, i32 %1) {
; X64-LABEL: <call_void_i32_mismatch>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_void_i32-0x4
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop
;
; ARM64-LABEL: <call_void_i32_mismatch>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    bl 0x280 <call_void_i32_mismatch+0x10>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_void_i32
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
  call void (i32, i32) @fn_void_i32(i32 %0, i32 %1)
  ret void
}

define i32 @call_i32_i32_i32(i32 %0, i32 %1) {
; X64-LABEL: <call_i32_i32_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    mov dword ptr [rbp - 0x2c], edi
; X64-NEXT:    mov edi, esi
; X64-NEXT:    mov esi, dword ptr [rbp - 0x2c]
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i32_i32_i32-0x4
; X64-NEXT:    add rsp, 0x40
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
;
; ARM64-LABEL: <call_i32_i32_i32>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str w0, [x29, #0xa0]
; ARM64-NEXT:    mov w0, w1
; ARM64-NEXT:    ldr w1, [x29, #0xa0]
; ARM64-NEXT:    bl 0x2fc <call_i32_i32_i32+0x1c>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i32_i32_i32
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
  %2 = call i32 @fn_i32_i32_i32(i32 %1, i32 %0)
  ret i32 %2
}

define i32 @call_i32_i32_i128_i128_i128(i32 %0, i128 %1) {
; X64-LABEL: <call_i32_i32_i128_i128_i128>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    sub rsp, 0x10
; X64-NEXT:    mov qword ptr [rbp - 0x40], rsi
; X64-NEXT:    mov qword ptr [rbp - 0x38], rdx
; X64-NEXT:    mov rcx, qword ptr [rbp - 0x40]
; X64-NEXT:    mov r8, qword ptr [rbp - 0x38]
; X64-NEXT:    mov rax, qword ptr [rbp - 0x40]
; X64-NEXT:    mov qword ptr [rsp], rax
; X64-NEXT:    mov rax, qword ptr [rbp - 0x38]
; X64-NEXT:    mov qword ptr [rsp + 0x8], rax
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i32_i32_i128_i128_i128-0x4
; X64-NEXT:    add rsp, 0x10
; X64-NEXT:    add rsp, 0x40
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <call_i32_i32_i128_i128_i128>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str x2, [x29, #0xb0]
; ARM64-NEXT:    str x3, [x29, #0xb8]
; ARM64-NEXT:    ldr x4, [x29, #0xb0]
; ARM64-NEXT:    ldr x5, [x29, #0xb8]
; ARM64-NEXT:    ldr x6, [x29, #0xb0]
; ARM64-NEXT:    ldr x7, [x29, #0xb8]
; ARM64-NEXT:    bl 0x378 <call_i32_i32_i128_i128_i128+0x28>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i32_i32_i128_i128_i128
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
entry:
  %2 = call i32 @fn_i32_i32_i128_i128_i128(i32 %0, i128 %1, i128 %1, i128 %1)
  ret i32 %2
}

define i32 @call_i32_vararg(ptr %0, i32 %1, i128 %2) {
; X64-LABEL: <call_i32_vararg>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x50
; X64-NEXT:    mov dword ptr [rbp - 0x34], esi
; X64-NEXT:    mov rsi, rdx
; X64-NEXT:    mov qword ptr [rbp - 0x50], rdx
; X64-NEXT:    mov rdx, rcx
; X64-NEXT:    mov ecx, dword ptr [rbp - 0x34]
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_var_arg-0x4
; X64-NEXT:    add rsp, 0x50
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    nop dword ptr [rax]
;
; ARM64-LABEL: <call_i32_vararg>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov w4, w1
; ARM64-NEXT:    bl 0x3e4 <call_i32_vararg+0x14>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_var_arg
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
entry:
    %3 = call i32 (ptr, ...) @fn_var_arg(ptr %0, i128 %2, i32 %1)
    ret i32 %3
}

define i32 @call_indirect(ptr %0) {
; X64-LABEL: <call_indirect>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    mov qword ptr [rbp - 0x30], rdi
; X64-NEXT:    mov edi, 0xa
; X64-NEXT:    call qword ptr [rbp - 0x30]
; X64-NEXT:    add rsp, 0x40
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    nop
;
; ARM64-LABEL: <call_indirect>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str x0, [x29, #0xa0]
; ARM64-NEXT:    mov x0, #0xa // =10
; ARM64-NEXT:    ldr x1, [x29, #0xa0]
; ARM64-NEXT:    blr x1
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
entry:
  %1 = call i32 (i32) %0 (i32 10)
  ret i32 %1
}

%struct.ptr_i32 = type { ptr, i32 }
define i32 @fn_i32_byval_ptr_i32_i32(ptr byval(%struct.ptr_i32) align 8 %0, i32 %1) {
; X64-LABEL: <fn_i32_byval_ptr_i32_i32>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    lea rax, [rbp + 0x10]
; X64-NEXT:    mov ecx, dword ptr [rax + 0x8]
; X64-NEXT:    lea ecx, [rcx + rdi]
; X64-NEXT:    mov eax, ecx
; X64-NEXT:    add rsp, 0x40
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    nop
;
; ARM64-LABEL: <fn_i32_byval_ptr_i32_i32>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    add x8, sp, #0xc0
; ARM64-NEXT:    add x9, x8, #0x0
; ARM64-NEXT:    ldr w1, [x9, #0x8]
; ARM64-NEXT:    add w0, w0, w1
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
entry:
  %addr = getelementptr %struct.ptr_i32, ptr %0, i64 0, i32 1
  %val = load i32, ptr %addr
  %res = add i32 %val, %1
  ret i32 %res
}

define i32 @call_byval(i32 %0) {
; X64-LABEL: <call_byval>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x50
; X64-NEXT:    sub rsp, 0x10
; X64-NEXT:    lea rax, [rbp - 0x40]
; X64-NEXT:    mov rcx, qword ptr [rax]
; X64-NEXT:    mov qword ptr [rsp], rcx
; X64-NEXT:    mov rcx, qword ptr [rax + 0x8]
; X64-NEXT:    mov qword ptr [rsp + 0x8], rcx
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 fn_i32_byval_ptr_i32_i32-0x4
; X64-NEXT:    add rsp, 0x10
; X64-NEXT:    add rsp, 0x50
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <call_byval>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    sub sp, sp, #0x10
; ARM64-NEXT:    add x1, x29, #0xa0
; ARM64-NEXT:    ldr x2, [x1]
; ARM64-NEXT:    str x2, [sp]
; ARM64-NEXT:    ldr x2, [x1, #0x8]
; ARM64-NEXT:    str x2, [sp, #0x8]
; ARM64-NEXT:    bl 0x548 <call_byval+0x28>
; ARM64-NEXT:     R_AARCH64_CALL26 fn_i32_byval_ptr_i32_i32
; ARM64-NEXT:    add sp, sp, #0x10
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
entry:
  %val = alloca %struct.ptr_i32, align 8
  %1 = call i32 @fn_i32_byval_ptr_i32_i32(ptr byval(%struct.ptr_i32) align 8 %val, i32 %0)
  ret i32 %1
}

%struct.3i64 = type { [3 x i64] }

define void @call_sret_tgt(ptr sret(%struct.3i64) align 8) {
; X64-LABEL: <call_sret_tgt>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov qword ptr [rdi], 0x1
; X64-NEXT:    mov qword ptr [rdi + 0x8], 0x2
; X64-NEXT:    mov qword ptr [rdi + 0x10], 0x3
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    nop word ptr [rax + rax]
;
; ARM64-LABEL: <call_sret_tgt>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov x0, #0x1 // =1
; ARM64-NEXT:    str x0, [x8]
; ARM64-NEXT:    mov x0, #0x2 // =2
; ARM64-NEXT:    str x0, [x8, #0x8]
; ARM64-NEXT:    mov x0, #0x3 // =3
; ARM64-NEXT:    str x0, [x8, #0x10]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
  %gep1 = getelementptr inbounds %struct.3i64, ptr %0, i64 0, i32 0, i32 0
  store i64 1, ptr %gep1
  %gep2 = getelementptr inbounds %struct.3i64, ptr %0, i64 0, i32 0, i32 1
  store i64 2, ptr %gep2
  %gep3 = getelementptr inbounds %struct.3i64, ptr %0, i64 0, i32 0, i32 2
  store i64 3, ptr %gep3
  ret void
}

define void @call_sret() {
; X64-LABEL: <call_sret>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x50
; X64-NEXT:    lea rdi, [rbp - 0x50]
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 call_sret_tgt-0x4
; X64-NEXT:    add rsp, 0x50
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    nop dword ptr [rax]
;
; ARM64-LABEL: <call_sret>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    add x8, x29, #0xa0
; ARM64-NEXT:    bl 0x634 <call_sret+0x14>
; ARM64-NEXT:     R_AARCH64_CALL26 call_sret_tgt
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %1 = alloca %struct.3i64, align 8
  call void @call_sret_tgt(ptr sret(%struct.3i64) align 8 %1)
  ret void
}

declare i32 @alloca_call_tgt(i32, ptr)
define i32 @alloca_call(i32 %a1, i32 %a2, i32 %a3, i32 %a4) {
; X64-LABEL: <alloca_call>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x138d0
; X64-NEXT:    mov edi, esi
; X64-NEXT:    mov dword ptr [rbp - 0x138b4], esi
; X64-NEXT:    lea rsi, [rbp - 0x138b0]
; X64-NEXT:    mov dword ptr [rbp - 0x138bc], ecx
; X64-NEXT:    mov dword ptr [rbp - 0x138b8], edx
; X64-NEXT:  <L0>:
; X64-NEXT:    call <L0>
; X64-NEXT:     R_X86_64_PLT32 alloca_call_tgt-0x4
; X64-NEXT:    mov ecx, dword ptr [rbp - 0x138b4]
; X64-NEXT:    lea ecx, [rcx + rax]
; X64-NEXT:    mov eax, dword ptr [rbp - 0x138b8]
; X64-NEXT:    mov edx, dword ptr [rbp - 0x138bc]
; X64-NEXT:    lea eax, [rax + rdx]
; X64-NEXT:    mov eax, ecx
; X64-NEXT:    add rsp, 0x138d0
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
;
; ARM64-LABEL: <alloca_call>:
; ARM64:         sub sp, sp, #0x14, lsl #12 // =0x14000
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov w0, w1
; ARM64-NEXT:    mov x4, #0x3920 // =14624
; ARM64-NEXT:    movk x4, #0x1, lsl #16
; ARM64-NEXT:    add x4, x29, w4, uxtw
; ARM64-NEXT:    str w1, [x4]
; ARM64-NEXT:    add x1, x29, #0xa0
; ARM64-NEXT:    mov x4, #0x3924 // =14628
; ARM64-NEXT:    movk x4, #0x1, lsl #16
; ARM64-NEXT:    add x4, x29, w4, uxtw
; ARM64-NEXT:    str w2, [x4]
; ARM64-NEXT:    mov x2, #0x3928 // =14632
; ARM64-NEXT:    movk x2, #0x1, lsl #16
; ARM64-NEXT:    add x2, x29, w2, uxtw
; ARM64-NEXT:    str w3, [x2]
; ARM64-NEXT:    bl 0x6d8 <alloca_call+0x48>
; ARM64-NEXT:     R_AARCH64_CALL26 alloca_call_tgt
; ARM64-NEXT:    mov x2, #0x3920 // =14624
; ARM64-NEXT:    movk x2, #0x1, lsl #16
; ARM64-NEXT:    add x2, x29, w2, uxtw
; ARM64-NEXT:    ldr w1, [x2]
; ARM64-NEXT:    add w0, w0, w1
; ARM64-NEXT:    mov x2, #0x3928 // =14632
; ARM64-NEXT:    movk x2, #0x1, lsl #16
; ARM64-NEXT:    add x2, x29, w2, uxtw
; ARM64-NEXT:    ldr w1, [x2]
; ARM64-NEXT:    mov x3, #0x3924 // =14628
; ARM64-NEXT:    movk x3, #0x1, lsl #16
; ARM64-NEXT:    add x3, x29, w3, uxtw
; ARM64-NEXT:    ldr w2, [x3]
; ARM64-NEXT:    add w1, w1, w2
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0x14, lsl #12 // =0x14000
; ARM64-NEXT:    ret
  %buf = alloca [80000 x i8]
  %c = call i32 @alloca_call_tgt(i32 %a2, ptr %buf)
  %r = add i32 %a2, %c
  %u1 = add i32 %a3, %a4
  ret i32 %r
}

define i32 @ind_call(ptr %call, i32 %a, i32 %b) {
; X64-LABEL: <ind_call>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    mov qword ptr [rbp - 0x30], rdi
; X64-NEXT:    call rdi
; X64-NEXT:    call qword ptr [rbp - 0x30]
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    add rsp, 0x40
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <ind_call>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    str x0, [x29, #0xa0]
; ARM64-NEXT:    blr x0
; ARM64-NEXT:    ldr x0, [x29, #0xa0]
; ARM64-NEXT:    blr x0
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
  call void %call()
  call void %call()
  ret i32 0
}

