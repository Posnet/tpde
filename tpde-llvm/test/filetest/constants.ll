; NOTE: Assertions have been autogenerated by utils/update_tpde_llvm_test_checks.py UTC_ARGS: --tool tpde_llvm --default-march x86-64-v2 --version 5
; SPDX-License-Identifier: LicenseRef-Proprietary

; RUN: tpde_llvm --target=x86_64 %s | llvm-objdump -d -r --no-show-raw-insn --symbolize-operands --no-addresses --x86-asm-syntax=intel --section=.text --section=.rodata - | FileCheck %s -check-prefixes=X64,CHECK --enable-var-scope --dump-input always
; RUN: tpde_llvm --target=aarch64 %s | llvm-objdump -d -r --no-show-raw-insn --symbolize-operands --no-addresses - | FileCheck %s -check-prefixes=ARM64,CHECK --enable-var-scope --dump-input always

@glob = internal global i32 5, align 4

define void @store_glob(ptr %ptr) {
; X64-LABEL: store_glob>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    lea rax, <store_glob+0x13>
; X64-NEXT:     R_X86_64_PC32 glob-0x4
; X64-NEXT:    mov qword ptr [rdi], rax
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    nop dword ptr [rax]
;
; ARM64-LABEL: store_glob>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    adrp x1, 0x0 <.text>
; ARM64-NEXT:     R_AARCH64_ADR_PREL_PG_HI21 glob
; ARM64-NEXT:    add x1, x1, #0x0
; ARM64-NEXT:     R_AARCH64_ADD_ABS_LO12_NC glob
; ARM64-NEXT:    str x1, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
; ARM64-NEXT:     ...
  store ptr @glob, ptr %ptr
  ret void
}

define void @store_glob_ptrtoint(ptr %ptr) {
; X64-LABEL: store_glob_ptrtoint>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    lea rax, <store_glob_ptrtoint+0x13>
; X64-NEXT:     R_X86_64_PC32 glob-0x4
; X64-NEXT:    mov qword ptr [rdi], rax
; X64-NEXT:    add rsp, 0x40
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    nop dword ptr [rax]
;
; ARM64-LABEL: store_glob_ptrtoint>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    adrp x1, 0x0 <.text>
; ARM64-NEXT:     R_AARCH64_ADR_PREL_PG_HI21 glob
; ARM64-NEXT:    add x1, x1, #0x0
; ARM64-NEXT:     R_AARCH64_ADD_ABS_LO12_NC glob
; ARM64-NEXT:    str x1, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
; ARM64-NEXT:     ...
  store i64 ptrtoint (ptr @glob to i64), ptr %ptr
  ret void
}

define void @store_glob_ptrtoint_trunc_add(ptr %ptr) {
; X64-LABEL: store_glob_ptrtoint_trunc_add>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    lea rax, <store_glob_ptrtoint_trunc_add+0x13>
; X64-NEXT:     R_X86_64_PC32 glob-0x4
; X64-NEXT:    lea eax, [rax + 0x20]
; X64-NEXT:    mov dword ptr [rdi], eax
; X64-NEXT:    add rsp, 0x40
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    nop
;
; ARM64-LABEL: store_glob_ptrtoint_trunc_add>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    adrp x1, 0x0 <.text>
; ARM64-NEXT:     R_AARCH64_ADR_PREL_PG_HI21 glob
; ARM64-NEXT:    add x1, x1, #0x0
; ARM64-NEXT:     R_AARCH64_ADD_ABS_LO12_NC glob
; ARM64-NEXT:    add w1, w1, #0x20
; ARM64-NEXT:    str w1, [x0]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
; ARM64-NEXT:     ...
  store i32 add (i32 trunc (i64 ptrtoint (ptr @glob to i64) to i32), i32 32), ptr %ptr
  ret void
}

define void @store_struct1(ptr %ptr) {
; X64-LABEL: store_struct1>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov dword ptr [rdi], 0x0
; X64-NEXT:    mov dword ptr [rdi + 0x4], 0x1
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
;
; ARM64-LABEL: store_struct1>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov w1, #0x0 // =0
; ARM64-NEXT:    str w1, [x0]
; ARM64-NEXT:    mov x1, #0x1 // =1
; ARM64-NEXT:    str w1, [x0, #0x4]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
; ARM64-NEXT:     ...
  store {i32, i32} {i32 0, i32 1}, ptr %ptr
  ret void
}

define void @store_struct2(ptr %ptr) {
; X64-LABEL: store_struct2>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov dword ptr [rdi], 0x0
; X64-NEXT:    lea rax, <store_struct2+0x19>
; X64-NEXT:     R_X86_64_PC32 glob-0x4
; X64-NEXT:    mov qword ptr [rdi + 0x8], rax
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: store_struct2>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov w1, #0x0 // =0
; ARM64-NEXT:    str w1, [x0]
; ARM64-NEXT:    adrp x1, 0x0 <.text>
; ARM64-NEXT:     R_AARCH64_ADR_PREL_PG_HI21 glob
; ARM64-NEXT:    add x1, x1, #0x0
; ARM64-NEXT:     R_AARCH64_ADD_ABS_LO12_NC glob
; ARM64-NEXT:    str x1, [x0, #0x8]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
; ARM64-NEXT:     ...
  store {i32, ptr} {i32 0, ptr @glob}, ptr %ptr
  ret void
}

define void @store_struct3(ptr %ptr) {
; X64-LABEL: store_struct3>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x50
; X64-NEXT:    lea rax, <store_struct3+0x13>
; X64-NEXT:     R_X86_64_PC32 glob-0x4
; X64-NEXT:    lea eax, [rax + 0x20]
; X64-NEXT:    mov ecx, 0x0
; X64-NEXT:    mov edx, 0x0
; X64-NEXT:    mov dword ptr [rdi], ecx
; X64-NEXT:    mov dword ptr [rdi + 0x4], eax
; X64-NEXT:    add rsp, 0x50
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    nop dword ptr [rax]
;
; ARM64-LABEL: store_struct3>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    adrp x1, 0x0 <.text>
; ARM64-NEXT:     R_AARCH64_ADR_PREL_PG_HI21 glob
; ARM64-NEXT:    add x1, x1, #0x0
; ARM64-NEXT:     R_AARCH64_ADD_ABS_LO12_NC glob
; ARM64-NEXT:    add w1, w1, #0x20
; ARM64-NEXT:    mov w2, #0x0 // =0
; ARM64-NEXT:    mov w3, #0x0 // =0
; ARM64-NEXT:    str w2, [x0]
; ARM64-NEXT:    str w1, [x0, #0x4]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
; ARM64-NEXT:     ...
  store {i32, i32} {i32 0, i32 add (i32 trunc (i64 ptrtoint (ptr @glob to i64) to i32), i32 32)}, ptr %ptr
  ret void
}

define void @store_array1(ptr %ptr) {
; X64-LABEL: store_array1>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    lea rax, <store_array1+0x13>
; X64-NEXT:     R_X86_64_PC32 glob-0x4
; X64-NEXT:    mov qword ptr [rdi], rax
; X64-NEXT:    mov qword ptr [rdi + 0x8], 0x0
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax]
;
; ARM64-LABEL: store_array1>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    adrp x1, 0x0 <.text>
; ARM64-NEXT:     R_AARCH64_ADR_PREL_PG_HI21 glob
; ARM64-NEXT:    add x1, x1, #0x0
; ARM64-NEXT:     R_AARCH64_ADD_ABS_LO12_NC glob
; ARM64-NEXT:    str x1, [x0]
; ARM64-NEXT:    mov w2, #0x0 // =0
; ARM64-NEXT:    str x2, [x0, #0x8]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
; ARM64-NEXT:     ...
  store [2 x ptr] [ ptr @glob, ptr null ], ptr %ptr
  ret void
}

define void @store_array2(ptr %ptr) {
; X64-LABEL: store_array2>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov qword ptr [rdi], 0xbc614e
; X64-NEXT:    movabs rax, 0x44e6af645f07c
; X64-NEXT:    mov qword ptr [rdi + 0x8], rax
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop
;
; ARM64-LABEL: store_array2>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov x1, #0x614e // =24910
; ARM64-NEXT:    movk x1, #0xbc, lsl #16
; ARM64-NEXT:    str x1, [x0]
; ARM64-NEXT:    mov x1, #0xf07c // =61564
; ARM64-NEXT:    movk x1, #0xf645, lsl #16
; ARM64-NEXT:    movk x1, #0x4e6a, lsl #32
; ARM64-NEXT:    movk x1, #0x4, lsl #48
; ARM64-NEXT:    str x1, [x0, #0x8]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
; ARM64-NEXT:     ...
  store [2 x i64] [ i64 12345678, i64 1212121212121212 ], ptr %ptr
  ret void
}

define void @phi_glob(ptr %ptr) {
; X64-LABEL: phi_glob>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    push r12
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    lea rax, <phi_glob+0x16>
; X64-NEXT:     R_X86_64_PC32 glob-0x4
; X64-NEXT:    mov r12, rax
; X64-NEXT:  <L1>:
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    je <L0>
; X64-NEXT:    lea rax, <phi_glob+0x30>
; X64-NEXT:     R_X86_64_PC32 glob-0x4
; X64-NEXT:    mov r12, rax
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    mov qword ptr [rbx], r12
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop r12
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax]
;
; ARM64-LABEL: phi_glob>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    stp x19, x20, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    adrp x0, 0x0 <.text>
; ARM64-NEXT:     R_AARCH64_ADR_PREL_PG_HI21 glob
; ARM64-NEXT:    add x0, x0, #0x0
; ARM64-NEXT:     R_AARCH64_ADD_ABS_LO12_NC glob
; ARM64-NEXT:    mov x20, x0
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x41c <phi_glob+0x3c>
; ARM64-NEXT:    adrp x0, 0x0 <.text>
; ARM64-NEXT:     R_AARCH64_ADR_PREL_PG_HI21 glob
; ARM64-NEXT:    add x0, x0, #0x0
; ARM64-NEXT:     R_AARCH64_ADD_ABS_LO12_NC glob
; ARM64-NEXT:    mov x20, x0
; ARM64-NEXT:    b 0x400 <phi_glob+0x20>
; ARM64-NEXT:    str x20, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldp x19, x20, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
; ARM64-NEXT:     ...
entry:
  br label %loop
loop:
  %phi = phi ptr [ @glob, %entry ], [ @glob, %loop ]
  br i1 false, label %loop, label %ret
ret:
  store ptr %phi, ptr %ptr
  ret void
}

define void @phi_ptrtoint(ptr %ptr) {
; X64-LABEL: phi_ptrtoint>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    push r12
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    lea rax, <phi_ptrtoint+0x16>
; X64-NEXT:     R_X86_64_PC32 glob-0x4
; X64-NEXT:    mov r12, rax
; X64-NEXT:  <L1>:
; X64-NEXT:    lea rax, <phi_ptrtoint+0x20>
; X64-NEXT:     R_X86_64_PC32 glob-0x4
; X64-NEXT:    mov ecx, 0x0
; X64-NEXT:    test ecx, 0x1
; X64-NEXT:    je <L0>
; X64-NEXT:    mov r12, rax
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    mov qword ptr [rbx], r12
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop r12
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
;
; ARM64-LABEL: phi_ptrtoint>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    stp x19, x20, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    adrp x0, 0x0 <.text>
; ARM64-NEXT:     R_AARCH64_ADR_PREL_PG_HI21 glob
; ARM64-NEXT:    add x0, x0, #0x0
; ARM64-NEXT:     R_AARCH64_ADD_ABS_LO12_NC glob
; ARM64-NEXT:    mov x20, x0
; ARM64-NEXT:    adrp x0, 0x0 <.text>
; ARM64-NEXT:     R_AARCH64_ADR_PREL_PG_HI21 glob
; ARM64-NEXT:    add x0, x0, #0x0
; ARM64-NEXT:     R_AARCH64_ADD_ABS_LO12_NC glob
; ARM64-NEXT:    mov w1, #0x0 // =0
; ARM64-NEXT:    tst w1, #0x1
; ARM64-NEXT:    b.eq 0x4ac <phi_ptrtoint+0x3c>
; ARM64-NEXT:    mov x20, x0
; ARM64-NEXT:    b 0x490 <phi_ptrtoint+0x20>
; ARM64-NEXT:    str x20, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldp x19, x20, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
; ARM64-NEXT:     ...
entry:
  br label %loop
loop:
  %phi = phi i64 [ ptrtoint (ptr @glob to i64), %entry ], [ ptrtoint (ptr @glob to i64), %loop ]
  br i1 false, label %loop, label %ret
ret:
  store i64 %phi, ptr %ptr
  ret void
}

define void @phi_ptrtoint_trunc_add(ptr %ptr) {
; X64-LABEL: phi_ptrtoint_trunc_add>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    push r12
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x30
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    lea rax, <phi_ptrtoint_trunc_add+0x16>
; X64-NEXT:     R_X86_64_PC32 glob-0x4
; X64-NEXT:    lea eax, [rax + 0x20]
; X64-NEXT:    mov r12d, eax
; X64-NEXT:  <L1>:
; X64-NEXT:    lea rax, <phi_ptrtoint_trunc_add+0x23>
; X64-NEXT:     R_X86_64_PC32 glob-0x4
; X64-NEXT:    lea eax, [rax + 0x20]
; X64-NEXT:    mov ecx, 0x0
; X64-NEXT:    test ecx, 0x1
; X64-NEXT:    je <L0>
; X64-NEXT:    mov r12d, eax
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    mov dword ptr [rbx], r12d
; X64-NEXT:    add rsp, 0x30
; X64-NEXT:    pop r12
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: phi_ptrtoint_trunc_add>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    stp x19, x20, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    adrp x0, 0x0 <.text>
; ARM64-NEXT:     R_AARCH64_ADR_PREL_PG_HI21 glob
; ARM64-NEXT:    add x0, x0, #0x0
; ARM64-NEXT:     R_AARCH64_ADD_ABS_LO12_NC glob
; ARM64-NEXT:    add w0, w0, #0x20
; ARM64-NEXT:    mov w20, w0
; ARM64-NEXT:    adrp x0, 0x0 <.text>
; ARM64-NEXT:     R_AARCH64_ADR_PREL_PG_HI21 glob
; ARM64-NEXT:    add x0, x0, #0x0
; ARM64-NEXT:     R_AARCH64_ADD_ABS_LO12_NC glob
; ARM64-NEXT:    add w0, w0, #0x20
; ARM64-NEXT:    mov w1, #0x0 // =0
; ARM64-NEXT:    tst w1, #0x1
; ARM64-NEXT:    b.eq 0x544 <phi_ptrtoint_trunc_add+0x44>
; ARM64-NEXT:    mov w20, w0
; ARM64-NEXT:    b 0x524 <phi_ptrtoint_trunc_add+0x24>
; ARM64-NEXT:    str w20, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldp x19, x20, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
; ARM64-NEXT:     ...
entry:
  br label %loop
loop:
  %phi = phi i32 [ add (i32 trunc (i64 ptrtoint (ptr @glob to i64) to i32), i32 32), %entry ], [ add (i32 trunc (i64 ptrtoint (ptr @glob to i64) to i32), i32 32), %loop ]
  br i1 false, label %loop, label %ret
ret:
  store i32 %phi, ptr %ptr
  ret void
}

define void @phi_struct1(ptr %ptr) {
; X64-LABEL: phi_struct1>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    mov dword ptr [rbp - 0x38], eax
; X64-NEXT:    mov eax, 0x1
; X64-NEXT:    mov dword ptr [rbp - 0x34], eax
; X64-NEXT:  <L1>:
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    je <L0>
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    mov dword ptr [rbp - 0x38], eax
; X64-NEXT:    mov eax, 0x1
; X64-NEXT:    mov dword ptr [rbp - 0x34], eax
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    mov eax, dword ptr [rbp - 0x38]
; X64-NEXT:    mov dword ptr [rbx], eax
; X64-NEXT:    mov ecx, dword ptr [rbp - 0x34]
; X64-NEXT:    mov dword ptr [rbx + 0x4], ecx
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: phi_struct1>:
; ARM64:         sub sp, sp, #0xb0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    str w0, [x29, #0xa8]
; ARM64-NEXT:    mov x0, #0x1 // =1
; ARM64-NEXT:    str w0, [x29, #0xac]
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x5e4 <phi_struct1+0x44>
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    str w0, [x29, #0xa8]
; ARM64-NEXT:    mov x0, #0x1 // =1
; ARM64-NEXT:    str w0, [x29, #0xac]
; ARM64-NEXT:    b 0x5c4 <phi_struct1+0x24>
; ARM64-NEXT:    ldr w0, [x29, #0xa8]
; ARM64-NEXT:    str w0, [x19]
; ARM64-NEXT:    ldr w1, [x29, #0xac]
; ARM64-NEXT:    str w1, [x19, #0x4]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xb0
; ARM64-NEXT:    ret
; ARM64-NEXT:     ...
entry:
  br label %loop
loop:
  %phi = phi {i32, i32} [ {i32 0, i32 1}, %entry ], [ {i32 0, i32 1}, %loop ]
  br i1 false, label %loop, label %ret
ret:
  store {i32, i32} %phi, ptr %ptr
  ret void
}

define void @phi_struct2(ptr %ptr) {
; X64-LABEL: phi_struct2>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    mov dword ptr [rbp - 0x40], eax
; X64-NEXT:    lea rax, <phi_struct2+0x1e>
; X64-NEXT:     R_X86_64_PC32 glob-0x4
; X64-NEXT:    mov qword ptr [rbp - 0x38], rax
; X64-NEXT:  <L1>:
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    je <L0>
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    mov dword ptr [rbp - 0x40], eax
; X64-NEXT:    lea rax, <phi_struct2+0x41>
; X64-NEXT:     R_X86_64_PC32 glob-0x4
; X64-NEXT:    mov qword ptr [rbp - 0x38], rax
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    mov eax, dword ptr [rbp - 0x40]
; X64-NEXT:    mov dword ptr [rbx], eax
; X64-NEXT:    mov rcx, qword ptr [rbp - 0x38]
; X64-NEXT:    mov qword ptr [rbx + 0x8], rcx
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    nop dword ptr [rax]
;
; ARM64-LABEL: phi_struct2>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    str w0, [x29, #0xb0]
; ARM64-NEXT:    adrp x0, 0x0 <.text>
; ARM64-NEXT:     R_AARCH64_ADR_PREL_PG_HI21 glob
; ARM64-NEXT:    add x0, x0, #0x0
; ARM64-NEXT:     R_AARCH64_ADD_ABS_LO12_NC glob
; ARM64-NEXT:    str x0, [x29, #0xb8]
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x69c <phi_struct2+0x4c>
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    str w0, [x29, #0xb0]
; ARM64-NEXT:    adrp x0, 0x0 <.text>
; ARM64-NEXT:     R_AARCH64_ADR_PREL_PG_HI21 glob
; ARM64-NEXT:    add x0, x0, #0x0
; ARM64-NEXT:     R_AARCH64_ADD_ABS_LO12_NC glob
; ARM64-NEXT:    str x0, [x29, #0xb8]
; ARM64-NEXT:    b 0x678 <phi_struct2+0x28>
; ARM64-NEXT:    ldr w0, [x29, #0xb0]
; ARM64-NEXT:    str w0, [x19]
; ARM64-NEXT:    ldr x1, [x29, #0xb8]
; ARM64-NEXT:    str x1, [x19, #0x8]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
; ARM64-NEXT:     ...
entry:
  br label %loop
loop:
  %phi = phi {i32, ptr} [ {i32 0, ptr @glob}, %entry ], [ {i32 0, ptr @glob}, %loop ]
  br i1 false, label %loop, label %ret
ret:
  store {i32, ptr} %phi, ptr %ptr
  ret void
}

define void @phi_struct3(ptr %ptr) {
; X64-LABEL: phi_struct3>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    lea rax, <phi_struct3+0x16>
; X64-NEXT:     R_X86_64_PC32 glob-0x4
; X64-NEXT:    lea eax, [rax + 0x20]
; X64-NEXT:    mov ecx, 0x0
; X64-NEXT:    mov edx, 0x0
; X64-NEXT:    mov dword ptr [rbp - 0x40], ecx
; X64-NEXT:    mov dword ptr [rbp - 0x3c], eax
; X64-NEXT:  <L1>:
; X64-NEXT:    lea rax, <phi_struct3+0x30>
; X64-NEXT:     R_X86_64_PC32 glob-0x4
; X64-NEXT:    lea eax, [rax + 0x20]
; X64-NEXT:    mov ecx, 0x0
; X64-NEXT:    mov edx, 0x0
; X64-NEXT:    mov edx, 0x0
; X64-NEXT:    test edx, 0x1
; X64-NEXT:    je <L0>
; X64-NEXT:    mov dword ptr [rbp - 0x40], ecx
; X64-NEXT:    mov dword ptr [rbp - 0x3c], eax
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    mov eax, dword ptr [rbp - 0x40]
; X64-NEXT:    mov dword ptr [rbx], eax
; X64-NEXT:    mov ecx, dword ptr [rbp - 0x3c]
; X64-NEXT:    mov dword ptr [rbx + 0x4], ecx
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: phi_struct3>:
; ARM64:         sub sp, sp, #0xd0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    adrp x0, 0x0 <.text>
; ARM64-NEXT:     R_AARCH64_ADR_PREL_PG_HI21 glob
; ARM64-NEXT:    add x0, x0, #0x0
; ARM64-NEXT:     R_AARCH64_ADD_ABS_LO12_NC glob
; ARM64-NEXT:    add w0, w0, #0x20
; ARM64-NEXT:    mov w1, #0x0 // =0
; ARM64-NEXT:    mov w2, #0x0 // =0
; ARM64-NEXT:    str w1, [x29, #0xb0]
; ARM64-NEXT:    str w0, [x29, #0xb4]
; ARM64-NEXT:    adrp x0, 0x0 <.text>
; ARM64-NEXT:     R_AARCH64_ADR_PREL_PG_HI21 glob
; ARM64-NEXT:    add x0, x0, #0x0
; ARM64-NEXT:     R_AARCH64_ADD_ABS_LO12_NC glob
; ARM64-NEXT:    add w0, w0, #0x20
; ARM64-NEXT:    mov w1, #0x0 // =0
; ARM64-NEXT:    mov w2, #0x0 // =0
; ARM64-NEXT:    mov w2, #0x0 // =0
; ARM64-NEXT:    tst w2, #0x1
; ARM64-NEXT:    b.eq 0x75c <phi_struct3+0x5c>
; ARM64-NEXT:    str w1, [x29, #0xb0]
; ARM64-NEXT:    str w0, [x29, #0xb4]
; ARM64-NEXT:    b 0x730 <phi_struct3+0x30>
; ARM64-NEXT:    ldr w0, [x29, #0xb0]
; ARM64-NEXT:    str w0, [x19]
; ARM64-NEXT:    ldr w1, [x29, #0xb4]
; ARM64-NEXT:    str w1, [x19, #0x4]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xd0
; ARM64-NEXT:    ret
; ARM64-NEXT:     ...
entry:
  br label %loop
loop:
  %phi = phi {i32, i32} [ {i32 0, i32 add (i32 trunc (i64 ptrtoint (ptr @glob to i64) to i32), i32 32)}, %entry ], [ {i32 0, i32 add (i32 trunc (i64 ptrtoint (ptr @glob to i64) to i32), i32 32)}, %loop ]
  br i1 false, label %loop, label %ret
ret:
  store {i32, i32} %phi, ptr %ptr
  ret void
}

define i32 @phi_gep_before_icmp(i32 %0) {
; X64-LABEL: phi_gep_before_icmp>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    push r12
; X64-NEXT:    push r13
; X64-NEXT:    nop dword ptr [rax]
; X64-NEXT:    sub rsp, 0x28
; X64-NEXT:    mov ebx, edi
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    jne <L0>
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    mov r12d, eax
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    lea rax, [rax + 0x1200]
; X64-NEXT:    mov ecx, 0x0
; X64-NEXT:    cmp ecx, 0x0
; X64-NEXT:    jne <L2>
; X64-NEXT:    mov r12d, ebx
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L2>:
; X64-NEXT:    mov r13, rax
; X64-NEXT:  <L4>:
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    jne <L3>
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    mov r13, rax
; X64-NEXT:    jmp <L4>
; X64-NEXT:  <L3>:
; X64-NEXT:    mov r12d, ebx
; X64-NEXT:  <L1>:
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    add rsp, 0x28
; X64-NEXT:    pop r13
; X64-NEXT:    pop r12
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    nop
;
; ARM64-LABEL: phi_gep_before_icmp>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    stp x19, x20, [sp, #0x10]
; ARM64-NEXT:    str x21, [sp, #0x20]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov w19, w0
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.ne 0x7ec <phi_gep_before_icmp+0x3c>
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    mov w20, w0
; ARM64-NEXT:    b 0x82c <phi_gep_before_icmp+0x7c>
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    mov x0, x0
; ARM64-NEXT:    mov x1, #0x1200 // =4608
; ARM64-NEXT:    add x0, x0, x1
; ARM64-NEXT:    mov w1, #0x0 // =0
; ARM64-NEXT:    cbnz w1, 0x80c <phi_gep_before_icmp+0x5c>
; ARM64-NEXT:    mov w20, w19
; ARM64-NEXT:    b 0x82c <phi_gep_before_icmp+0x7c>
; ARM64-NEXT:    mov x21, x0
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.ne 0x828 <phi_gep_before_icmp+0x78>
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    mov x21, x0
; ARM64-NEXT:    b 0x810 <phi_gep_before_icmp+0x60>
; ARM64-NEXT:    mov w20, w19
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldp x19, x20, [sp, #0x10]
; ARM64-NEXT:    ldr x21, [sp, #0x20]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
; ARM64-NEXT:     ...
  br i1 false, label %2, label %6

2:                                                ; preds = %1
  %3 = icmp eq i32 0, 0
  br i1 %3, label %6, label %4

4:                                                ; preds = %4, %2
  %5 = phi ptr [ null, %4 ], [ getelementptr inbounds (i8, ptr null, i64 4608), %2 ]
  br i1 false, label %6, label %4

6:                                                ; preds = %4, %2, %1
  %7 = phi i32 [ 0, %1 ], [ %0, %2 ], [ %0, %4 ]
  ret i32 0
}

define void @phi_gep_before_icmp_twice() {
; X64-LABEL: phi_gep_before_icmp_twice>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    push r12
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x40
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    lea rax, [rax + 0xa]
; X64-NEXT:    mov ecx, 0x0
; X64-NEXT:    lea rcx, [rcx + 0xa]
; X64-NEXT:    mov edx, 0x0
; X64-NEXT:    cmp rdx, 0x0
; X64-NEXT:    mov edx, 0x0
; X64-NEXT:    setl dl
; X64-NEXT:    mov edx, 0x0
; X64-NEXT:    test edx, 0x1
; X64-NEXT:    je <L0>
; X64-NEXT:    mov rbx, rax
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    mov r12, rcx
; X64-NEXT:  <L3>:
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    jne <L2>
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    mov r12, rax
; X64-NEXT:    jmp <L3>
; X64-NEXT:  <L2>:
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    mov rbx, rax
; X64-NEXT:  <L1>:
; X64-NEXT:    jmp <L1>
;
; ARM64-LABEL: phi_gep_before_icmp_twice>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    stp x19, x20, [sp, #0x10]
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    add x0, x0, #0xa
; ARM64-NEXT:    mov w1, #0x0 // =0
; ARM64-NEXT:    add x1, x1, #0xa
; ARM64-NEXT:    mov w2, #0x0 // =0
; ARM64-NEXT:    cmp x2, #0x0
; ARM64-NEXT:    cset w2, lt
; ARM64-NEXT:    mov w2, #0x0 // =0
; ARM64-NEXT:    tst w2, #0x1
; ARM64-NEXT:    b.eq 0x8c0 <phi_gep_before_icmp_twice+0x40>
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    b 0x8e4 <phi_gep_before_icmp_twice+0x64>
; ARM64-NEXT:    mov x20, x1
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.ne 0x8dc <phi_gep_before_icmp_twice+0x5c>
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    mov x20, x0
; ARM64-NEXT:    b 0x8c4 <phi_gep_before_icmp_twice+0x44>
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    b 0x8e4 <phi_gep_before_icmp_twice+0x64>
  br label %1

1:                                                ; No predecessors!
  %2 = icmp slt i64 0, 0
  br i1 false, label %5, label %3

3:                                                ; preds = %3, %1
  %4 = phi ptr [ null, %3 ], [ getelementptr inbounds (i8, ptr null, i64 10), %1 ]
  br i1 false, label %5, label %3

5:                                                ; preds = %3, %1
  %6 = phi ptr [ getelementptr inbounds (i8, ptr null, i64 10), %1 ], [ null, %3 ]
  br label %7

7:                                                ; preds = %7, %5
  br label %7
}

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
