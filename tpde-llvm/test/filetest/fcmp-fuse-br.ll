; NOTE: Assertions have been autogenerated by test/update_tpde_llc_test_checks.py UTC_ARGS: --version 5
; SPDX-License-Identifier: LicenseRef-Proprietary

; RUN: tpde-llc --target=x86_64 %s | %objdump | FileCheck %s -check-prefixes=X64
; RUN: tpde-llc --target=aarch64 %s | %objdump | FileCheck %s -check-prefixes=ARM64

define void @fcmp_false_f32_br(float, float, ptr %p) {
; X64-LABEL: <fcmp_false_f32_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movd dword ptr [rbp - 0x30], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:    movd dword ptr [rbp - 0x2c], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movd xmm0, dword ptr [rbp - 0x30]
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_false_f32_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x50 <fcmp_false_f32_br+0x40>
; ARM64-NEXT:    str s8, [x19]
; ARM64-NEXT:    b 0x54 <fcmp_false_f32_br+0x44>
; ARM64-NEXT:    str s9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp false float %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store float %0, ptr %p
  br label %ret
block2:
  store float %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_oeq_f32_br(float, float, ptr %p) {
; X64-LABEL: <fcmp_oeq_f32_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    movapd xmm2, xmm0
; X64-NEXT:    cmpeqss xmm2, xmm1
; X64-NEXT:    movd eax, xmm2
; X64-NEXT:    and eax, 0x1
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movd dword ptr [rbp - 0x30], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movd xmm0, dword ptr [rbp - 0x30]
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <fcmp_oeq_f32_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp s8, s9
; ARM64-NEXT:    cset w0, eq
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0xe4 <fcmp_oeq_f32_br+0x44>
; ARM64-NEXT:    str s8, [x19]
; ARM64-NEXT:    b 0xe8 <fcmp_oeq_f32_br+0x48>
; ARM64-NEXT:    str s9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp oeq float %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store float %0, ptr %p
  br label %ret
block2:
  store float %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_ogt_f32_br(float, float, ptr %p) {
; X64-LABEL: <fcmp_ogt_f32_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomiss xmm0, xmm1
; X64-NEXT:    seta al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movd dword ptr [rbp - 0x30], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movd xmm0, dword ptr [rbp - 0x30]
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_ogt_f32_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp s8, s9
; ARM64-NEXT:    cset w0, gt
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x174 <fcmp_ogt_f32_br+0x44>
; ARM64-NEXT:    str s8, [x19]
; ARM64-NEXT:    b 0x178 <fcmp_ogt_f32_br+0x48>
; ARM64-NEXT:    str s9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp ogt float %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store float %0, ptr %p
  br label %ret
block2:
  store float %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_oge_f32_br(float, float, ptr %p) {
; X64-LABEL: <fcmp_oge_f32_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomiss xmm0, xmm1
; X64-NEXT:    setae al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movd dword ptr [rbp - 0x30], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movd xmm0, dword ptr [rbp - 0x30]
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_oge_f32_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp s8, s9
; ARM64-NEXT:    cset w0, ge
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x204 <fcmp_oge_f32_br+0x44>
; ARM64-NEXT:    str s8, [x19]
; ARM64-NEXT:    b 0x208 <fcmp_oge_f32_br+0x48>
; ARM64-NEXT:    str s9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp oge float %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store float %0, ptr %p
  br label %ret
block2:
  store float %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_olt_f32_br(float, float, ptr %p) {
; X64-LABEL: <fcmp_olt_f32_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomiss xmm1, xmm0
; X64-NEXT:    seta al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movd dword ptr [rbp - 0x30], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movd xmm0, dword ptr [rbp - 0x30]
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_olt_f32_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp s8, s9
; ARM64-NEXT:    cset w0, mi
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x294 <fcmp_olt_f32_br+0x44>
; ARM64-NEXT:    str s8, [x19]
; ARM64-NEXT:    b 0x298 <fcmp_olt_f32_br+0x48>
; ARM64-NEXT:    str s9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp olt float %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store float %0, ptr %p
  br label %ret
block2:
  store float %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_ole_f32_br(float, float, ptr %p) {
; X64-LABEL: <fcmp_ole_f32_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomiss xmm1, xmm0
; X64-NEXT:    setae al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movd dword ptr [rbp - 0x30], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movd xmm0, dword ptr [rbp - 0x30]
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_ole_f32_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp s8, s9
; ARM64-NEXT:    cset w0, ls
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x324 <fcmp_ole_f32_br+0x44>
; ARM64-NEXT:    str s8, [x19]
; ARM64-NEXT:    b 0x328 <fcmp_ole_f32_br+0x48>
; ARM64-NEXT:    str s9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp ole float %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store float %0, ptr %p
  br label %ret
block2:
  store float %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_one_f32_br(float, float, ptr %p) {
; X64-LABEL: <fcmp_one_f32_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomiss xmm0, xmm1
; X64-NEXT:    setne al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movd dword ptr [rbp - 0x30], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movd xmm0, dword ptr [rbp - 0x30]
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_one_f32_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp s8, s9
; ARM64-NEXT:    cset w0, mi
; ARM64-NEXT:    csinc w1, w0, wzr, le
; ARM64-NEXT:    tst w1, #0x1
; ARM64-NEXT:    b.eq 0x3b8 <fcmp_one_f32_br+0x48>
; ARM64-NEXT:    str s8, [x19]
; ARM64-NEXT:    b 0x3bc <fcmp_one_f32_br+0x4c>
; ARM64-NEXT:    str s9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp one float %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store float %0, ptr %p
  br label %ret
block2:
  store float %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_ord_f32_br(float, float, ptr %p) {
; X64-LABEL: <fcmp_ord_f32_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomiss xmm0, xmm1
; X64-NEXT:    setnp al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movd dword ptr [rbp - 0x30], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movd xmm0, dword ptr [rbp - 0x30]
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_ord_f32_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp s8, s9
; ARM64-NEXT:    cset w0, vc
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x444 <fcmp_ord_f32_br+0x44>
; ARM64-NEXT:    str s8, [x19]
; ARM64-NEXT:    b 0x448 <fcmp_ord_f32_br+0x48>
; ARM64-NEXT:    str s9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp ord float %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store float %0, ptr %p
  br label %ret
block2:
  store float %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_ueq_f32_br(float, float, ptr %p) {
; X64-LABEL: <fcmp_ueq_f32_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomiss xmm0, xmm1
; X64-NEXT:    sete al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movd dword ptr [rbp - 0x30], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movd xmm0, dword ptr [rbp - 0x30]
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_ueq_f32_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp s8, s9
; ARM64-NEXT:    cset w0, eq
; ARM64-NEXT:    csinc w1, w0, wzr, vc
; ARM64-NEXT:    tst w1, #0x1
; ARM64-NEXT:    b.eq 0x4d8 <fcmp_ueq_f32_br+0x48>
; ARM64-NEXT:    str s8, [x19]
; ARM64-NEXT:    b 0x4dc <fcmp_ueq_f32_br+0x4c>
; ARM64-NEXT:    str s9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp ueq float %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store float %0, ptr %p
  br label %ret
block2:
  store float %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_ugt_f32_br(float, float, ptr %p) {
; X64-LABEL: <fcmp_ugt_f32_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomiss xmm1, xmm0
; X64-NEXT:    setb al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movd dword ptr [rbp - 0x30], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movd xmm0, dword ptr [rbp - 0x30]
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_ugt_f32_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp s8, s9
; ARM64-NEXT:    cset w0, hi
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x564 <fcmp_ugt_f32_br+0x44>
; ARM64-NEXT:    str s8, [x19]
; ARM64-NEXT:    b 0x568 <fcmp_ugt_f32_br+0x48>
; ARM64-NEXT:    str s9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp ugt float %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store float %0, ptr %p
  br label %ret
block2:
  store float %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_uge_f32_br(float, float, ptr %p) {
; X64-LABEL: <fcmp_uge_f32_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomiss xmm1, xmm0
; X64-NEXT:    setbe al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movd dword ptr [rbp - 0x30], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movd xmm0, dword ptr [rbp - 0x30]
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_uge_f32_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp s8, s9
; ARM64-NEXT:    cset w0, pl
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x5f4 <fcmp_uge_f32_br+0x44>
; ARM64-NEXT:    str s8, [x19]
; ARM64-NEXT:    b 0x5f8 <fcmp_uge_f32_br+0x48>
; ARM64-NEXT:    str s9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp uge float %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store float %0, ptr %p
  br label %ret
block2:
  store float %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_ult_f32_br(float, float, ptr %p) {
; X64-LABEL: <fcmp_ult_f32_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomiss xmm0, xmm1
; X64-NEXT:    setb al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movd dword ptr [rbp - 0x30], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movd xmm0, dword ptr [rbp - 0x30]
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_ult_f32_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp s8, s9
; ARM64-NEXT:    cset w0, lt
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x684 <fcmp_ult_f32_br+0x44>
; ARM64-NEXT:    str s8, [x19]
; ARM64-NEXT:    b 0x688 <fcmp_ult_f32_br+0x48>
; ARM64-NEXT:    str s9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp ult float %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store float %0, ptr %p
  br label %ret
block2:
  store float %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_ule_f32_br(float, float, ptr %p) {
; X64-LABEL: <fcmp_ule_f32_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomiss xmm0, xmm1
; X64-NEXT:    setbe al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movd dword ptr [rbp - 0x30], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movd xmm0, dword ptr [rbp - 0x30]
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_ule_f32_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp s8, s9
; ARM64-NEXT:    cset w0, le
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x714 <fcmp_ule_f32_br+0x44>
; ARM64-NEXT:    str s8, [x19]
; ARM64-NEXT:    b 0x718 <fcmp_ule_f32_br+0x48>
; ARM64-NEXT:    str s9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp ule float %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store float %0, ptr %p
  br label %ret
block2:
  store float %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_une_f32_br(float, float, ptr %p) {
; X64-LABEL: <fcmp_une_f32_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    movapd xmm2, xmm0
; X64-NEXT:    cmpneqss xmm2, xmm1
; X64-NEXT:    movd eax, xmm2
; X64-NEXT:    and eax, 0x1
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movd dword ptr [rbp - 0x30], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movd xmm0, dword ptr [rbp - 0x30]
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <fcmp_une_f32_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp s8, s9
; ARM64-NEXT:    cset w0, ne
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x7a4 <fcmp_une_f32_br+0x44>
; ARM64-NEXT:    str s8, [x19]
; ARM64-NEXT:    b 0x7a8 <fcmp_une_f32_br+0x48>
; ARM64-NEXT:    str s9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp une float %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store float %0, ptr %p
  br label %ret
block2:
  store float %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_uno_f32_br(float, float, ptr %p) {
; X64-LABEL: <fcmp_uno_f32_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomiss xmm0, xmm1
; X64-NEXT:    setp al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movd dword ptr [rbp - 0x30], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movd xmm0, dword ptr [rbp - 0x30]
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_uno_f32_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp s8, s9
; ARM64-NEXT:    cset w0, vs
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x834 <fcmp_uno_f32_br+0x44>
; ARM64-NEXT:    str s8, [x19]
; ARM64-NEXT:    b 0x838 <fcmp_uno_f32_br+0x48>
; ARM64-NEXT:    str s9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp uno float %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store float %0, ptr %p
  br label %ret
block2:
  store float %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_true_f32_br(float, float, ptr %p) {
; X64-LABEL: <fcmp_true_f32_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x38
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    mov eax, 0x1
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movd dword ptr [rbp - 0x30], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:    movd dword ptr [rbp - 0x2c], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movd xmm0, dword ptr [rbp - 0x30]
; X64-NEXT:    movss dword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x38
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_true_f32_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    mov x0, #0x1 // =1
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x8c0 <fcmp_true_f32_br+0x40>
; ARM64-NEXT:    str s8, [x19]
; ARM64-NEXT:    b 0x8c4 <fcmp_true_f32_br+0x44>
; ARM64-NEXT:    str s9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp true float %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store float %0, ptr %p
  br label %ret
block2:
  store float %1, ptr %p
  br label %ret
ret:
  ret void
}


define void @fcmp_false_f64_br(double, double, ptr %p) {
; X64-LABEL: <fcmp_false_f64_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    mov eax, 0x0
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movq qword ptr [rbp - 0x38], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:    movq qword ptr [rbp - 0x30], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movq xmm0, qword ptr [rbp - 0x38]
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax]
;
; ARM64-LABEL: <fcmp_false_f64_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    stp d8, d9, [sp, #0x18]
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    nop
; ARM64-NEXT:    mov v8.16b, v0.16b
; ARM64-NEXT:    mov v9.16b, v1.16b
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    mov w0, #0x0 // =0
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    b.eq 0x950 <fcmp_false_f64_br+0x40>
; ARM64-NEXT:    str d8, [x19]
; ARM64-NEXT:    b 0x954 <fcmp_false_f64_br+0x44>
; ARM64-NEXT:    str d9, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    ldp d8, d9, [sp, #0x18]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp false double %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store double %0, ptr %p
  br label %ret
block2:
  store double %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_oeq_f64_br(double, double, ptr %p) {
; X64-LABEL: <fcmp_oeq_f64_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    movapd xmm2, xmm0
; X64-NEXT:    cmpeqsd xmm2, xmm1
; X64-NEXT:    movq rax, xmm2
; X64-NEXT:    and eax, 0x1
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movq qword ptr [rbp - 0x38], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movq xmm0, qword ptr [rbp - 0x38]
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    nop dword ptr [rax]
;
; ARM64-LABEL: <fcmp_oeq_f64_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp d0, d1
; ARM64-NEXT:    cset w0, eq
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    str d1, [x29, #0xa8]
; ARM64-NEXT:    b.eq 0x9e0 <fcmp_oeq_f64_br+0x30>
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    b 0x9e8 <fcmp_oeq_f64_br+0x38>
; ARM64-NEXT:    ldr d0, [x29, #0xa8]
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp oeq double %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store double %0, ptr %p
  br label %ret
block2:
  store double %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_ogt_f64_br(double, double, ptr %p) {
; X64-LABEL: <fcmp_ogt_f64_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomisd xmm0, xmm1
; X64-NEXT:    seta al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movq qword ptr [rbp - 0x38], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movq xmm0, qword ptr [rbp - 0x38]
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_ogt_f64_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp d0, d1
; ARM64-NEXT:    cset w0, gt
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    str d1, [x29, #0xa8]
; ARM64-NEXT:    b.eq 0xa70 <fcmp_ogt_f64_br+0x30>
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    b 0xa78 <fcmp_ogt_f64_br+0x38>
; ARM64-NEXT:    ldr d0, [x29, #0xa8]
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp ogt double %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store double %0, ptr %p
  br label %ret
block2:
  store double %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_oge_f64_br(double, double, ptr %p) {
; X64-LABEL: <fcmp_oge_f64_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomisd xmm0, xmm1
; X64-NEXT:    setae al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movq qword ptr [rbp - 0x38], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movq xmm0, qword ptr [rbp - 0x38]
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_oge_f64_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp d0, d1
; ARM64-NEXT:    cset w0, ge
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    str d1, [x29, #0xa8]
; ARM64-NEXT:    b.eq 0xb00 <fcmp_oge_f64_br+0x30>
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    b 0xb08 <fcmp_oge_f64_br+0x38>
; ARM64-NEXT:    ldr d0, [x29, #0xa8]
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp oge double %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store double %0, ptr %p
  br label %ret
block2:
  store double %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_olt_f64_br(double, double, ptr %p) {
; X64-LABEL: <fcmp_olt_f64_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomisd xmm1, xmm0
; X64-NEXT:    seta al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movq qword ptr [rbp - 0x38], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movq xmm0, qword ptr [rbp - 0x38]
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_olt_f64_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp d0, d1
; ARM64-NEXT:    cset w0, mi
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    str d1, [x29, #0xa8]
; ARM64-NEXT:    b.eq 0xb90 <fcmp_olt_f64_br+0x30>
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    b 0xb98 <fcmp_olt_f64_br+0x38>
; ARM64-NEXT:    ldr d0, [x29, #0xa8]
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp olt double %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store double %0, ptr %p
  br label %ret
block2:
  store double %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_ole_f64_br(double, double, ptr %p) {
; X64-LABEL: <fcmp_ole_f64_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomisd xmm1, xmm0
; X64-NEXT:    setae al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movq qword ptr [rbp - 0x38], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movq xmm0, qword ptr [rbp - 0x38]
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_ole_f64_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp d0, d1
; ARM64-NEXT:    cset w0, ls
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    str d1, [x29, #0xa8]
; ARM64-NEXT:    b.eq 0xc20 <fcmp_ole_f64_br+0x30>
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    b 0xc28 <fcmp_ole_f64_br+0x38>
; ARM64-NEXT:    ldr d0, [x29, #0xa8]
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp ole double %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store double %0, ptr %p
  br label %ret
block2:
  store double %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_one_f64_br(double, double, ptr %p) {
; X64-LABEL: <fcmp_one_f64_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomisd xmm0, xmm1
; X64-NEXT:    setne al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movq qword ptr [rbp - 0x38], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movq xmm0, qword ptr [rbp - 0x38]
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_one_f64_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp d0, d1
; ARM64-NEXT:    cset w0, mi
; ARM64-NEXT:    csinc w1, w0, wzr, le
; ARM64-NEXT:    tst w1, #0x1
; ARM64-NEXT:    str d1, [x29, #0xa8]
; ARM64-NEXT:    b.eq 0xcb4 <fcmp_one_f64_br+0x34>
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    b 0xcbc <fcmp_one_f64_br+0x3c>
; ARM64-NEXT:    ldr d0, [x29, #0xa8]
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp one double %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store double %0, ptr %p
  br label %ret
block2:
  store double %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_ord_f64_br(double, double, ptr %p) {
; X64-LABEL: <fcmp_ord_f64_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomisd xmm0, xmm1
; X64-NEXT:    setnp al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movq qword ptr [rbp - 0x38], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movq xmm0, qword ptr [rbp - 0x38]
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_ord_f64_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp d0, d1
; ARM64-NEXT:    cset w0, vc
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    str d1, [x29, #0xa8]
; ARM64-NEXT:    b.eq 0xd40 <fcmp_ord_f64_br+0x30>
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    b 0xd48 <fcmp_ord_f64_br+0x38>
; ARM64-NEXT:    ldr d0, [x29, #0xa8]
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp ord double %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store double %0, ptr %p
  br label %ret
block2:
  store double %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_ueq_f64_br(double, double, ptr %p) {
; X64-LABEL: <fcmp_ueq_f64_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomisd xmm0, xmm1
; X64-NEXT:    sete al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movq qword ptr [rbp - 0x38], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movq xmm0, qword ptr [rbp - 0x38]
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_ueq_f64_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp d0, d1
; ARM64-NEXT:    cset w0, eq
; ARM64-NEXT:    csinc w1, w0, wzr, vc
; ARM64-NEXT:    tst w1, #0x1
; ARM64-NEXT:    str d1, [x29, #0xa8]
; ARM64-NEXT:    b.eq 0xdd4 <fcmp_ueq_f64_br+0x34>
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    b 0xddc <fcmp_ueq_f64_br+0x3c>
; ARM64-NEXT:    ldr d0, [x29, #0xa8]
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp ueq double %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store double %0, ptr %p
  br label %ret
block2:
  store double %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_ugt_f64_br(double, double, ptr %p) {
; X64-LABEL: <fcmp_ugt_f64_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomisd xmm1, xmm0
; X64-NEXT:    setb al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movq qword ptr [rbp - 0x38], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movq xmm0, qword ptr [rbp - 0x38]
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_ugt_f64_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp d0, d1
; ARM64-NEXT:    cset w0, hi
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    str d1, [x29, #0xa8]
; ARM64-NEXT:    b.eq 0xe60 <fcmp_ugt_f64_br+0x30>
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    b 0xe68 <fcmp_ugt_f64_br+0x38>
; ARM64-NEXT:    ldr d0, [x29, #0xa8]
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp ugt double %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store double %0, ptr %p
  br label %ret
block2:
  store double %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_uge_f64_br(double, double, ptr %p) {
; X64-LABEL: <fcmp_uge_f64_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomisd xmm1, xmm0
; X64-NEXT:    setbe al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movq qword ptr [rbp - 0x38], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movq xmm0, qword ptr [rbp - 0x38]
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_uge_f64_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp d0, d1
; ARM64-NEXT:    cset w0, pl
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    str d1, [x29, #0xa8]
; ARM64-NEXT:    b.eq 0xef0 <fcmp_uge_f64_br+0x30>
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    b 0xef8 <fcmp_uge_f64_br+0x38>
; ARM64-NEXT:    ldr d0, [x29, #0xa8]
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp uge double %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store double %0, ptr %p
  br label %ret
block2:
  store double %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_ult_f64_br(double, double, ptr %p) {
; X64-LABEL: <fcmp_ult_f64_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomisd xmm0, xmm1
; X64-NEXT:    setb al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movq qword ptr [rbp - 0x38], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movq xmm0, qword ptr [rbp - 0x38]
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_ult_f64_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp d0, d1
; ARM64-NEXT:    cset w0, lt
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    str d1, [x29, #0xa8]
; ARM64-NEXT:    b.eq 0xf80 <fcmp_ult_f64_br+0x30>
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    b 0xf88 <fcmp_ult_f64_br+0x38>
; ARM64-NEXT:    ldr d0, [x29, #0xa8]
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp ult double %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store double %0, ptr %p
  br label %ret
block2:
  store double %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_ule_f64_br(double, double, ptr %p) {
; X64-LABEL: <fcmp_ule_f64_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomisd xmm0, xmm1
; X64-NEXT:    setbe al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movq qword ptr [rbp - 0x38], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movq xmm0, qword ptr [rbp - 0x38]
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_ule_f64_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp d0, d1
; ARM64-NEXT:    cset w0, le
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    str d1, [x29, #0xa8]
; ARM64-NEXT:    b.eq 0x1010 <fcmp_ule_f64_br+0x30>
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    b 0x1018 <fcmp_ule_f64_br+0x38>
; ARM64-NEXT:    ldr d0, [x29, #0xa8]
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp ule double %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store double %0, ptr %p
  br label %ret
block2:
  store double %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_une_f64_br(double, double, ptr %p) {
; X64-LABEL: <fcmp_une_f64_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    movapd xmm2, xmm0
; X64-NEXT:    cmpneqsd xmm2, xmm1
; X64-NEXT:    movq rax, xmm2
; X64-NEXT:    and eax, 0x1
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movq qword ptr [rbp - 0x38], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movq xmm0, qword ptr [rbp - 0x38]
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop word ptr [rax + rax]
; X64-NEXT:    nop dword ptr [rax]
;
; ARM64-LABEL: <fcmp_une_f64_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp d0, d1
; ARM64-NEXT:    cset w0, ne
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    str d1, [x29, #0xa8]
; ARM64-NEXT:    b.eq 0x10a0 <fcmp_une_f64_br+0x30>
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    b 0x10a8 <fcmp_une_f64_br+0x38>
; ARM64-NEXT:    ldr d0, [x29, #0xa8]
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp une double %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store double %0, ptr %p
  br label %ret
block2:
  store double %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_uno_f64_br(double, double, ptr %p) {
; X64-LABEL: <fcmp_uno_f64_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    xor eax, eax
; X64-NEXT:    ucomisd xmm0, xmm1
; X64-NEXT:    setp al
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movq qword ptr [rbp - 0x38], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movq xmm0, qword ptr [rbp - 0x38]
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
; X64-NEXT:    nop dword ptr [rax + rax]
;
; ARM64-LABEL: <fcmp_uno_f64_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    fcmp d0, d1
; ARM64-NEXT:    cset w0, vs
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    str d1, [x29, #0xa8]
; ARM64-NEXT:    b.eq 0x1130 <fcmp_uno_f64_br+0x30>
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    b 0x1138 <fcmp_uno_f64_br+0x38>
; ARM64-NEXT:    ldr d0, [x29, #0xa8]
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp uno double %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store double %0, ptr %p
  br label %ret
block2:
  store double %1, ptr %p
  br label %ret
ret:
  ret void
}

define void @fcmp_true_f64_br(double, double, ptr %p) {
; X64-LABEL: <fcmp_true_f64_br>:
; X64:         push rbp
; X64-NEXT:    mov rbp, rsp
; X64-NEXT:    push rbx
; X64-NEXT:    nop dword ptr [rax + rax]
; X64-NEXT:    sub rsp, 0x48
; X64-NEXT:    mov rbx, rdi
; X64-NEXT:    mov eax, 0x1
; X64-NEXT:    test eax, 0x1
; X64-NEXT:    movq qword ptr [rbp - 0x38], xmm1
; X64-NEXT:    je <L0>
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:    movq qword ptr [rbp - 0x30], xmm0
; X64-NEXT:    jmp <L1>
; X64-NEXT:  <L0>:
; X64-NEXT:    movq xmm0, qword ptr [rbp - 0x38]
; X64-NEXT:    movsd qword ptr [rbx], xmm0
; X64-NEXT:  <L1>:
; X64-NEXT:    add rsp, 0x48
; X64-NEXT:    pop rbx
; X64-NEXT:    pop rbp
; X64-NEXT:    ret
;
; ARM64-LABEL: <fcmp_true_f64_br>:
; ARM64:         sub sp, sp, #0xc0
; ARM64-NEXT:    stp x29, x30, [sp]
; ARM64-NEXT:    mov x29, sp
; ARM64-NEXT:    str x19, [sp, #0x10]
; ARM64-NEXT:    mov x19, x0
; ARM64-NEXT:    mov x0, #0x1 // =1
; ARM64-NEXT:    tst w0, #0x1
; ARM64-NEXT:    str d1, [x29, #0xa8]
; ARM64-NEXT:    b.eq 0x11c0 <fcmp_true_f64_br+0x30>
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    str d0, [x29, #0xa0]
; ARM64-NEXT:    b 0x11c8 <fcmp_true_f64_br+0x38>
; ARM64-NEXT:    ldr d0, [x29, #0xa8]
; ARM64-NEXT:    str d0, [x19]
; ARM64-NEXT:    ldp x29, x30, [sp]
; ARM64-NEXT:    ldr x19, [sp, #0x10]
; ARM64-NEXT:    add sp, sp, #0xc0
; ARM64-NEXT:    ret
  %c = fcmp true double %0, %1
  br i1 %c, label %block1, label %block2
block1:
  store double %0, ptr %p
  br label %ret
block2:
  store double %1, ptr %p
  br label %ret
ret:
  ret void
}
