; NOTE: Assertions have been autogenerated by utils/update_tpde_llvm_test_checks.py UTC_ARGS: --tool tpde_llvm --default-march x86-64-v2 --filter-out "int3" --version 5
; SPDX-FileCopyrightText: 2024 Tobias Schwarz <tobias.schwarz@tum.de>
;
; SPDX-License-Identifier: LicenseRef-Proprietary

; RUN: tpde_llvm %s | llvm-objdump -d -r --no-show-raw-insn --symbolize-operands --no-addresses --x86-asm-syntax=intel - | FileCheck %s -check-prefixes=X64,CHECK --enable-var-scope --dump-input always

; TODO(ts): datalayout depending on arch?
; target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"


define i8 @load_i8(ptr %a) {
; X64-LABEL: load_i8>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movzx edi, byte ptr [rdi]
; X64:    mov eax, edi
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rbp + 0x48], dl
entry:
  %b = load i8, ptr %a, align 1
  ret i8 %b
}

define i8 @load_i8_alt(ptr %a) {
; X64-LABEL: load_i8_alt>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movzx eax, byte ptr [rdi]
; X64:    movzx edi, byte ptr [rdi]
; X64:    mov eax, edi
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
entry:
  %b = load i8, ptr %a, align 1
  %c = load i8, ptr %a, align 1
  ret i8 %c
}


define i16 @load_i16(ptr %a) {
; X64-LABEL: load_i16>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movzx edi, word ptr [rdi]
; X64:    mov eax, edi
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rbp + 0x48], dl
entry:
  %b = load i16, ptr %a, align 2
  ret i16 %b
}

define i16 @load_i16_alt(ptr %a) {
; X64-LABEL: load_i16_alt>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movzx eax, word ptr [rdi]
; X64:    movzx edi, word ptr [rdi]
; X64:    mov eax, edi
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
entry:
  %b = load i16, ptr %a, align 2
  %c = load i16, ptr %a, align 2
  ret i16 %c
}


define i24 @load_i24(ptr %a) {
; X64-LABEL: load_i24>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movzx eax, word ptr [rdi]
; X64:    movzx edi, byte ptr [rdi + 0x2]
; X64:    shl edi, 0x10
; X64:    or edi, eax
; X64:    mov eax, edi
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:     ...
entry:
  %b = load i24, ptr %a, align 2
  ret i24 %b
}

define i24 @load_i24_alt(ptr %a) {
; X64-LABEL: load_i24_alt>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movzx eax, word ptr [rdi]
; X64:    movzx ecx, byte ptr [rdi + 0x2]
; X64:    shl ecx, 0x10
; X64:    or ecx, eax
; X64:    movzx eax, word ptr [rdi]
; X64:    movzx edi, byte ptr [rdi + 0x2]
; X64:    shl edi, 0x10
; X64:    or edi, eax
; X64:    mov eax, edi
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
entry:
  %b = load i24, ptr %a, align 2
  %c = load i24, ptr %a, align 2
  ret i24 %c
}


define i32 @load_i32(ptr %a) {
; X64-LABEL: load_i32>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov edi, dword ptr [rdi]
; X64:    mov eax, edi
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
entry:
  %b = load i32, ptr %a, align 4
  ret i32 %b
}

define i32 @load_i32_alt(ptr %a) {
; X64-LABEL: load_i32_alt>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov eax, dword ptr [rdi]
; X64:    mov edi, dword ptr [rdi]
; X64:    mov eax, edi
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
entry:
  %b = load i32, ptr %a, align 4
  %c = load i32, ptr %a, align 4
  ret i32 %c
}


define i40 @load_i40(ptr %a) {
; X64-LABEL: load_i40>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov eax, dword ptr [rdi]
; X64:    movzx edi, byte ptr [rdi + 0x4]
; X64:    shl rdi, 0x20
; X64:    or rdi, rax
; X64:    mov rax, rdi
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rax], al
entry:
  %b = load i40, ptr %a, align 2
  ret i40 %b
}

define i40 @load_i40_alt(ptr %a) {
; X64-LABEL: load_i40_alt>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov eax, dword ptr [rdi]
; X64:    movzx ecx, byte ptr [rdi + 0x4]
; X64:    shl rcx, 0x20
; X64:    or rcx, rax
; X64:    mov eax, dword ptr [rdi]
; X64:    movzx edi, byte ptr [rdi + 0x4]
; X64:    shl rdi, 0x20
; X64:    or rdi, rax
; X64:    mov rax, rdi
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rbp + 0x48], dl
entry:
  %b = load i40, ptr %a, align 2
  %c = load i40, ptr %a, align 2
  ret i40 %c
}


define i48 @load_i48(ptr %a) {
; X64-LABEL: load_i48>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov eax, dword ptr [rdi]
; X64:    movzx edi, word ptr [rdi + 0x4]
; X64:    shl rdi, 0x20
; X64:    or rdi, rax
; X64:    mov rax, rdi
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rax], al
entry:
  %b = load i48, ptr %a, align 2
  ret i48 %b
}

define i48 @load_i48_alt(ptr %a) {
; X64-LABEL: load_i48_alt>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov eax, dword ptr [rdi]
; X64:    movzx ecx, word ptr [rdi + 0x4]
; X64:    shl rcx, 0x20
; X64:    or rcx, rax
; X64:    mov eax, dword ptr [rdi]
; X64:    movzx edi, word ptr [rdi + 0x4]
; X64:    shl rdi, 0x20
; X64:    or rdi, rax
; X64:    mov rax, rdi
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rbp + 0x48], dl
entry:
  %b = load i48, ptr %a, align 2
  %c = load i48, ptr %a, align 2
  ret i48 %c
}


define i56 @load_i56(ptr %a) {
; X64-LABEL: load_i56>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movzx eax, word ptr [rdi + 0x4]
; X64:    movzx ecx, byte ptr [rdi + 0x6]
; X64:    shl ecx, 0x10
; X64:    or ecx, eax
; X64:    shl rcx, 0x20
; X64:    mov eax, dword ptr [rdi]
; X64:    or rax, rcx
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
entry:
  %b = load i56, ptr %a, align 2
  ret i56 %b
}

define i56 @load_i56_alt(ptr %a) {
; X64-LABEL: load_i56_alt>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movzx eax, word ptr [rdi + 0x4]
; X64:    movzx ecx, byte ptr [rdi + 0x6]
; X64:    shl ecx, 0x10
; X64:    or ecx, eax
; X64:    shl rcx, 0x20
; X64:    mov eax, dword ptr [rdi]
; X64:    or rax, rcx
; X64:    movzx eax, word ptr [rdi + 0x4]
; X64:    movzx ecx, byte ptr [rdi + 0x6]
; X64:    shl ecx, 0x10
; X64:    or ecx, eax
; X64:    shl rcx, 0x20
; X64:    mov eax, dword ptr [rdi]
; X64:    or rax, rcx
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rax], al
entry:
  %b = load i56, ptr %a, align 2
  %c = load i56, ptr %a, align 2
  ret i56 %c
}


define i64 @load_i64(ptr %a) {
; X64-LABEL: load_i64>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov rdi, qword ptr [rdi]
; X64:    mov rax, rdi
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
entry:
  %b = load i64, ptr %a, align 8
  ret i64 %b
}

define i64 @load_i64_alt(ptr %a) {
; X64-LABEL: load_i64_alt>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov rax, qword ptr [rdi]
; X64:    mov rdi, qword ptr [rdi]
; X64:    mov rax, rdi
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rbp + 0x48], dl
entry:
  %b = load i64, ptr %a, align 8
  %c = load i64, ptr %a, align 8
  ret i64 %c
}


define i128 @load_i128(ptr %a) {
; X64-LABEL: load_i128>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov rax, qword ptr [rdi]
; X64:    mov rdi, qword ptr [rdi + 0x8]
; X64:    mov rdx, rdi
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
entry:
  %b = load i128, ptr %a, align 8
  ret i128 %b
}

define i128 @load_i128_alt(ptr %a) {
; X64-LABEL: load_i128_alt>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov rax, qword ptr [rdi]
; X64:    mov rcx, qword ptr [rdi + 0x8]
; X64:    mov rax, qword ptr [rdi]
; X64:    mov rdi, qword ptr [rdi + 0x8]
; X64:    mov rdx, rdi
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rbp + 0x48], dl
entry:
  %b = load i128, ptr %a, align 8
  %c = load i128, ptr %a, align 8
  ret i128 %c
}


define float @load_float(ptr %a) {
; X64-LABEL: load_float>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movss xmm0, dword ptr [rdi]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
entry:
  %b = load float, ptr %a, align 4
  ret float %b
}

define float @load_float_alt(ptr %a) {
; X64-LABEL: load_float_alt>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movss xmm0, dword ptr [rdi]
; X64:    movss xmm0, dword ptr [rdi]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
entry:
  %b = load float, ptr %a, align 4
  %c = load float, ptr %a, align 4
  ret float %c
}


define double @load_double(ptr %a) {
; X64-LABEL: load_double>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movsd xmm0, qword ptr [rdi]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
entry:
  %b = load double, ptr %a, align 8
  ret double %b
}

define double @load_double_alt(ptr %a) {
; X64-LABEL: load_double_alt>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movsd xmm0, qword ptr [rdi]
; X64:    movsd xmm0, qword ptr [rdi]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
entry:
  %b = load double, ptr %a, align 8
  %c = load double, ptr %a, align 8
  ret double %c
}


define <4 x float> @load_4f(ptr %a) {
; X64-LABEL: load_4f>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movaps xmm0, xmmword ptr [rdi]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rbp + 0x48], dl
entry:
  %b = load <4 x float>, ptr %a, align 8
  ret <4 x float> %b
}

define <4 x float> @load_4f_alt(ptr %a) {
; X64-LABEL: load_4f_alt>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movaps xmm0, xmmword ptr [rdi]
; X64:    movaps xmm0, xmmword ptr [rdi]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
entry:
  %b = load <4 x float>, ptr %a, align 8
  %c = load <4 x float>, ptr %a, align 8
  ret <4 x float> %c
}


%struct.i8_i1 = type { i8, i1 }
%struct.i8_i8 = type { i8, i8 }
%struct.i8_i16 = type { i8, i16 }
%struct.i8_i32 = type { i8, i32 }
%struct.i8_i64 = type { i8, i64 }

%struct.i1_i32 = type { i1, i32 }
%struct.i16_i32 = type { i16, i32 }
%struct.i32_i32 = type { i32, i32 }
%struct.i64_i32 = type { i64, i32 }

%struct.ptr_i32 = type { ptr, i32 }
%struct.i32_ptr = type { i32, ptr }

%struct.f32_ptr = type { float, ptr }
%struct.i128_i1 = type { i128, i1 }

%struct.i32_i32_i32_i32_i32_i32 = type { i32, i32, i32, i32, i32, i32 }

define void @load_struct_i8_i1(ptr %0) {
; X64-LABEL: load_struct_i8_i1>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movzx eax, byte ptr [rdi]
; X64:    movzx ecx, byte ptr [rdi + 0x1]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rbp + 0x48], dl
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldrb w0
; A64: ldrb [[REG:w[0-9]+]], [x0]
; A64-NOT: ldrb [[REG]]
; A64-NEXT: ldrb {{w[0-9]+}}, [x0, #0x1]
; A64-NEXT: add sp
    %1 = load %struct.i8_i1, ptr %0
    ret void
}

define void @load_struct_i8_i8(ptr %0) {
; X64-LABEL: load_struct_i8_i8>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movzx eax, byte ptr [rdi]
; X64:    movzx ecx, byte ptr [rdi + 0x1]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rbp + 0x48], dl
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldrb w0
; A64: ldrb [[REG:w[0-9]+]], [x0]
; A64-NOT: ldrb [[REG]]
; A64-NEXT: ldrb {{w[0-9]+}}, [x0, #0x1]
; A64-NEXT: add sp
    %1 = load %struct.i8_i8, ptr %0
    ret void
}

define void @load_struct_i8_i16(ptr %0) {
; X64-LABEL: load_struct_i8_i16>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movzx eax, byte ptr [rdi]
; X64:    movzx ecx, word ptr [rdi + 0x2]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rbp + 0x48], dl
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldrb w0
; A64: ldrb [[REG:w[0-9]+]], [x0]
; A64-NOT: ldrh [[REG]]
; A64-NEXT: ldrh {{w[0-9]+}}, [x0, #0x2]
; A64-NEXT: add sp
    %1 = load %struct.i8_i16, ptr %0
    ret void
}

define void @load_struct_i8_i32(ptr %0) {
; X64-LABEL: load_struct_i8_i32>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movzx eax, byte ptr [rdi]
; X64:    mov ecx, dword ptr [rdi + 0x4]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldrb w0
; A64: ldrb [[REG:w[0-9]+]], [x0]
; A64-NOT: ldr [[REG]]
; A64-NEXT: ldr {{w[0-9]+}}, [x0, #0x4]
; A64-NEXT: add sp
    %1 = load %struct.i8_i32, ptr %0
    ret void
}

define void @load_struct_i8_i64(ptr %0) {
; X64-LABEL: load_struct_i8_i64>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movzx eax, byte ptr [rdi]
; X64:    mov rcx, qword ptr [rdi + 0x8]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rbp + 0x48], dl
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldrb w0
; A64: ldrb w[[REG:[0-9]+]], [x0]
; A64-NOT: ldr x[[REG]]
; A64-NEXT: ldr {{x[0-9]+}}, [x0, #0x8]
; A64-NEXT: add sp
    %1 = load %struct.i8_i64, ptr %0
    ret void
}

define void @load_struct_i1_i32(ptr %0) {
; X64-LABEL: load_struct_i1_i32>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movzx eax, byte ptr [rdi]
; X64:    mov ecx, dword ptr [rdi + 0x4]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldrb w0
; A64: ldrb [[REG:w[0-9]+]], [x0]
; A64-NOT: ldr [[REG]]
; A64-NEXT: ldr {{w[0-9]+}}, [x0, #0x4]
; A64-NEXT: add sp
    %1 = load %struct.i1_i32, ptr %0
    ret void
}

define void @load_struct_i16_i32(ptr %0) {
; X64-LABEL: load_struct_i16_i32>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movzx eax, word ptr [rdi]
; X64:    mov ecx, dword ptr [rdi + 0x4]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldrh w0
; A64: ldrh [[REG:w[0-9]+]], [x0]
; A64-NOT: ldr [[REG]]
; A64-NEXT: ldr {{w[0-9]+}}, [x0, #0x4]
; A64-NEXT: add sp
    %1 = load %struct.i16_i32, ptr %0
    ret void
}

define void @load_struct_i32_i32(ptr %0) {
; X64-LABEL: load_struct_i32_i32>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov eax, dword ptr [rdi]
; X64:    mov ecx, dword ptr [rdi + 0x4]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rbp + 0x48], dl
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldr w0
; A64: ldr [[REG:w[0-9]+]], [x0]
; A64-NOT: ldr [[REG]]
; A64-NEXT: ldr {{w[0-9]+}}, [x0, #0x4]
; A64-NEXT: add sp
    %1 = load %struct.i32_i32, ptr %0
    ret void
}

define void @load_struct_i64_i32(ptr %0) {
; X64-LABEL: load_struct_i64_i32>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov rax, qword ptr [rdi]
; X64:    mov ecx, dword ptr [rdi + 0x8]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldr x0
; A64: ldr x[[REG:[0-9]+]], [x0]
; A64-NOT: ldr w[[REG]]
; A64-NEXT: ldr {{w[0-9]+}}, [x0, #0x8]
; A64-NEXT: add sp
    %1 = load %struct.i64_i32, ptr %0
    ret void
}

define void @load_struct_ptr_i32(ptr %0) {
; X64-LABEL: load_struct_ptr_i32>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov rax, qword ptr [rdi]
; X64:    mov ecx, dword ptr [rdi + 0x8]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldr x0
; A64: ldr x[[REG:[0-9]+]], [x0]
; A64-NOT: ldr w[[REG]]
; A64-NEXT: ldr {{w[0-9]+}}, [x0, #0x8]
; A64-NEXT: add sp
    %1 = load %struct.ptr_i32, ptr %0
    ret void
}

define void @load_struct_i32_ptr(ptr %0) {
; X64-LABEL: load_struct_i32_ptr>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    mov eax, dword ptr [rdi]
; X64:    mov rcx, qword ptr [rdi + 0x8]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rax], al
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldr w0
; A64: ldr w[[REG:[0-9]+]], [x0]
; A64-NOT: ldr x[[REG]]
; A64-NEXT: ldr {{x[0-9]+}}, [x0, #0x8]
; A64-NEXT: add sp
    %1 = load %struct.i32_ptr, ptr %0
    ret void
}

define void @load_struct_f32_ptr(ptr %0) {
; X64-LABEL: load_struct_f32_ptr>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x40
; X64:    movss xmm0, dword ptr [rdi]
; X64:    mov rax, qword ptr [rdi + 0x8]
; X64:    add rsp, 0x40
; X64:    pop rbp
; X64:    ret
; X64:    add byte ptr [rax], al
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldr w0
; A64: ldr w[[REG:[0-9]+]], [x0]
; A64-NOT: ldr x[[REG]]
; A64-NEXT: ldr {{x[0-9]+}}, [x0, #0x8]
; A64-NEXT: add sp
    %1 = load %struct.f32_ptr, ptr %0
    ret void
}

define void @load_struct_i128_i1(ptr %0) {
; X64-LABEL: load_struct_i128_i1>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    nop word ptr [rax + rax]
; X64:    sub rsp, 0x50
; X64:    mov rax, qword ptr [rdi]
; X64:    mov rcx, qword ptr [rdi + 0x8]
; X64:    movzx edx, byte ptr [rdi + 0x10]
; X64:    add rsp, 0x50
; X64:    pop rbp
; X64:    ret
; X64:     ...
; X64:    add byte ptr [rax], al
; X64:    add byte ptr [rbp + 0x48], dl
  entry:
; Make sure we are after the prologue
; A64: sub sp, sp
; A64: sub sp, sp
; A64-NOT: ldr w0
; A64: ldr w[[REG:[0-9]+]], [x0]
; A64-NOT: ldr x[[REG]]
; A64-NEXT: ldr {{x[0-9]+}}, [x0, #0x8]
; A64-NEXT: add sp
    %1 = load %struct.i128_i1, ptr %0
    ret void
}

define void @load_struct_i32_i32_i32_i32_i32_i32(ptr %0) {
; X64-LABEL: load_struct_i32_i32_i32_i32_i32_i32>:
; X64:    push rbp
; X64:    mov rbp, rsp
; X64:    push rbx
; X64:    nop dword ptr [rax + rax]
; X64:    sub rsp, 0x48
; X64:    mov eax, dword ptr [rdi]
; X64:    mov ecx, dword ptr [rdi + 0x4]
; X64:    mov edx, dword ptr [rdi + 0x8]
; X64:    mov ebx, dword ptr [rdi + 0xc]
; X64:    mov esi, dword ptr [rdi + 0x10]
; X64:    mov r8d, dword ptr [rdi + 0x14]
; X64:    add rsp, 0x48
; X64:    pop rbx
; X64:    pop rbp
; X64:    ret
; X64:     ...
  entry:
    %1 = load %struct.i32_i32_i32_i32_i32_i32, ptr %0
    ret void
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
